<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>arm-ws-day2</title>
  <style>
    body {
      max-width: 38rem;
      padding: 2rem;
      margin: auto;
      background-color: #FAF0E6;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
  </style>

</head>
<body>


<div id="header">
<a href="https://rawtext.club/~famubu">Home</a>
 | 
<a href="https://rawtext.club/~famubu/blog/index.html">Blog</a>
 | 
<a href="https://rawtext.club/~famubu/wiki/index.html">Wiki</a>
 | 
<a href="https://rawtext.club/~famubu/about.html">About</a>
</div>


<ul>
    </ul>




<div id="content-container">
<h1 id="workshop-on-arm-based-hpc-day-2">Workshop on ARM based HPC: Day
2</h1>
<ul>
<li>Speaker: Phil Ridley</li>
<li>NSM (National Supercomputing Mission) Industry Talks</li>
<li>NSM Nodal Centres for Training in HPC and AI</li>
<li><a href="https://www.cse.iitm.ac.in/~rupesh/events/arm2021/">Info
link</a></li>
<li>Date: 03-Mar-2021</li>
</ul>
<hr />
<ul>
<li>W register: 32 bits (lower half of X)</li>
<li>X register: 64 bits</li>
<li>D register: 64 bits (lower 64b of Q)</li>
<li>Q register: 128bits (lower half??)</li>
<li>word size : 128 bits?</li>
</ul>
<h2 id="neon-intrinsics">Neon intrinsics</h2>
<ul>
<li>ACLE: ARM C Language Extensions</li>
<li><code>#include arm_neon.h</code></li>
<li>ARM Neon doesnâ€™t have SVE. Only 128b registers.</li>
<li>Advanced SIMD</li>
</ul>
<h2 id="scalable-vector-implementation">Scalable Vector
Implementation</h2>
<ul>
<li>Vector length: hardware implementation choice from 128b to
2048b.</li>
<li>Hardware sets VL.</li>
<li>Software =&gt; vectors have no length.</li>
<li>Same binary code runs on hardware with different VL.</li>
</ul>
<h3 id="vector-length-agnostic">Vector length agnostic</h3>
<ul>
<li>There are programming models that allow software to scale to
available vector length.</li>
<li>No need of new ISA or rewrite or recompile for new vector
lengths.</li>
</ul>
<h3 id="auto-vectorization">Auto-vectorization</h3>
<ul>
<li>Gather-load and scatter-store =&gt; Loads a single register from
multiple scattered locations.</li>
</ul>
<h1 id="sve-vs-traditional-isa">SVE vs traditional ISA</h1>
<ul>
<li>SVE is a predicate-centric architecture</li>
</ul>
<h2 id="per-lane-predication">Per lane predication</h2>
<ul>
<li>Operations are done in individual lanes each under the control of a
predicate register.</li>
</ul>
<h2 id="example">Example</h2>
<ul>
<li>Consider an example with 10 chunks of 4B (ie, 32b each)</li>
</ul>
<h3 id="aarch64-scalar">Aarch64 (Scalar)</h3>
<ul>
<li>10 iterations over a 4B register ### Neon (128b Vector engine)</li>
<li>Two iterations over a 128b register (main loop) + two iterations of
a drain loop over a 4B register ### SVE (128b VLA vector engine)</li>
<li>VLA =&gt; Vector Length Agnostic</li>
<li>Three iterations over a 16B VLA register with an adjustable
predicate.</li>
<li>VLA -&gt; portability, scalability improved</li>
</ul>
<h2 id="sve-registers">SVE registers</h2>
<h3 id="scalable-vector-registers">Scalable vector registers</h3>
<ul>
<li>Z0 to Z31 (Extends V0 to V31 of the NEON architecture)</li>
<li>Packed registers: DP,SP,HP</li>
</ul>
<h3 id="scalable-predicate-registers">Scalable predicate registers</h3>
<ul>
<li>P0-P7 (Predicates for load/store/arithmetic)</li>
<li>P8-P15 (Predicates for loop management)</li>
<li>FFR (First Fault Register for software speculation)</li>
</ul>
<h1 id="vl-vector-length">VL (Vector Length)</h1>
<ul>
<li><p>Set by the CPU architect.</p></li>
<li><p>Any multiple of 128b upto 2048b</p></li>
<li><p>VL can be dynamically adjusted.</p></li>
<li><p>Implementation dependent</p></li>
<li><p>Can be reduced by OS/hypervisor</p></li>
<li><p>Predicates are not bit masks.</p></li>
<li><p>Predicate gives a lot of advantage that the compiler can
use.</p></li>
<li><p>Lanes</p></li>
<li><p>LBB in assembly</p></li>
<li><p>Main loop</p></li>
<li><p>Drain loop: do anything that remains, if any.</p></li>
<li><p>auto vectorization</p></li>
<li><p>AVX in vector implementation</p></li>
<li><p>Disadvantages of a load/store architecture</p></li>
<li><p>software speculation</p></li>
<li><p>Full predicate</p></li>
<li><p>Partial predicate</p></li>
<li><p>A64 conditional instructions</p></li>
<li><p>Hotchips (conference)</p></li>
<li><p>Predicate instructions</p></li>
<li><p>Why double precision for double data type (general NQ)</p></li>
</ul>
<h1 id="aiml-with-arm">AI/ML With ARM</h1>
<ul>
<li><p>gvisor: Container sandbox by Google</p></li>
<li><p>Edge computing</p></li>
<li><p>ad hoc network</p></li>
</ul>
</div>
</body>
</html>
