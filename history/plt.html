<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Programming language theory</title>
  <style>
    body {
      max-width: 38rem;
      padding: 2rem;
      margin: auto;
      background-color: #FAF0E6;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
  </style>

</head>
<body>


<div id="header">
<a href="https://ju-sh.github.io">Home</a>
 | 
<a href="https://ju-sh.github.io/blog/index.html">Blog</a>
 | 
<a href="https://ju-sh.github.io/wiki/index.html">Wiki</a>
 | 
<a href="https://ju-sh.github.io/about.html">About</a>
</div>

<header id="title-block-header">
<h1 class="title">Programming language theory</h1>
</header>

<ul>
    </ul>




<hr/>

<div id="content-container">
<p>An attempt to know what happened when and what influenced development
of what, in the field of logic, programming language theory and verified
software.</p>
<h1 id="timeline">Timeline</h1>
<ul>
<li>350BC: Syllogisms
<ul>
<li>(In Aristotle's <em>Prior analytics</em>)</li>
</ul></li>
<li>300BC: Euclid's <em>Elements</em>
<ul>
<li>(Euclidean geometry)</li>
</ul></li>
<li>1347: Ockham's razor
<ul>
<li>(Old concept got some more attention at this point)</li>
<li>(Prefer the proof with the smallest number of assumptions)</li>
<li>('Simplest explanation is usually the best one')</li>
<li>(Russell: 'Whenever possible, substitute constructions out of known
entities for inferences to unknown entities')</li>
</ul></li>
</ul>
<h2 id="modern">Modern</h2>
<ul>
<li>1847: Boolean algebra developed
<ul>
<li><em>Mathematical Analysis of Logic</em> - George Boole (1847)</li>
<li><em>The Laws of Thought</em> - George Boole (1854)</li>
</ul></li>
<li>1872: 'Ignoramus et ignorabimus' quote by du Bois-Reymond
<ul>
<li>'We don't know and we shall not know'</li>
<li>About the sum of all human knowledge</li>
</ul></li>
<li>1879: <em>Begriffschrift</em> by Gottlob Frege published
<ul>
<li>(Hilbert system: Reliant on axioms)</li>
<li>(First-order symbolic logic)</li>
</ul></li>
<li>1891: Cantor's diagonal argument
<ul>
<li>(Proves that there are uncountable sets)</li>
<li>(ℝ is uncountable)</li>
</ul></li>
<li>1900: Hilbert's problems posed
<ul>
<li>(23 questions)</li>
</ul></li>
<li>1901: Russell's paradox
<ul>
<li>(Had already been discoverd by Ernst Zermelo in 1899)</li>
</ul></li>
<li>1905: Richard's paradox</li>
<li>1908: Russell's type theory
<ul>
<li>(Proposed to avoid Russell's paradox)</li>
</ul></li>
<li>1908: Zermelo set theory
<ul>
<li>(Proposed to avoid Russell's paradox)</li>
<li>(First axiomatic set theory)</li>
<li>(Till this point it was all informally defined naïve set
theory)</li>
</ul></li>
<li>1910: Principia Mathematica - Whitehead and Russell
<ul>
<li>(Showed that 'formal logic could express a large part of
mathematics'¹)</li>
</ul></li>
<li>1920: Schönfinkel's work on combinatory logic</li>
<li>1921: Hilbert defines Hilbert's program</li>
<li>1928: Entscheidungsproblem posed (Hilbert, Ackermann)
<ul>
<li>(Given all axioms of math, is there an algorithm to check if a
proposition is universally valid?)</li>
<li>(Required a formal definition of an algorithm or computability)</li>
<li>('Entscheidungsproblem' is German for 'decision problem')</li>
<li><em>Grundzuge der theoretischen logik</em> - Hilbert, Ackermann
(1928)</li>
</ul></li>
<li>1929: Gödel's completeness theorem
<ul>
<li>(First order logic is complete. There is a first order formula for
all first order truth)</li>
<li>(Proof simplified by Henkin in 1949)</li>
<li>(Henkin's proof was in turn simplified by Hasenjaeger in 1953)</li>
</ul></li>
<li>1930: Curry's work on Combinatory logic
<ul>
<li>(Based on earlier work of Schönfinkel)</li>
</ul></li>
<li>1930: "Wir müssen wissen. Wir werden wissen" quote by Hilbert
<ul>
<li>We must know. We shall know</li>
<li>A later iteration of the same conference were du Bois-Reynold gave
his comment</li>
</ul></li>
<li>1931: Gödel's incompleteness theorems
<ul>
<li>(2 theorems)</li>
<li>(Showed limitations of formal systems)</li>
<li>(Showed that Hilbert's program was impossible)</li>
<li><em>Über formal unterscheidbare Sätze der Principia Mathematica und
verwandter Systeme I</em> - Gödel (1931)</li>
</ul></li>
<li>1932: Original lambda calculus (Church)
<ul>
<li>(Originally meant to encode logical formulas, but that didn't work
out due to inconsistency as shown by Church-Rosser paradox)</li>
<li><code>∃x, A[x]</code> could be written as <code>Σ(λx. A[x])</code>
(What did <code>Σ</code> mean ???)</li>
<li><em>A set of postulates for the foundation of logic</em> - Alonzo
Church (2 parts: 1932, 1933)</li>
<li>(The 1932 paper had this prophetic remark: 'There may, indeed, be
other applications of the system than as its use as a logic')</li>
</ul></li>
<li>1934: Natural deduction and sequent calculus (Gentzen)
<ul>
<li><em>Untersuchungen über das logische Schließen</em> - Gerhard
Gentzen (1935)
<ul>
<li>aka Investigations in Logical Deduction</li>
</ul></li>
<li>(Introduced ∀ for universal quantification to match ∃ of Peano)</li>
<li>(Unlike Hilbert system, natural deduction relies inference rules.
Axioms are 0-ary inference rules)</li>
<li>(System LJ: Intuitionistic logic as sequent calculus)</li>
<li>(System LK: Classical logic as sequent calculus)</li>
<li>(Cut-elimination theorem in sequent calculus: There is a 'cut-free'
proof for all 'cut' proofs )</li>
<li>(Both natural deduction and sequent calculus are equivalent)</li>
</ul></li>
<li>1935: Kleene-Rosser paradox
<ul>
<li>(Original LC is inconsistent)</li>
<li><em>The inconsistency of certain formal logics</em> - Kleene, Rosser
(1936)</li>
<li>(Church originally meant lambda calculus as a way to encode logic,
but this paradox played spoilsport)</li>
<li>(Yet, by this time it was obvious that lambda calculus was of
independent interest)</li>
<li>(Curry's combinatory logic and original lambda calculus are
inconsistent)</li>
<li>(Curry himself later simplified this as Curry's paradox)</li>
</ul></li>
<li>1936: Church encoding ??
<ul>
<li><em>An unsolvable problem in number theory</em> - Alonzo Church
(1936)</li>
</ul></li>
<li>1936: Church's result on the Entscheidungsproblem
<ul>
<li><em>A note on the Entscheidungsproblem</em> - Alonzo Church
(1936)</li>
</ul></li>
<li>1936: Turing machine (Turing)
<ul>
<li>(<em>On Computable Numbers With an Application to the
Entscheidungsproblem</em>)</li>
<li>An answer to the Entscheidungsproblem</li>
</ul></li>
<li>1936: General recursive functions (Gödel, Kleene)
<ul>
<li>(Gödel's lectures at Princeton were made in 1934, Kleene made notes
and published it in 1936)</li>
<li><em>General recursive functions of natural numbers</em> - Stephen
Cole Kleene (1936)</li>
</ul></li>
<li>1936: Church-Turing thesis
<ul>
<li>(Turing machine and lambda calculus are equivalent)</li>
<li>(Entscheidungsproblem proven impossible)</li>
<li>(Turing and Church found this independently)</li>
<li>(1937: <em>Computability and λ-definability</em> - Alan Turing)</li>
</ul></li>
<li>1936: Church-Rosser theorem
<ul>
<li>(Lambda calculus is confluent)</li>
<li>(Normal form of lambda calculus terms)</li>
</ul></li>
<li>1940: Simply typed lambda calculus
<ul>
<li>(Weaker than UTLC, but logically consistent)</li>
<li><em>A formulation of the simple theory of types</em> - Alonzo Church
(1940)</li>
</ul></li>
<li>1942: Curry's paradox</li>
<li>1945: von-Neumann architecture
<ul>
<li>First published description of stored program architecture</li>
<li><em>First draft of a report on the EDVAC</em></li>
</ul></li>
</ul>
<ul>
<li>1954: FORTRAN
<ul>
<li>Led by John Backus</li>
<li>"what FORTRAN did primarily was to mechanize the organization of
loops" - John Backus</li>
</ul></li>
<li>1958: ALGOL
<ul>
<li>Invovled Peter Naur, John Backus, John McCarthy</li>
<li>(Algol 60 report introduced Backus-Naur Form)</li>
<li>(Algol 68: Quite different. Considered too complex to
implement)</li>
<li>(Algol 60 was the most popular ALGOL)</li>
<li>(Algol 60 introduced the modern if-then-else syntax) <a
href="https://github.com/e-n-f/if-then-else/blob/master/if-then-else.md">ˡ</a></li>
</ul></li>
</ul>
<ul>
<li>1960s: Continuations
<ul>
<li>Earliest description in literature was by Adriaan van
Wijngaarden</li>
<li>A survey: <em>The discoveries of continuations</em> - John. C.
Reynolds (1993) <a
href="https://www.cs.ru.nl/~freek/courses/tt-2011/papers/cps/histcont.pdf">ˡ</a></li>
</ul></li>
<li>1960: Davis-Putnam algorithm
<ul>
<li>(Check SAT of a first oder formula via resolution)</li>
</ul></li>
<li>1960: Design of Lisp published
<ul>
<li><em>Recursive functions of symbolic expressions and their
computation by machine, Part I</em> - John McCarthy</li>
<li>(Steve Russell would soon write a form of lisp interpreter on an IBM
704)</li>
<li>(<code>car</code> and <code>cdr</code> are assembly macros for IBM
704)</li>
<li>Lisp was an implementation of lambda calculus</li>
<li>McCarthy developed the idea of conditional statement
(<code>if</code>) while working on lisp</li>
</ul></li>
</ul>
<ul>
<li>1962: Abstract syntax
<ul>
<li>Term coined by John McCarthy</li>
<li><em>Towards a mathematical science of computation</em> - John
McCarthy</li>
</ul></li>
<li>1962: DPLL algorithm
<ul>
<li>(Davis-Putnam-Logemann-Loveland algorithm)</li>
</ul></li>
<li>1962: Scott encoding</li>
</ul>
<ul>
<li>1964: SECD machine by Landin <a
href="https://www.brics.dk/RS/03/33/BRICS-RS-03-33.pdf">ᵈ</a>
<ul>
<li><em>Mechanical evaluation of expressions</em> - Peter J. Landin
(1964)</li>
<li>(This paper also introduced indentation sensitivity in programs
???)</li>
<li>Stands for internal registers of the machine: Stack, Environment,
Control, Dump</li>
<li>First abstract machine for lambda calculus</li>
<li>Landin also coined the name 'closure' of functions in this
paper.</li>
</ul></li>
<li>1965: <em>A correspondence between ALGOL 60 and Church's
lambda-notation: Part I</em> - Landin
<ul>
<li>Possibly the first instance where denotational semantics was given
to a programming language</li>
<li>SECD can be thought of as an operational semantics</li>
</ul></li>
<li>1966: <em>The next 700 programming languages</em> - Landin
<ul>
<li>It was foreseen that lot many more languages would be made</li>
<li>ISWIM: If you see what I mean (a language design)
<ul>
<li>Church without lambda</li>
<li>Never implemented</li>
<li>Had patmat, garbage collection, etc</li>
</ul></li>
<li>Primitives or domain specific languages</li>
</ul></li>
<li>1966: Böhm-Jacopini theorem
<ul>
<li><em>Flow diagrams, Turing machines and languages with only two
formation rules</em> - Corrado Böhm, Giuseppe Jacopini (1966)</li>
<li>Structured programming</li>
</ul></li>
<li>1967: <em>Assigning meanings to programs</em> - Robert W. Floyd <a
href="https://people.eecs.berkeley.edu/~necula/Papers/FloydMeaning.pdf">[ˡ</a>
<ul>
<li>Logical assertions to verify programs</li>
<li>Considered a pioneer paper on programming language semantics</li>
</ul></li>
<li>1968: Operational semantics
<ul>
<li>Used for defining semantics of ALGOL 68</li>
<li>The name was coined later</li>
</ul></li>
<li>1968: Automath
<ul>
<li><em>The mathematical language AUTOMATH, its usage, and some of its
extension</em> - N. G. de Bruijn (1968)</li>
<li>(First logical framework)</li>
</ul></li>
</ul>
<ul>
<li>1968: Dijkstra's article crticising use of <code>goto</code>
statement
<ul>
<li><em>Goto statement considered harmful</em> - Edsgar W. Dijkstra
(1968)</li>
</ul></li>
<li>1969: Hoare logic
<ul>
<li><em>An axiomatic basis for computer programming</em> - Charles
Antony Richard Hoare (1969)</li>
<li>Axiomatic semantics</li>
</ul></li>
<li>1969: Logic of Computable Functions (LCF) by Dana Scott
<ul>
<li>(This work was published only in 1993)</li>
</ul></li>
<li>1969: Curry-Howard isomorphism becomes clear
<ul>
<li><em>The formulae-as-types notion of construction</em> - William
Howard (1969)</li>
<li><em>Combinatory Logic, Volume I</em> - Haskell Curry, Robert Feys
(1958)</li>
<li><em>Functionality in Combinatory Logic</em> - Haskell Curry
(1934)</li>
</ul></li>
<li>1970: Pascal
<ul>
<li>(Influenced by ALGOL)</li>
</ul></li>
<li>1971: Denotational semantics
<ul>
<li><em>Toward a mathematical semantics for computer languages</em> -
Dana Scott, Christopher Strachey</li>
<li>aka Scott-Strachey semantics</li>
</ul></li>
<li>1971: Martin-Löf type theory
<ul>
<li>(Intuitionistic type theory by Per Martin-Löf)</li>
</ul></li>
<li>1972: <em>Structured programming</em>
<ul>
<li>Book by Dijkstra, Hoare and Dahl</li>
</ul></li>
<li>1972: C programming language</li>
<li>1972: Prolog programming language</li>
<li>1972: Stanford LCF
<ul>
<li>(Robin Milner's implementation for LCF)</li>
<li>(No support for custom proof commands)</li>
<li>(Hogged up memory)</li>
</ul></li>
<li>1972: Girard's paradox
<ul>
<li>(Type theory version of Russell's paradox)</li>
<li>(Martin-Löf's original type theory is shown to be inconsistent due
to Type in Type)</li>
</ul></li>
<li>1973: Mizar theorem prover</li>
<li>1976: Four colour theorem proven
<ul>
<li>(First computer-assisted major proof)</li>
<li>(By Kenneth Appel, Wolfgang Haken of University of Illinois)</li>
<li>(A discussion is at [3])</li>
<li>(Several mistakes were found later?? but were all addressed)</li>
<li><em>Every planar map is four-colorable</em> - Appel, Haken
(1989)</li>
</ul></li>
<li>1977: Safety and liveness properties
<ul>
<li><em>Proving the correctness of multiprocess programs</em> - Leslie
Lamport (1977)</li>
</ul></li>
<li>1977: Tail call optimization
<ul>
<li><em>Debunking the "expensive procedure call" myth or, procedure call
implementations considered harmful or, Lamdba: The ultimate goto</em> -
G. L. Steele
<ul>
<li>(Part of 'The Lambda papers')</li>
</ul></li>
</ul></li>
<li>1978: ML
<ul>
<li>(A general purpose, higher order programming language)</li>
<li>(Made for use in Edinburgh LCF)</li>
<li><em>A theory of type polymorphism in programming</em> - Robin
Milner</li>
<li>(Had a 'novel polymorphic type system')</li>
</ul></li>
<li>1979: Edinburg LCF
<ul>
<li>(By Milner and his associates at University of Edinburg)</li>
<li>(An LCF implementation embedded in ML)</li>
<li>('proof is always performed', but exists 'only ephemerally as part
of evaluation process' =&gt; less memory usage than Stanford LCF)</li>
</ul></li>
<li>1980s: Krivine machine (aka K-machine) <a
href="https://arxiv.org/abs/1202.2924v1">ᵈ</a>
<ul>
<li>Call-by-name abstract machine for lambda calculus</li>
<li>Was formally published only years after its invention</li>
<li><em>A call-by-name lambda-calculus machine</em> - J. L. Krivine
(2007)</li>
<li>By Jean-Louis Krivine</li>
<li>Operational semantics ??</li>
</ul></li>
<li>1984: Work started on an implementation of CoC
<ul>
<li>(This would later become Coq)</li>
<li>(Gérard Huet and Thierry Coquand are invovled)</li>
</ul></li>
<li>1985-1987: Therac-25 causes patient deaths by excess radiation <a
href="https://shemesh.larc.nasa.gov/fm/fm-why-new.html">ˡ</a>
<ul>
<li>(A computer-controlled radiation therapy machine)</li>
</ul></li>
<li>1985: C++ programming language</li>
<li>1986: Isabelle prover released</li>
<li>1987: Edinburg LF
<ul>
<li>(aka LF)</li>
<li>(Harper, Honesell, Plotkin)</li>
</ul></li>
<li>1988: <em>The calculus of constructions</em> - Coquand, Huet,
Gérard</li>
<li>1989: Type classes in Haskell
<ul>
<li><em>How to make ad-hoc polymorphism less ad-hoc</em> - Philip Wadler
and Stephen Blott</li>
</ul></li>
<li>1989: First version of modern Coq
<ul>
<li>(Version 4.10)</li>
<li>(With support for tactics??)</li>
<li>(To be renamed Rocq in 2025)</li>
</ul></li>
<li>1990: Haskell programming language</li>
<li>1991: Barengredt's lambda cube
<ul>
<li><em>Introduction to generalized type systems</em> - Hendrik P.
Barendregt (1991)</li>
</ul></li>
<li>1991: Python programming language</li>
<li>1993: Mars climate orbiter bug
<ul>
<li>(English units vs metric unit confusion in SM<sub>FORCES</sub>)</li>
</ul></li>
<li>1993: OCaml</li>
<li>1994: Pentium FDIV bug discovered</li>
<li>1995: Racket
<ul>
<li>(Initiated by a group led by Matthias Felleisen)</li>
</ul></li>
<li>1996: Ariane 5 test flight failure
<ul>
<li>Cause type conversion from 64-bit float to 16-bit int</li>
</ul></li>
<li>1999: Twelf
<ul>
<li><em>Twelf - A meta-logical framework for deductive systems</em> -
Frank Pfenning, Carsten Schürmann</li>
<li>(An implementation of LF)</li>
</ul></li>
<li>1999-2015: British Post Office scandal
<ul>
<li>Errors in Horizon software by Fujistsu led to false accusations of
theft</li>
</ul></li>
<li>2002: Separation logic
<ul>
<li><em>Local reasoning about programs that alter data structures</em> -
Peter O'Hearn, John Reynolds, Hongseok Yang (2001)</li>
<li><em>Separation logic: A logic for shared mutable data
structures</em> - John Reynolds (2002)</li>
</ul></li>
<li>2005: Felt-Thompson proof of Four colour theorem made in Coq
(Gonthier, et al)</li>
<li>2005: CompCert
<ul>
<li>(C compiler formally verified with Coq. Considered first such effort
for a 'realistic' compiler)</li>
</ul></li>
<li>2005: POPLMark challenge
<ul>
<li>(Ways to mechanise System F&lt;)</li>
</ul></li>
<li>2007: Agda2</li>
<li>2007: Concurrent separation logic (CSL)</li>
<li>2009: seL4: microkernel made with Isabelle/HOL</li>
<li>2012: Odd order theorem proven in Coq (Gonthier, et al)</li>
<li>2014: CakeML
<ul>
<li>(Compiler for a subset of sml, formally verified with HOL4)</li>
</ul></li>
<li>2015: Rust programming language</li>
<li>2015: iris
<ul>
<li>(A framework for concurrent seperation logic)</li>
</ul></li>
<li>2018: Problems in Boeing 737 MAX surface
<ul>
<li>(An automatic system named MCAS had problems??)</li>
<li>(Faulty sensor data triggered MCAS at inappropriate time)</li>
</ul></li>
<li>2023: PureCake
<ul>
<li>(Compiler for PureLang, a haskell-like language, formally verified
with HOL4.)</li>
<li>(An effort to have something like cakeml but with laziness??)</li>
</ul></li>
</ul>
<h2 id="refs">Refs</h2>
<ul>
<li><code>[1]</code>: Propositions as types - Philip Wadler</li>
<li><code>[2]</code>: The Automation of Proof: A Historical and
Sociological Exploration - Donald Mackenzie</li>
<li><code>[3]</code>: The Use of the Computer in the Proof of the Four
Color Theorem - Kenneth I. Appel</li>
<li><code>[4]</code>: History of interactive theorem proving - John
Harrison, Josef Urban and Freek Wiedijk</li>
<li><code>[5]</code>: History of Lisp - John McCarthy (1979)
<ul>
<li><a
href="http://jmc.stanford.edu/articles/lisp/lisp.pdf">http://jmc.stanford.edu/articles/lisp/lisp.pdf</a></li>
</ul></li>
</ul>
<h1 id="dbt">DBT</h1>
<ul>
<li>Original UTLC had a problem related to Russell's paradox. How? (src:
pat wadler)
<ul>
<li>Self application</li>
</ul></li>
<li>Example of a typed lambda calulus with provision for general
recursion
<ul>
<li>Can such a system be useful for proofs? Can't anything be
proven?</li>
</ul></li>
<li>Schmidt found an error in original computer generated proof of four
colour theorem ??</li>
</ul>
</div>
</body>
</html>
