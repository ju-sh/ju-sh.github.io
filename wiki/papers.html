<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Papers and articles</title>
  <style>
    body {
      max-width: 38rem;
      padding: 2rem;
      margin: auto;
      background-color: #FAF0E6;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
  </style>

</head>
<body>


<div id="header">
<a href="https://ju-sh.github.io">Home</a>
 | 
<a href="https://ju-sh.github.io/blog/index.html">Blog</a>
 | 
<a href="https://ju-sh.github.io/wiki/index.html">Wiki</a>
 | 
<a href="https://ju-sh.github.io/about.html">About</a>
</div>

<header id="title-block-header">
<h1 class="title">Papers and articles</h1>
</header>

<ul>
    </ul>




<hr/>

<div id="content-container">
<p>Publications that I came across one time or the other.</p>
<h1 id="section">2025</h1>
<ul>
<li>A history of Haskell: being lazy with class</li>
<li>WasmRef-Isabelle</li>
<li>SpecTec</li>
<li>You could've invented Fenwick trees</li>
</ul>
<p>To read:</p>
<ul>
<li>A list of successes that can change the world: Essays dedicated to
Philip Wadler on the occasion of his 60th birthday</li>
</ul>
<h1 id="section-1">2024</h1>
<h2 id="november">November</h2>
<ul>
<li>TODO: Automating Equational Proofs in Dirac Notation @ POPL'25
<ul>
<li><a
href="http://arxiv.org/pdf/2411.11617v1">http://arxiv.org/pdf/2411.11617v1</a></li>
</ul></li>
<li>TODO: Qurts: Automatic Quantum Uncomputation by Affine Types with
Lifetime</li>
<li>TODO: how to write 21st century proofs - Leslie Lamport
<ul>
<li><a
href="https://link.springer.com/content/pdf/10.1007/s11784-012-0071-6.pdf">https://link.springer.com/content/pdf/10.1007/s11784-012-0071-6.pdf</a></li>
</ul></li>
</ul>
<h2 id="august">August</h2>
<p>Lilac - Li, Ahmed, Holtzen (PLDI'23)</p>
<ul>
<li>Frame rule in separation logic</li>
<li>Probabilistic independence: 'two sources of randomness are
independent if knowledge of one does not give any knowledge of the
other'</li>
</ul>
<p>Look up:</p>
<ul>
<li>Measurability of random variables</li>
<li>Ambient sample space</li>
<li>Disintegration theory</li>
</ul>
<hr />
<p>Dlugosch, P., Brown, D., Glendenning, P., Leventhal, M. and Noyes,
H., <strong>2014</strong>. <em>An efficient and scalable semiconductor
architecture for parallel automata processing</em>. IEEE Transactions on
Parallel and Distributed Systems, 25(12), pp.3088-3098.</p>
<blockquote>
<p>this architecture exceeds the capabilities of high-performance
FPGA-based implementations of regular expression processors.</p>
</blockquote>
<ul>
<li>Uses a form of XML to program AP
<ul>
<li>Automata Network Markup Language (ANML)</li>
</ul></li>
</ul>
<p>Offtopic:</p>
<ul>
<li>Datasets: small NIDS, bioinformatics, and synthetic</li>
</ul>
<hr />
<p>Nourian, M., Wang, X., Yu, X., Feng, W.C. and Becchi, M.,
<strong>2017</strong>. <em>Demystifying automata processing: GPUs, FPGAs
or Micron's AP?</em>. In Proceedings of the International Conference on
Supercomputing (pp. 1-11).</p>
<blockquote>
<p>Micron's AP delivers throughputs, pattern densities, and
preprocessing times that are <strong>intermediate between those of FPGAs
and GPUs</strong>, and it is most suited for applications that use
datasets consisting of many small NFAs with a topology that is fixed and
known a priori.</p>
</blockquote>
<ul>
<li>Network processors
<ul>
<li>Configurable match tables</li>
</ul></li>
</ul>
<p>Associated masters thesis: <a
href="https://mospace.umsystem.edu/xmlui/bitstream/handle/10355/59977/research.pdf?sequence=2&amp;isAllowed=y">https://mospace.umsystem.edu/xmlui/bitstream/handle/10355/59977/research.pdf?sequence=2&amp;isAllowed=y</a></p>
<hr />
<p>Barrière, A. and Pit-Claudel, C., <strong>2024</strong>. <em>Linear
Matching of JavaScript Regular Expressions</em>. Proceedings of the ACM
on Programming Languages, 8(PLDI), pp.1336-1360.</p>
<h2 id="april">April</h2>
<p>Design Patterns for Parser Combinators (Functional Pearl) - Jamie
Willis, Nicolas Wu</p>
<hr />
<p>Cohen, C., Crance, E. and Mahboubi, A., <strong>2023</strong>.
<em>Trocq: Proof Transfer for Free, With or Without Univalence</em>.
arXiv preprint arXiv:2310.14022.</p>
<p>Presented at ESOP 2024.</p>
<p>Trocq implementation incorporate CoqEAL along with support for
univalent axioms if needed.</p>
<h2 id="february">February</h2>
<p>Gay, S.J., <strong>2020</strong>. <em>Cables, trains and types</em>.
From Lambda Calculus to Cybersecurity Through Program Analysis: Essays
Dedicated to Chris Hankin on the Occasion of His Retirement,
pp.3-16.</p>
<hr />
<p>Vericert <a
href="https://yannherklotz.com/papers/fvhls_oopsla21.pdf">https://yannherklotz.com/papers/fvhls_oopsla21.pdf</a>
<a
href="https://github.com/ymherklotz/vericert">https://github.com/ymherklotz/vericert</a></p>
<p>C -&gt; compcert -&gt; Verilog</p>
<hr />
<p>Call-by-push-value: Paul Blain Levy <a
href="https://dl.acm.org/doi/10.1145/3537668.3537670">https://dl.acm.org/doi/10.1145/3537668.3537670</a></p>
<ul>
<li><strong>A values is, a computation does</strong></li>
<li>Useful to represent effects??
<ul>
<li>Blend imperative and functional styles??</li>
</ul></li>
</ul>
<p>Dbts:</p>
<ul>
<li>weak normalization ✓
<ul>
<li><a
href="https://cs.stackexchange.com/questions/68080/what-is-the-difference-between-strong-normalization-and-weak-normalization-in-th">https://cs.stackexchange.com/questions/68080/what-is-the-difference-between-strong-normalization-and-weak-normalization-in-th</a></li>
</ul></li>
<li>'strong operational semantics'. What does strength of a semantics
mean?</li>
<li>confluence</li>
<li>equational theory: β, η, sequencing laws</li>
<li>Krivine machine: Call-by-name stack machine</li>
</ul>
<p>—</p>
<p>Coq implementation: <a
href="https://www.ps.uni-saarland.de/Publications/documents/ForsterEtAl_2018_Call-By-Push-Value.pdf">https://www.ps.uni-saarland.de/Publications/documents/ForsterEtAl_2018_Call-By-Push-Value.pdf</a></p>
<ul>
<li>makes use autosubst2</li>
</ul>
<p>—</p>
<p><a
href="https://qmro.qmul.ac.uk/xmlui/bitstream/handle/123456789/4742/RR-01-03.pdf?sequence=1">https://qmro.qmul.ac.uk/xmlui/bitstream/handle/123456789/4742/RR-01-03.pdf?sequence=1</a></p>
<ul>
<li>CBV and CBN. Why are these two needed anyway? What's missing from
each other?</li>
<li>Scott semantics: Just another name for denotational semantics
??</li>
<li>Different kinds of semantics:
<ul>
<li>Game semantics</li>
<li>Continuation semantics</li>
</ul></li>
</ul>
<hr />
<p>Harper, R., Honsell, F. and Plotkin, G., <strong>1993</strong>. <em>A
framework for defining logics</em>. Journal of the ACM (JACM), 40(1),
pp.143-184.</p>
<p>3 levels:</p>
<ul>
<li>objects
<ul>
<li>I guess like values. As in inhabitants of types</li>
</ul></li>
<li>types and type families
<ul>
<li>Type families are like function types?</li>
</ul></li>
<li>kinds</li>
</ul>
<p>Notations:</p>
<ul>
<li>K, L: Kinds</li>
<li>M, N, …: Objects</li>
<li>A, B, …: Types</li>
<li>x, y, z: variables</li>
<li>c, d: object constants</li>
<li>a, b: type constants</li>
</ul>
<p>DBT:</p>
<ul>
<li>What's the difference between Martin-Löf type theoreis and Edinburg
LF and CoC?
<ul>
<li>I thought CoC was a form of Martin Löf?</li>
</ul></li>
<li>Adequacy (as in adequacy theorems)</li>
<li>Canonical form</li>
</ul>
<h2 id="january">January</h2>
<p>Hasochism: The Pleasure and Pain of Dependently Typed Haskell
Programming - Sam Lindley, Conor McBride</p>
<p>—</p>
<blockquote>
<p>Haskell’s dependent ∀·quantifier is for implicit and exclusively
static things</p>
</blockquote>
<p>I guess, here the authors are talking about <code>forall a. a</code>
thing.</p>
<p>— Why was a separate <code>Natty</code> type needed for splitting a
vector into two vectors?</p>
<hr />
<ul>
<li>Dependent types: Type depends on a value (or another type, which can
also be said to be a value)</li>
<li>PL with deptypes =&gt; types are first order values
<ul>
<li>Types can be passed around as arguments to functions</li>
<li>Types can be returned by functions</li>
</ul></li>
<li>A dependent type =&gt; a family of types
<ul>
<li><code>T -&gt; Type</code></li>
</ul></li>
<li>Horn clause: Useful in SAT solving. A formula where at most one
literal is unnegated (ie, positive)
<ul>
<li>No unnegated literal =&gt; unit clause ??</li>
</ul></li>
</ul>
<p>Haskell</p>
<ul>
<li>type class offers a rudimentary part of deptypes?
<ul>
<li>When applied on types taking args</li>
</ul></li>
<li>all datatypes have ⟘, the undefined value, as a value:
<code>undefined</code>
<ul>
<li>ie, all types in haskell are inhabited</li>
<li><a
href="https://stackoverflow.com/questions/16748416/how-does-undefined-work-in-haskell">https://stackoverflow.com/questions/16748416/how-does-undefined-work-in-haskell</a></li>
</ul></li>
<li>Multiparameter type classes extension:
<code>MultiParamTypeClasses</code>
<ul>
<li><a
href="https://wiki.haskell.org/Multi-parameter_type_class">https://wiki.haskell.org/Multi-parameter_type_class</a></li>
<li>'If you think of a single-parameter type class as a set of types,
then a multi-parameter type class (MPTC) is a relation between types.'
Hmm..</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Collects</span> es e <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  insert ::</span> e <span class="ot">-&gt;</span> es <span class="ot">-&gt;</span> es</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  element ::</span> e <span class="ot">-&gt;</span> es <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Collects</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) a <span class="kw">where</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  insert e f <span class="ot">=</span> (\x <span class="ot">-&gt;</span> x<span class="op">==</span>e) <span class="op">||</span> (f x)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  element e f <span class="ot">=</span> f e</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Collects</span> [a] a <span class="kw">where</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  insert e l <span class="ot">=</span> e <span class="op">:</span> l</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  element e l <span class="ot">=</span> <span class="fu">elem</span> e l</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Hashable</span> e, <span class="dt">Collects</span> es e) <span class="ot">=&gt;</span> <span class="dt">Collects</span> (<span class="dt">HashTable</span> es) e <span class="kw">where</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  insert e es <span class="ot">=</span> </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  element e es <span class="ot">=</span> </span></code></pre></div>
<ul>
<li>Functional dependencies: <a
href="https://wiki.haskell.org/Functional_dependencies">https://wiki.haskell.org/Functional_dependencies</a>
<ul>
<li><code>class Mult a b c | a b -&gt; c where</code> tells compiler
that <code>c</code> is not a free type variable and is uniquely
determined by <code>a</code> and <code>b</code>.</li>
</ul></li>
</ul>
<p>—</p>
<p>Vector: Something like this would be nice..</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Vector</span> a n</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">Vector</span> a (n<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">{-</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">λ&gt; Cons 3 Nil</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">Cons 3 Nil :: Num a =&gt; Vector a n</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">But the `n&#39; value is useless in this form..</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">-}</span></span></code></pre></div>
<p>This one works:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Vector</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">Vector</span> <span class="dv">0</span> a</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> n a <span class="ot">-&gt;</span> <span class="dt">Vector</span> (<span class="dt">Suc</span> n) a</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- https://hackage.haskell.org/package/clash-prelude-1.8.1/docs/src/Clash.Sized.Vector.html#Vec</span></span></code></pre></div>
<h1 id="section-2">2023</h1>
<h2 id="november-1">November</h2>
<p>Kami</p>
<p>Conventions:</p>
<ul>
<li>c: constant</li>
<li>r: register / identifier</li>
</ul>
<p>Module consists of:</p>
<ul>
<li>[(r, c)]: registers with initial values</li>
<li>[(r, a)]: rules (with actions?)</li>
<li>[(f, λx:τ. a)]: methods (with actions?)</li>
</ul>
<hr />
<p>Krishnaswami, N.R. and Yallop, J., <strong>2019</strong>, June. <em>A
typed, algebraic approach to parsing</em>. In Proceedings of the 40th
ACM SIGPLAN Conference on Programming Language Design and Implementation
(pp. 379-393).</p>
<blockquote>
<p>the old observation that the <strong>context-free languages can be
understood as the extension of regular expressions with variables and a
least-fixed point operator</strong> (aka the <strong>μ-regular
expressions</strong></p>
</blockquote>
<ul>
<li>Multi-stage programming</li>
<li>MetaOCaml</li>
<li><code>'a t</code>: parsers reading a stream of tokens of the input
type and return a value of type <code>a</code></li>
<li>DBT: Functorial api vs functional api</li>
<li>DBT: Monoidal style
<ul>
<li>Monadic basically means function taking just one argument,
right?</li>
</ul></li>
<li>Example of monadic vs applicative style:
<ul>
<li>Monadic style: <code>'a t -&gt; 'b t -&gt; ('a * 'b) t</code></li>
<li>Applicative style:
<code>('a -&gt; 'b) t -&gt; 'a t -&gt; 'b t</code></li>
</ul></li>
<li>Parsers: Functions from streams to values
<ul>
<li>stream: strings of input symbols</li>
<li>value: parsed ast</li>
</ul></li>
<li>Deterministic regular languages: Languages where NFA-DFA translation
can be done without exponential blow-up in state count
<ul>
<li>Brüggemann-Klein and Wood 1992</li>
</ul></li>
</ul>
<h2 id="october">October</h2>
<p>Cohen, C., Dénès, M. and Mörtberg, A., <strong>2013</strong>,
December. <em>Refinements for free!</em>. In International Conference on
Certified Programs and Proofs (pp. 147-162). Cham: Springer
International Publishing.</p>
<p>Types of refinement:</p>
<ul>
<li>Data refinement: Changing representation</li>
<li>Program refinement: As in changing efficiency of algorithm</li>
</ul>
<p>Steps for data refinement:</p>
<ol>
<li><em>Relate</em>: Make a relation between proof-friendly data
representation with the computation-friendly representation</li>
<li><em>Parametrize</em>: Make an abstract data type parametrized by
data representation.
<ul>
<li>With abstract types and basic operations</li>
</ul></li>
<li><em>Instantiate</em> the abstract type with proof-friendly
representation and prove its correctness</li>
<li>Use parametricity of the abstract type to show that the
computation-friendly repr is also correct</li>
</ol>
<p>–</p>
<p>Refinement relations:</p>
<ul>
<li><em>Implementation function</em>: Proof-oriented to
computation-oriented</li>
<li><em>Specification function</em>: Computation-oriented to
proof-oriented</li>
</ul>
<p>Examples:</p>
<ul>
<li>nat and N (isomorphic)
<ul>
<li><a
href="https://github.com/coq-community/coqeal/blob/master/refinements/binnat.v">https://github.com/coq-community/coqeal/blob/master/refinements/binnat.v</a></li>
</ul></li>
<li>nat and Z (partial)</li>
</ul>
<p>—</p>
<p>Need for parametricity:</p>
<blockquote>
<p>Proving correctness directly on computation-oriented types is
precisely what we are trying to avoid</p>
</blockquote>
<ul>
<li>R ==&gt; R': if both R and R' sends related inputs to related
output</li>
</ul>
<pre><code>R: A -&gt; B
R&#39;: A&#39; -&gt; B&#39;
R ==&gt; R&#39;: (A -&gt; A&#39;) -&gt; (B -&gt; B&#39;)
</code></pre>
<p>—</p>
<p>Dbts:</p>
<ul>
<li><del>Isomorphic types: 'simple case where implementation and
specification functions are inverses of each other'. But wouldn't they
always be inverses? What am I missing here?</del>
<ul>
<li>They needn't be inverses. Example: partial functions.</li>
</ul></li>
</ul>
<hr />
<p>Bourgeat, T., Clester, I., Erbsen, A., Gruetter, S., Singh, P.,
Wright, A. and Chlipala, A., <strong>2023</strong>. <em>Flexible
Instruction-Set Semantics via Abstract Monads (Experience Report)</em>.
Proceedings of the ACM on Programming Languages, 7(ICFP),
pp.108-124.</p>
<ul>
<li>Spec written in Haskell subset (Clash compatible, I guess)</li>
<li>hs-to-coq: Spec to coq to reason about</li>
</ul>
<hr />
<p>Macedo, H.D. and Oliveira, J.N., <strong>2013</strong>. <em>Typing
linear algebra: A biproduct-oriented approach</em>. Science of Computer
Programming, 78(11), pp.2160-2191.</p>
<hr />
<p>Dénès, M., Mörtberg, A. and Siles, V., <strong>2012</strong>, August.
<em>A refinement-based approach to computational algebra in Coq</em>. In
International Conference on Interactive Theorem Proving (pp. 83-98).
Berlin, Heidelberg: Springer Berlin Heidelberg.</p>
<ul>
<li>A coq library made using this concept: <a
href="https://github.com/coq-community/coqeal/">https://github.com/coq-community/coqeal/</a></li>
</ul>
<blockquote>
<p>having the size of matrices encoded in their type allows to state
concise lemmas without explicit side conditions, but it is <strong>not
always flexible enough when getting closer to machine-level
implementation details</strong>.</p>
</blockquote>
<blockquote>
<p>It is worth noting that we could have stated all our morphism lemmas
with the converse operator (from concrete matrices to abstract ones).
But these lemmas would then have been quantified over lists of lists,
with poorer types, which would have required a well-formedness predicate
as well as premises expressing size constraints. The way we have chosen
takes full advantage of the information carried by richer types.</p>
</blockquote>
<ul>
<li>matrix example shown directly in the paper in terms of
winograd/strassen is algorithmic refinement
<ul>
<li>winograd algorithm, which is an improvement of naïve matrix
multiplication, is shown to be equivalent to <code>*m</code> of
mathcomp.</li>
<li><code>mat: Prop</code></li>
<li><code>mat2seqmx: mat -&gt; seqmx</code> (where <code>seqmx</code>
uses <code>Type</code>)</li>
<li><code>reflect (M=N) (mat2seqmx M = mat2seqmx N)</code></li>
</ul></li>
</ul>
<p>More reading:</p>
<ul>
<li>Pragmatic quotient types in type theory - Cyril Cohen</li>
</ul>
<p>–</p>
<pre><code>T: Type
M N: matrix A rows cols
meq: seq (seq T) -&gt; seq (seq T) -&gt; bool
───────────────────────

let Mc := seqmx_of_fun M in
let Nc := seqmx_of_fun N in
reflect (M=N) (meq Mc Nc)


</code></pre>
<h2 id="september">September</h2>
<p>Agnishom Chattopadhyay (Rice uni) MTL paper</p>
<ul>
<li>Explore:
<ul>
<li>queue implementation using 2 stacks</li>
<li>Lattice formalization in coq</li>
</ul></li>
<li>New stuff:
<ul>
<li>Dyanmic logic</li>
</ul></li>
</ul>
<hr />
<p>Kanabar, H., Vivien, S., Abrahamsson, O., Myreen, M.O., Norrish, M.,
Pohjola, J.Å. and Zanetti, R., <strong>2023</strong>. <em>PureCake: A
Verified Compiler for a Lazy Functional Language</em>. Proceedings of
the ACM on Programming Languages, 7(PLDI), pp.952-976.</p>
<p>HOL4 verified compiler from a haskell-like language to cakeml.</p>
<hr />
<p>Landi, W., <strong>1992</strong>. <em>Undecidability of static
analysis</em>. ACM Letters on Programming Languages and Systems
(LOPLAS), 1(4), pp.323-337.</p>
<hr />
<ul>
<li>Verse coq-edsl ppk, Abhishek Dang 2018 PPDP</li>
</ul>
<p>Code:</p>
<ul>
<li><a
href="https://github.com/raaz-crypto/verse-coq">https://github.com/raaz-crypto/verse-coq</a></li>
<li><a
href="https://github.com/raaz-crypto/verse-agda">https://github.com/raaz-crypto/verse-agda</a>
(old abandoned version in agda)</li>
</ul>
<h2 id="august-1">August</h2>
<p>A tutorial on the universality and expressiveness of fold - Graham
Hutton (1999)</p>
<blockquote>
<p>recursion and induction are the primary tools for defining and
proving properties of program</p>
</blockquote>
<p>New(ish) stuff:</p>
<ul>
<li>primitive recursion</li>
<li>fold operation is also known as 'banana operation' because it was
once denoted with ''
<ul>
<li><em>Functional Programming with Bananas, Lenses, Envelopes and
Barbed Wire</em> - Erik Meijer, Maarten Fokking, Ross Paterson
<ul>
<li><a
href="https://maartenfokkinga.github.io/utwente/mmf91m.pdf">https://maartenfokkinga.github.io/utwente/mmf91m.pdf</a></li>
<li>May be related: <a
href="http://web.archive.org/web/20150302113739/http://jozefg.bitbucket.org/posts/2014-11-19-recursion.html">http://web.archive.org/web/20150302113739/http://jozefg.bitbucket.org/posts/2014-11-19-recursion.html</a></li>
</ul></li>
</ul></li>
<li>Ackermann function</li>
</ul>
<p>To read:</p>
<ul>
<li>Meertens, L. (1983) Algorithmics: Towards programming as a
mathematical activity: <a
href="https://ir.cwi.nl/pub/2686/2686D.pdf">https://ir.cwi.nl/pub/2686/2686D.pdf</a></li>
<li>Meertens, L. (1992) Paramorphisms. Formal Aspects of Computing</li>
</ul>
<hr />
<p>difflist paper Hughes</p>
<ul>
<li>abstraction means losing some of the details in the concrete
represenation, right? In that sense, we can't recover concrete
representation from the abstract version. I guess, it's not used in that
sense in this paper.</li>
<li>'KRC convention that all functions are curried': KRC as in K&amp;R C
?? NO!!
<ul>
<li>KRC seems to be 'Kent Recursive Calculator', whose syntax bears some
resemblence to that of haskell (because Haskell was influenced by
it).</li>
<li><a
href="https://www.pls-lab.org/en/Kent_Recursive_Calculator">https://www.pls-lab.org/en/Kent_Recursive_Calculator</a></li>
</ul></li>
</ul>
<pre><code>abstr: CONCR -&gt; ABSTR
concr: ABSTR -&gt; CONCR

∀a:ABSTR,
  abstr (concr a) = a
</code></pre>
<hr />
<p>Dijkstra about teaching:</p>
<p>General:</p>
<ul>
<li>Non-Euclidean geometry</li>
</ul>
<hr />
<p>Dijkstra, E.W. <strong>1979</strong>. <em>On the foolishness of
'natural language programming'</em>. In: Bauer, F.L., et al. Program
Construction. Lecture Notes in Computer Science, vol 69. Springer,
Berlin, Heidelberg. <a
href="https://doi.org/10.1007/BFb0014656">https://doi.org/10.1007/BFb0014656</a></p>
<p>(Only 3 pages)</p>
<p>Probably still true:</p>
<blockquote>
<p>some people found error messages they couldn't ignore more annoying
than wrong results, and, when judging the relative merits of programming
languages, some still seem to equate "the ease of programming" with the
ease of making undetected mistakes.</p>
</blockquote>
<p>—</p>
<p>About good notations:</p>
<blockquote>
<p>Greek mathematics got stuck because it remained a verbal, pictorial
activity, Moslem "algebra", after a timid attempt at symbolism, died
when it returned to the rhetoric style, and the modern civilized world
could only emerge - for better o2 for worse– when Western Europe could
free itself from the fetters of medieval scholasticism</p>
</blockquote>
<p>—</p>
<p>About advantage of formal langauges:</p>
<blockquote>
<p>The virtue of formal texts is that their manipulations, in order to
be legitimate, need to satisfy only a few simple rules; they are, when
you come to think of it, an amazingly effective tool for ruling out all
sorts of nonsense that, when we use our native tongues, are almost
impossible to avoid.</p>
</blockquote>
<p>—</p>
<p>Funny, yet meaningful.</p>
<blockquote>
<p>From one gut fesling I derive much consolation: I suspect that
machines to be programmed in our native tongues –be it Dutch, English,
American, French, German, or Swahili– are as damned difficult to make as
they would be to use.</p>
</blockquote>
<hr />
<p>Dijkstra 'Humble progammer'</p>
<p>General:</p>
<ul>
<li>duty cycle = (time circuit was ON) / (time circuit was OFF)</li>
<li>ALGOL 60: Backus-Naur Form (BNF) for grammars used</li>
</ul>
<p>—</p>
<blockquote>
<p>silence their doubts by observing how many of these machines have
been sold, and derive from that observation the false sense of security
that, after all, then cannot have been that bad. But upon closer
inspection, that line of defense has the same convincing strength as the
argument that cigarette smoking must be healthy because so many people
do it.</p>
</blockquote>
<p>—</p>
<p>About compatibility with old code constraining new ideas, here with
respect to FORTRAN:</p>
<blockquote>
<p>FORTRAN'S tragic fate has been its wide acceptance, mentally chaining
thousands and thousands of programmers to our past mistakes. I pray
daily that more of my fellow programmers may find the means of freeing
themselves from the curse of compatibility.</p>
</blockquote>
<p>—</p>
<p>About learning from problems of FORTRAN and PL/I:</p>
<blockquote>
<p>there is no point in making mistakes unless thereafter we are able to
learn from them.</p>
</blockquote>
<p>—</p>
<blockquote>
<p>*Those who want really reliable software will discover that they must
find means of avoiding the majority of bugs to start with*<br />
…<br />
<strong>If you want more effective programmers, you will discover that
they should not waste their time debugging - they should not introduce
the bugs to start with.</strong></p>
</blockquote>
<p>—</p>
<blockquote>
<p>Today a usual technique is to make a program and then to test it.</p>
<p>But: <strong>program testing can be a very effective way to show the
presence of bugs, but it is hopelessly inadequate for showing their
absence.</strong> The only effective way to raise the confidence level
of a program significantly is to give a convincing <strong>proof of its
correctness</strong>. But one should not first make the program and then
prove its correctness, because then the requirement of providing the
proof would only increase the poor programmer's burden. On the contrary:
<strong>the programmer should let correctness proof and program grow
hand in hand.</strong></p>
</blockquote>
<hr />
<p>Datatype à la carte - 2008</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> f <span class="ot">=</span> <span class="dt">In</span> <span class="op">$</span> f (<span class="dt">Expr</span> f)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Val</span> e <span class="ot">=</span> <span class="dt">Val</span> <span class="dt">Int</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">IntExpr</span> <span class="ot">=</span> <span class="dt">Expr</span> <span class="dt">Val</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> f <span class="ot">=</span> <span class="dt">In</span> (f (<span class="dt">Expr</span> f))</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Val</span> e <span class="ot">=</span> <span class="dt">ValC</span> <span class="dt">Int</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">IntExpr</span> <span class="ot">=</span> <span class="dt">Expr</span> <span class="dt">ValC</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="dt">In</span> (<span class="dt">ValC</span> _)</span></code></pre></div>
<hr />
<p>On-the-fly Verification of Linear Temporal Logic 1999 LaBRI
Bordeaux</p>
<hr />
<p>Peled, D. and Havelund, K., <strong>2019</strong>. <em>Refining the
safety–liveness classification of temporal properties according to
monitorability</em>. Models, Mindsets, Meta: The What, the How, and the
Why Not? Essays Dedicated to Bernhard Steffen on the Occasion of His
60th Birthday, pp.218-234.</p>
<ul>
<li>□◇p is not monitorable</li>
<li>Safety checking: PSPACE</li>
<li>Liveness checking: EXPSPACE-complete</li>
</ul>
<table>
<thead>
<tr class="header">
<th>Lamport's ??</th>
<th>New dual</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Safety</td>
<td>guarantee</td>
</tr>
<tr class="even">
<td>Liveness</td>
<td>Morbidity</td>
</tr>
</tbody>
</table>
<p>Ref papers to be read:</p>
<ul class="task-list">
<li><input type="checkbox" disabled="" />The temporal logic of reactive
and concurrent systems - Pneuli, Manna 1992<ul>
<li>May be the paper that introduced LTL ??</li>
</ul></li>
<li><input type="checkbox" disabled="" />Springer, 61-102, 2018. 14. K.
Havelund, G. Rosu, Synthesizing monitors for safety properties,
TACAS’02, LNCS Volume 2280, Springer, 342-356, 2002.<ul>
<li>Why just safety properties? Is there some problem with considering
all properties together?</li>
</ul></li>
<li><input type="checkbox" disabled="" />RV’09, LNCS Volume 5779,
Springer, 40-59, 2009. 10. Y. Falcone, J.-C. Fernandez, L. Mounier, What
can you verify and enforce at runtime? STTT 14(3), 349-382, 2012.</li>
</ul>
<hr />
<p>Pike, L., Wegmann, N., Niller, S. and Goodloe, A.,
<strong>2013</strong>. <em>Copilot: monitoring embedded systems</em>.
Innovations in Systems and Software Engineering, 9, pp.235-255.</p>
<p>Original copilot paper:</p>
<ul>
<li><p>Copilot3 is much different feature-wise</p></li>
<li><p>Showed testing is insufficient: Butler RW, Finelli GB (1993) The
infeasibility of quantifying the reliability of life-critical real-time
software. IEEE Trans Softw Eng 19:3–12</p></li>
<li><p>Byzantine fault:</p>
<ul>
<li>Different nodes in the system interpret the same broadcast message
differently.</li>
</ul></li>
</ul>
<hr />
<p>RV paper from ICFP'23</p>
<blockquote>
<p>systematic and rigorous evidence that can be audited.</p>
</blockquote>
<ul>
<li>An RTCA document (kind of like a guideline or standard): Software
Considerations in Airborne Systems and Equipment Certification</li>
</ul>
<hr />
<p>Perez, I., Dedden, F. and Goodloe, A., 2020. Copilot 3 (No.
NF1676L-35996).</p>
<p>This is not the paper that introduced the tool. This seems to be an
improvement over earlier versions.</p>
<p><a
href="https://github.com/Copilot-Language/copilot">https://github.com/Copilot-Language/copilot</a></p>
<p>—</p>
<ul>
<li>A 'comprehensive survey of RV' (2010): Goodloe and Pike, 2010.
Goodloe, A. and Pike, L. (2010). Monitoring distributed real-time
systems: A survey and future directions.</li>
</ul>
<p>Motivation for this paper:</p>
<blockquote>
<p>monitors for hard real-time avionics should not afefct the system
under observation in a way that changes the functionality of the system,
requires re-certification, interferes with timing, or exhausts size,
weight, and power (SWAP) reserves.</p>
</blockquote>
<p>—</p>
<blockquote>
<p>Runtime verification (RV) [Havelund and Goldberg, 2008, Goodloe and
Pike, 2010, Bartocci et al., 2018] is a verification technique that has
the potential to enable the <strong>safe operation of safety-critical
systems that are too complex to formally verify or fully test</strong>.
In RV, the system is monitored <strong>during execution</strong>, to
<strong>detect and respond</strong> to property violations that take
place during the actual mission. RV detects when properties are violated
in runtime, <strong>so it is not a proof of correctness, but a
significant improvement over testing alone</strong>.</p>
</blockquote>
<p>—</p>
<blockquote>
<p>The language also relies on dependent types, to enable safe use of
non-primitive data structures, like structs and arrays.</p>
</blockquote>
<p>—</p>
<blockquote>
<p>Temporal logic languages generally vary in the logic they are based
on, the temporal operators they support and in their model of time
(e.g., continuous vs discrete, linear vs branching, future and/or past,
etc.). These aspects impact what formulas can be expressed, which ones
are true or false, what information is needed to evaluate them, and how
efficiently we can do so.</p>
</blockquote>
<blockquote>
<p>In Copilot, we opt for implementing Bounded LTL, a variant of LTL in
which the amount of time into the future that is observable is bounded
in each application of a temporal operator.</p>
</blockquote>
<p>—</p>
<p>:DBT: Examples of properties that are not expressible in LTL: a
property that is true at every alternate time step.</p>
<blockquote>
<p>some properties are known not to be expressible in LTL, such as, for
example, a formula that is true at every other sample, but they can be
expressed in Copilot due to the existence of delays and recursion.</p>
</blockquote>
<p>In LTL, the next operator (ie, <code>X</code>) is essentially a
delay, right?</p>
<p>—</p>
<p>Isn't MTL ⊆ LTL though? Ranges can be made in LTL as well although
the formula would be far from concise.</p>
<ul>
<li>MAVLink: A protocol used for communicating with an unmanned vehicle
(like drones as well, I guess) from a ground station.</li>
<li>Core Flight System (cFS) at nasa</li>
</ul>
<hr />
<p>Braibant, T. and Pous, D., <strong>2010</strong>, July. <em>An
efficient Coq tactic for deciding Kleene algebras</em>. In International
Conference on Interactive Theorem Proving (pp. 163-178). Berlin,
Heidelberg: Springer Berlin Heidelberg.</p>
<blockquote>
<p>matrices over a Kleene algebra form a Kleene algebra</p>
</blockquote>
<hr />
<p>Coquand, T. and Siles, V., <strong>2011</strong>, December. <em>A
decision procedure for regular expression equivalence in type
theory</em>. In International Conference on Certified Programs and
Proofs (pp. 119-134). Berlin, Heidelberg: Springer Berlin
Heidelberg.</p>
<ul>
<li>Paper: <a
href="https://www.researchgate.net/profile/Thierry-Coquand/publication/220818744_A_Decision_Procedure_for_Regular_Expression_Equivalence_in_Type_Theory/links/56b08e4608ae9ea7c3b05585/A-Decision-Procedure-for-Regular-Expression-Equivalence-in-Type-Theory.pdf">https://www.researchgate.net/profile/Thierry-Coquand/publication/220818744_A_Decision_Procedure_for_Regular_Expression_Equivalence_in_Type_Theory/links/56b08e4608ae9ea7c3b05585/A-Decision-Procedure-for-Regular-Expression-Equivalence-in-Type-Theory.pdf</a></li>
</ul>
<hr />
<p>Firsov, D. and Uustalu, T., <strong>2013</strong>, December.
<em>Certified parsing of regular languages</em>. In International
Conference on Certified Programs and Proofs (pp. 98-113). Cham: Springer
International Publishing.</p>
<ul>
<li>Code: <a
href="https://cs.ioc.ee/~denis/cert-reg">https://cs.ioc.ee/~denis/cert-reg</a></li>
</ul>
<blockquote>
<p>Note that instead of the Kleene star (<sub>*</sub>) we use plus (_+).
This is more convenient for us and does not restrict generality, as star
is expressible as choice between the empty string and plus. Now, we need
to specify when a string (an element of type List Σ) is</p>
</blockquote>
<p>Notations used:</p>
<ul>
<li><code>w ▶ spec</code>: like <code>w ⊨ spec</code></li>
<li><code>'c</code>: like <code>Char c</code></li>
</ul>
<p><code>Star</code> is defined in terms of <code>ε</code> and
<code>Char</code>.</p>
<p>Matrix defined in terms of a commutative semiring.</p>
<p>Misc thoughts</p>
<ul>
<li>From clash docs: Moore machine is strictly less expressive than
Melay machine.
<ul>
<li><a
href="https://hackage.haskell.org/package/clash-prelude-1.6.5/docs/Clash-Prelude-Moore.html">https://hackage.haskell.org/package/clash-prelude-1.6.5/docs/Clash-Prelude-Moore.html</a></li>
</ul></li>
<li>From Wikipedia: Not every Mealy can be converted to Moore</li>
<li>We can convert from Moore to Mealy though, right? How was it done,
again?
<ul>
<li>I probably learnt it in UG but have forgotten.</li>
</ul></li>
</ul>
<p>Project thoughts:</p>
<ul>
<li>They don't have hlist here… So, does that mean we don't have to have
it to have the same transition matrix result?** July</li>
</ul>
<p>lang deriv - Conal Elliott (ICFP 2021)</p>
<ul>
<li><a
href="https://github.com/conal/paper-2021-language-derivatives/">https://github.com/conal/paper-2021-language-derivatives/</a></li>
</ul>
<p>𝒟: says what can come after 'u'</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Derivative</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>𝒟<span class="op">:</span> ([<span class="dt">A</span>] <span class="ot">-&gt;</span> <span class="dt">B</span>) <span class="ot">-&gt;</span> [<span class="dt">A</span>] <span class="ot">-&gt;</span> ([<span class="dt">A</span>] <span class="ot">-&gt;</span> <span class="dt">B</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>𝒟 f u <span class="ot">=</span> λv <span class="ot">=&gt;</span> f (u<span class="op">++</span>v)</span></code></pre></div>
<p>I guess we can think of <code>[A] -&gt; B</code> being a language.
Language involving only the <code>[A]</code> given, I suppose?</p>
<blockquote>
<p>For languages, 𝒟 P u is the set of u-suffixes from P, i.e., the
strings v such that u ++ v ∈ P.</p>
</blockquote>
<p>:DBT: Shouldn't it be 'u-prefixes from P'?</p>
<hr />
<p>Plotkin, G.D. and Pretnar, M., <strong>2013</strong>. <em>Handling
algebraic effects</em>. Logical methods in computer science, 9.</p>
<hr />
<p>Combinator parsing: A short tutorial - S. Doaitse Swierstra</p>
<ul>
<li>Sequential composition</li>
<li>Alternative composition</li>
</ul>
<p>Relevant for a good library:</p>
<ul>
<li>Composibility</li>
<li>Extendability</li>
</ul>
<hr />
<h2 id="june">June</h2>
<p>TU Delft agda2hs MSc thesis</p>
<p>Ref:</p>
<ul>
<li>Abstract interpretation POPL-1977</li>
<li>Harrison, Urban, Wiedijk - History of ITP</li>
</ul>
<hr />
<p>Coq: Best macro assembler</p>
<ul>
<li>bitvectors were represented as bool-tuples
<ul>
<li>They then leveraged ssreflect and mathcomp lemmas.</li>
</ul></li>
</ul>
<p>Dbt:</p>
<ul>
<li>x86 calling conventions</li>
<li>left-inverse of something</li>
<li>Applications of Kleene algebras</li>
<li>What notations are <code>#42</code> and <code>#c</code>?</li>
</ul>
<p>Possibly related code repos and links:</p>
<ul>
<li><a
href="https://github.com/maximedenes/coq-amd64">https://github.com/maximedenes/coq-amd64</a></li>
<li><a
href="https://github.com/nbenton/x86proved">https://github.com/nbenton/x86proved</a></li>
<li><a
href="https://sympa.inria.fr/sympa/arc/coq-club/2023-08/msg00014.html">https://sympa.inria.fr/sympa/arc/coq-club/2023-08/msg00014.html</a></li>
</ul>
<hr />
<p>Tag-Free Garbage Collection for Strongly Typed Programming Languages
- Benjamin Goldbe</p>
<blockquote>
<p>Traditionally, garbage collection (and dynamic type checking)
required each datum to be tagged with type information (see [Ungar86]
for description of various tagging schemes). During garbage collection,
the tag of each datum is examined in order to determine how the datum
should be handled. Naturally, whether the datum is a number, pointer,
structure, or closure will determine how the object is treated by the
collector.</p>
</blockquote>
<ul>
<li>sml has automatic garbage collection, C++ doesn't.</li>
<li>Automatic garbage collection: 'an internal process that releases
heap memory and other resources as a program runs'
<ul>
<li>Source: <a
href="https://learn.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-170">https://learn.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-170</a></li>
</ul></li>
<li>Maintaining tags inflict 'space and time overhead'. So tag-free
garbage collection is desirable.</li>
</ul>
<p>Dbt:</p>
<ul class="task-list">
<li><input type="checkbox" disabled="" />'For strongly typed languages,
no run-time tags are required for type checking, since type checking
occurs at compile-time. However, current implementations of ML, such as
[AMW], retain tags to support garbage collection'. But sml is a strongly
typed language, right?</li>
<li><input type="checkbox" disabled="" />Seperation logic</li>
</ul>
<hr />
<p>Chlipala, A., <strong>2007</strong>. <em>A certified type-preserving
compiler from lambda calculus to assembly language</em>. ACM Sigplan
Notices, 42(6), pp.54-65.</p>
<ul>
<li>TIL: an SML compiler</li>
<li>Type directed optimizations</li>
</ul>
<p>Dbts:</p>
<ul class="task-list">
<li><input type="checkbox" disabled="" checked="" />tags in garbage
collection in compilers<ul>
<li>As in 'tag-free garbage collection'</li>
</ul></li>
<li><input type="checkbox" disabled="" />Relational reasoning</li>
</ul>
<hr />
<p>Aydemir, B.E., Bohannon, A., Fairbairn, M., Foster, J.N., Pierce,
B.C., Sewell, P., Vytiniotis, D., Washburn, G., Weirich, S. and
Zdancewic, S., <strong>2005</strong>. <em>Mechanized metatheory for the
masses: the PoplMark challenge</em>. In Theorem Proving in Higher Order
Logics: 18th International Conference, TPHOLs 2005, Oxford, UK, August
22-25, 2005. Proceedings 18 (pp. 50-65). Springer Berlin Heidelberg.</p>
<p>POPLMark challenge</p>
<ul>
<li>Variable binding is always a challenge.</li>
</ul>
<hr />
<p>Dreyer, D. and Pierce, B.C., <strong>2022</strong>. <em>On being a
PhD student of Robert Harper</em>. Journal of Functional Programming,
32, p.e3.</p>
<blockquote>
<p>The trick was doing this in a principled way</p>
</blockquote>
<blockquote>
<p>Towards the end of my graduate career, I had figured something out
and was excited to show Bob. I went up to his office but couldn’t find
him. In fact, he disappeared for a whole week. (I later found out he was
trying to solve all of the puzzles in the "Myst" CD-ROM game that was
all the rage back then.) When I finally tracked him down, I started
writing on the white board and got about half-way through explaining
whatever it was that so excited me. Bob kept interrupting me with
questions. I got so frustrated that I finally just threw the white board
marker at him and yelled at him to “Shut up!” At that point, he leaned
back in his chair, smiled, and said, "Now you’re ready to graduate."</p>
</blockquote>
<blockquote>
<p>one day in grad school I revealed to Bob that I didn’t know anything
about logical relations. In typical Bob fashion, he was very surprised
and gave me a hard time for not having already educated myself about
this fundamental thing that he thought every student should know. To
rectify this lapse in my education, he spent the afternoon giving me a
private lesson in his office about logical relations, starting with
Tait’s method for proving strong normalization of the simply-typed
λ-calculus, and then Girard’s method for proving the same of System F.
If I recall correctly, he described these as "book proofs", a reference
to Paul Erdös's idea of proofs so beautiful that they belonged in God’s
book of perfect mathematical proofs</p>
</blockquote>
<blockquote>
<p>Bob has embraced the motto, "Dare to be irrelevant." I think that,
while catchy and provocative, this slogan is but one instance of a
broader lesson that I took away from Bob’s research and mentorship,
namely: "Dare to think for yourself. Question the conventional wisdom.
If everyone else is going one direction, go the other way. It’s OK to be
weird."</p>
</blockquote>
<blockquote>
<p>Far more valuable though, I think, was a rigorous education in the
<strong>value of a kind of clarity of thought, and co-equally of
communication</strong>. Bob was never satisfied with something that just
worked. It had to <em>obviously</em> work, and it had to explain by its
very expression <em>how</em> it worked. The occasional marathon sessions
in Bob's office working through a problem were as <strong>much about
arriving at an explanation for a solution as at the solution
itself</strong>. This appreciation for <strong>thinking and
communicating clearly</strong> was almost certainly by far the most
valuable thing I took away from my time with Bob</p>
</blockquote>
<blockquote>
<p>It took me several months to rewrite the introduction because I had
to first familiarize myself with a century of mathematics. Only then
could I truly understand where my dissertation stood in the universe of
all knowledge. I feel privileged. His high standards elevated me</p>
</blockquote>
<blockquote>
<p>Bob’s advice was that it takes 10 years to gain expertise in a new
field, and that I should be ready for that. I think it depends. If
you’re lucky enough to have an advisor like Bob, that time frame can be
drastically reduced.</p>
</blockquote>
<blockquote>
<p>not just a boring version of programming where rules prevented you
from having fun and being creative. This was a better version of
programming that I didn’t know about yet.</p>
</blockquote>
<blockquote>
<p>Communicating about research, both in written and spoken form, is a
critical part of being a researcher.</p>
</blockquote>
<blockquote>
<p>conferences were for meeting new people!</p>
</blockquote>
<blockquote>
<p>research can and should be motivated by teaching. If something
important is too difficult or confusing to explain to students, that’s a
sign that the underlying ideas can be improved.</p>
</blockquote>
<blockquote>
<p>Beyond the fact that lambda conquers all, what will always stick with
me is Bob’s advice to <strong>develop a point of view: I always try to
start a project by articulating exactly why it’s worthwhile, and keep
this perspective close at hand even when I’m deep in the technical
details</strong>.</p>
</blockquote>
<p>About Harper structuring his lectures as a story:</p>
<blockquote>
<p>With Bob, the story is paramount. In my undergraduate days, he was
well-known among the students for his bombastic and mind-expanding
lectures. As his teaching assistant and then doctoral student, I saw he
was forever looking for ways to improve them, to drill down to the
essence. Each year he’d reconstruct and reinvent his lesson plans, and
in our weekly meetings he’d often take me on a tour through his latest
perspective. When we sat down to plan out a paper, the first questions
were the story-theoretical: what would be the hook? What was the climax?
We didn’t always agree at first what the story ought to be, but Bob
impressed upon me the importance of working through it together, of
putting in the effort to hammer out something that satisfied us both</p>
</blockquote>
<p>Checkout:</p>
<ul>
<li>2006 ICFP Programming Contest: <em>Bound Variable</em></li>
<li>Frank Pfenning’s course notes and Milner's Pi Calculus.</li>
<li><strong>Logical relations</strong></li>
</ul>
<hr />
<p>Kern, C. and Greenstreet, M.R., <strong>1999</strong>. <em>Formal
verification in hardware design: a survey</em>. ACM Transactions on
Design Automation of Electronic Systems (TODAES), 4(2), pp.123-193.</p>
<blockquote>
<p>Formal verification, in contrast to testing, uses rigorous
mathematical reasoning to show that a design meets all or parts of its
specification. This requires the existence of formal descriptions for
both the specification and implementa- tion. Such descriptions are given
in notational frameworks with a formal semantics that unambiguously
associates a mathematical object with each description, permitting these
objects to be manipulated in a formal mathematical framework. […]
notational frameworks, including predicate logic, temporal logic</p>
</blockquote>
<hr />
<p>Guo, X., Dutta, R.G., Mishra, P. and Jin, Y., 2016, May. Scalable SoC
trust verification using integrated theorem proving and model checking.
In 2016 IEEE International Symposium on Hardware Oriented Security and
Trust (HOST) (pp. 124-129). IEEE.</p>
<ul>
<li>IP (intellectual property) cores are proprietory designs, right? How
can it be formally verified when its design is not revealed?
<ul>
<li>DBT: They mention examining traces. Oh.. so this might be where
runtime verification becomes relevant?</li>
<li>DBT: Maybe runtime verification is actually a part of post-silicon
validation?
<ul>
<li>But in that case, shouldn't the monitor be always there? And
post-silicon validation have to end at some point.</li>
</ul></li>
<li>DBT: "model checking is used for detecting malicious logic that
corrupts data in critical registers of third-party IP cores" (quote from
paper)</li>
</ul></li>
<li>Safety properties: Must always be true</li>
<li>Liveliness properties: Must be true at least once</li>
<li>DBT: "not all security properties can be expressed as traces". An
example of such a property?</li>
<li>"formal verification frameworks such as proof-carrying hardware
(PCH), which rely on an interactive theorem prover for evaluating
trustworthiness of IP cores, are not scalable to SoC designs". Why? If
it works for cores, why not for SoCs? Because it's the design is much
bigger?</li>
<li>Looks like the authors target VHDL from Coq.
<ul>
<li>Smaller proofs are done with model checker and bigger ones built
from the smaller ones used in coq proofs.</li>
</ul></li>
</ul>
<p>Refs to look at:</p>
<ul>
<li>Proof-carrying hardware intellectual property: A pathway to trusted
module acquisition</li>
<li>Backspace: formal analysis for post-silicon debug</li>
<li>Proof-carrying hardware: Runtime formal verification for secure
dynamic reconfiguration</li>
<li>Pre-silicon security verification and validation: A formal
perspective</li>
<li>G. C. Necula, Proof-carrying code (POPL 1997)</li>
<li>Formally verifying ieee compliance of floating-point hardwar (an
intel tech report or something)</li>
</ul>
<hr />
<p>Herklotz, Y., Pollard, J.D., Ramanathan, N. and Wickerson, J.,
<strong>2021</strong>. <em>Formal verification of high-level
synthesis</em>. Proceedings of the ACM on Programming Languages,
5(OOPSLA), pp.1-30.</p>
<p>Source code available at: <a
href="https://github.com/ymherklotz/vericert">https://github.com/ymherklotz/vericert</a></p>
<p>Extended compcert to make an HDL with a verilog backend.</p>
<ul>
<li>translation validation
<ul>
<li>Pnueli 1998 paper</li>
<li>DBT: How is this any different than proving that the translator is
correct? The translator's correctness is the correctness of its
translation itself, right?</li>
</ul></li>
<li>They used a semantics of verilog that was already made by others
within HOL in 2019</li>
<li>Bencharking done with: PolyBench/C benchmark suite
<ul>
<li><a
href="https://web.cse.ohio-state.edu/~pouchet.2/software/polybench/">https://web.cse.ohio-state.edu/~pouchet.2/software/polybench/</a></li>
<li>Looks like these are C files.</li>
</ul></li>
<li>Coq: <code>Separate Extraction &lt;list-of-files&gt;</code>
<ul>
<li><a
href="https://github.com/ymherklotz/vericert/blob/master/src/extraction/Extraction.v">https://github.com/ymherklotz/vericert/blob/master/src/extraction/Extraction.v</a></li>
</ul></li>
</ul>
<blockquote>
<p>the object of the proof is the same as the implementation of the
tool.</p>
</blockquote>
<hr />
<p>Joyce, J.J., Liu, E., Rushby, J.M., Shankar, N., Suaya, R. and von
Henke, F.W., <strong>1990</strong>. <em>From formal verification to
silicon compilation</em>. University of British Columbia, Department of
Computer Science.</p>
<ul>
<li>Intel 486 error (still recent in 1990 apparently. But wikipedia says
Thomas Nicely discovered it in 1994 ??)</li>
<li>Only VLSI design that was formally verified: British Viper
microprocessor</li>
</ul>
<blockquote>
<p>Our main conclusion is that the <strong>most effective use of formal
hardware verification will be at the higher levels of VLSI system
design, with lower levels best handled by conventional VLSI CAD
tools</strong>.</p>
</blockquote>
<blockquote>
<p>Formal verification, the mathematical demonstration of consistency
between a specification and a design</p>
</blockquote>
<blockquote>
<p>Formal hardware verification is no more than an academic exercise
unless verified designs can be turned into functional chips.</p>
</blockquote>
<hr />
<p>Minsky, Y. and Weeks, S., <strong>2008</strong>. <em>Caml trading -
Experiences with functional programming on Wall Street</em>. Journal of
Functional Programming, 18(4), pp.553-564.</p>
<ul>
<li>Private types
<ul>
<li>Values can be constructed only by some functions.</li>
<li>But value can be pattern matched against by any function.</li>
</ul></li>
<li>Phantom types
<ul>
<li><a
href="https://blog.janestreet.com/howto-static-access-control-using-phantom-types/">https://blog.janestreet.com/howto-static-access-control-using-phantom-types/</a></li>
</ul></li>
<li>Apparently ocaml does support inheritance, but it's considered an
obscure feature that noone really uses.</li>
<li>Generational collector: kind of garbage collection that ocaml has
got (remember that this paper was written in 2008 though).</li>
<li>camlp4: can essentially modifies syntax of ocaml
<ul>
<li>A macro system</li>
<li>Can add new syntax or change meaning of existing syntax.</li>
<li>Has been used to make DSLs that can be boiled down to ocaml.</li>
</ul></li>
<li>I suppose this is what the s-expression converting thing that they
made eventually became: <a
href="https://github.com/janestreet/ppx_sexp_conv">https://github.com/janestreet/ppx_sexp_conv</a></li>
<li>ocaml findlib</li>
<li>ocaml has and ExtLib library as well since stdlib has drawback which
are not being changed. 3rd party of course.</li>
</ul>
<blockquote>
<p>The main point of code review is for the reader to put together an
informal proof that the code they are reading does the right thing.
Constructing such a proof is of course difficult, and we try to write
our code to <strong>pack as much of the proof into the type system as
possible</strong>.</p>
</blockquote>
<blockquote>
<p><strong>make illegal states unrepresentable</strong></p>
</blockquote>
<hr />
<p>Johnsson, T., <strong>1985</strong>. <em>Lambda lifting: Transforming
programs to recursive equations</em> (pp. 190-203). Springer Berlin
Heidelberg.</p>
<p>let f x = x * x in f</p>
<ul>
<li>f = λx =&gt; x*x</li>
<li>λf =&gt; f</li>
</ul>
<p>ie, (λf =&gt; f) (λx =&gt; x*x)</p>
<blockquote>
<p>The process of flattening out a program involving local function
definitions, possibly with free variables, into a program consisting
only of global function definitions, we call <strong>lambda
lifting</strong>.</p>
</blockquote>
<p>η-expand with each free variable in e for λx.e</p>
<p>Eg:</p>
<pre><code>λx.y

Here, y is free. So we η-expand with y:

(λy. λx. y) y

Thus the &#39;inner&#39; term is closed. All abstractions are now in the beginning.
</code></pre>
<p>2 rewrite rules:</p>
<pre><code>let x = e1 in e2      ↔   (λx.e2) e1

letrec x = e1 in e2   ↔   let x = Y(λx.e1) in e2
                          (λx.e2) [Y(λx.e1)]
</code></pre>
<p>—</p>
<p><strong>Attempt 1 method</strong></p>
<p>Example:</p>
<pre><code>let i = 5 in
letrec f = λx.f i in
f i

Converting the letrec to let,

let i = 5 in
let f = Y (λf. λx.f i) in
f i

Rewriting the inner let,

let i = 5 in
(λf. f i) [Y (λf. λx.f i)]

Rewriting the remaining let,

(λi. {(λf. f i) [Y (λf. λx.f i)]}) 5

η-expanding few subterms to make free variables bound:
 - (λf. f i)       ↔  (λi.λf.f i) i 
 - (λf. λx.f i)    ↔  (λi.λf. λx.f i) i

which makes the term:

(λi. {[(λi.λf.f i) i] [Y ((λi.λf. λx.f i) i)]}) 5
</code></pre>
<p>—</p>
<p><strong>Attempt 2 method</strong></p>
<hr />
<p>Moggi, E., <strong>1991</strong>. <em>Notions of computation and
monads</em>. Information and computation, 93(1), pp.55-92.</p>
<p>A 'more refined' follow up to his 1988 paper.</p>
<p>—</p>
<p>A digression:</p>
<ul>
<li>bind: F A -&gt; (A -&gt; F B) -&gt; F B</li>
<li>return: A -&gt; F A</li>
</ul>
<table>
<tbody>
<tr class="odd">
<td>bind (return a) fab ≡ fab a</td>
<td>return a &gt;&gt;= fab ≡ fab a</td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>where:</p>
<ul>
<li>a: A</li>
<li>ma: F A</li>
</ul>
<p>ma &gt;&gt;= return</p>
<p>Monad composition operator (aka Kleisli operator) in haskell:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;=&gt;</span><span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m c)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">&gt;=&gt;</span>) ab bc <span class="ot">=</span> \a <span class="ot">-&gt;</span> (ab a) <span class="op">&gt;&gt;=</span> bc</span></code></pre></div>
<h2 id="may">May</h2>
<p>Maurer, L., Downen, P., Ariola, Z.M. and Peyton Jones, S., 2017,
June. <a
href="https://www.pauldownen.com/publications/pldi17.pdf"><em>Compiling
without continuations</em></a>. In Proceedings of the 38th ACM SIGPLAN
Conference on Programming Language Design and Implementation (pp.
482-494).</p>
<ul>
<li>Join point: a point where multiple paths of execution converge</li>
<li>ANF (administrative normal form): 'Think in CPS, work in direct
style'</li>
</ul>
<p>—</p>
<ul>
<li>Commuting conversion. An example:</li>
</ul>
<pre><code>if (if e1 then e2 else e3) then e4 else e5

becomes

if e1 then (if e2 then e4 else e5)
      else (if e3 then e4 else e5)
</code></pre>
<ul>
<li>Commuting conversion is considered a problematic procedure ??</li>
<li>Originated from Gentzen's natural deduction.</li>
<li>Jean-Yves Girard didn't seem to like this.</li>
</ul>
<p>Links:</p>
<ul>
<li><a
href="https://proofassistants.stackexchange.com/questions/1202/what-is-a-commuting-conversion-and-why-are-they-problematic">https://proofassistants.stackexchange.com/questions/1202/what-is-a-commuting-conversion-and-why-are-they-problematic</a></li>
<li><a
href="https://webpages.ciencias.ulisboa.pt/~fjferreira/commuting.pdf">https://webpages.ciencias.ulisboa.pt/~fjferreira/commuting.pdf</a></li>
</ul>
<hr />
<p>Functional pearl: <a
href="https://www.cmi.ac.in/~spsuresh/teaching/prgh15/papers/monadic-parsing.pdf">Monadic
parsing in Haskell</a> - Graham Hutton, Erik Meijer (1998)</p>
<h2 id="april-1">April</h2>
<p>Harper, R., <strong>1999</strong>. <a
href="http://www.aladdin.cs.cmu.edu/papers/pdfs/y2000/functional_pearls.pdf"><em>Proof-directed
debugging</em></a>. Journal of functional programming, 9(4),
pp.463-469.</p>
<hr />
<p>Partial derivatives of regular expressions and finite automaton
constructions - Valentin Antimirov</p>
<ul>
<li>Brzozowski's word derivatives: DFA</li>
<li>Antimirov's partial derivatives: NFA</li>
</ul>
<p>Glushkov [14]: regex to NFA algorithm</p>
<p><a
href="https://gist.github.com/neel-krishnaswami/7353772">https://gist.github.com/neel-krishnaswami/7353772</a>
<a
href="http://semantic-domain.blogspot.com/2013/11/antimirov-derivatives-for-regular.html">http://semantic-domain.blogspot.com/2013/11/antimirov-derivatives-for-regular.html</a></p>
<hr />
<p>Owens, S., Reppy, J. and Turon, A., <strong>2009</strong>.
<em>Regular-expression derivatives re-examined</em>. Journal of
Functional Programming, 19(2), pp.173-190.</p>
<hr />
<p>Danvy, O. and Nielsen, L.R., 2001, September. <a
href="https://www.brics.dk/RS/01/23/BRICS-RS-01-23.pdf"><em>Defunctionalization
at work</em></a>. In Proceedings of the 3rd ACM SIGPLAN international
conference on Principles and practice of declarative programming (pp.
162-174)</p>
<ul>
<li>links: <span class="spurious-link" target="l8"><em>l8</em></span>,
<span class="spurious-link" target="l9"><em>l9</em></span></li>
</ul>
<p>Continuations: Functional representation of control</p>
<p>Aim: Make higher order functions first order.</p>
<p>Higher order function: Function that accepts another function as
argument.</p>
<p>Whole program available =&gt; We can defunctionalize.</p>
<p>—</p>
<p>Defunctionalization example:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode sml"><code class="sourceCode sml"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> aux f = (f <span class="dv">1</span>) + (f <span class="dv">10</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> main x y b =</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  (aux (λz. x + z)) * (aux (λz. <span class="kw">if</span> b <span class="kw">then</span> x+y <span class="kw">else</span> x-y))</span></code></pre></div>
<p><code>aux</code> is a higher order function. ∵ it takes
<code>f</code> which itself is a function, as an argument.</p>
<p>Let's defunctionalize <code>aux</code>.</p>
<p>Observe the ways in which <code>aux</code> has been used. There are
only two ways:</p>
<ul>
<li><code>aux (λz. x + z)</code></li>
<li><code>aux (λz. if b then y+z else y-z)</code></li>
</ul>
<p>Let's make it a type:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode sml"><code class="sourceCode sml"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">datatype</span> auxType</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  = Plus <span class="kw">of</span> <span class="dt">int</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  | Cond <span class="kw">of</span> <span class="dt">bool</span> * <span class="dt">int</span></span></code></pre></div>
<p>Now we need a way to use this type to get the same effect as the
original <code>aux</code> function.</p>
<p>Each of the <code>aux</code> usage accepts an integer as an argument.
So,</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode sml"><code class="sourceCode sml"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* apply : auxType -&gt; int -&gt; int *)</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> apply f z =</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> f <span class="kw">of</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    Plus x -&gt; x + z</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  | Cond b y -&gt; <span class="kw">if</span> b <span class="kw">then</span> y+z <span class="kw">else</span> y-z</span></code></pre></div>
<p>Now to have the <code>aux</code> and <code>main</code>
equivalent:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode sml"><code class="sourceCode sml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* auxDef : auxType -&gt; int *)</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> auxDef f = (apply f <span class="dv">1</span>) + (apply f <span class="dv">10</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>main : auxType -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">bool</span> -&gt; <span class="dt">int</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> main x y b</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  = (auxDef (Plus x)) * (auxDef (Cond b y))</span></code></pre></div>
<p>A coq version:</p>
<pre class="coq"><code>Definition aux (f:nat-&gt;nat) : nat := (f 1) + (f 10).         
Definition main (x y:nat) (b:bool) : nat :=                  
  (aux (fun z=&gt;x+z)) * (aux (fun z=&gt;if b then y+z else y-z)).
Compute main 3 5 true.    (* 357:nat *)                      
Compute main 3 5 false.   (* 68:nat *)                       
(*Compute 17 * 21.*)                                         

(**********************************************)                                                             

Inductive auxType : Set :=                                   
| Plus: nat -&gt; auxType                                       
| Cond: bool -&gt; nat -&gt; auxType.                              

Definition apply (f:auxType) (z:nat) : nat :=                
  match f with                                               
  | Plus x =&gt; x + z                                          
  | Cond b y =&gt; if b then y+z else y-z                       
  end.                                                       
Definition auxDef (f:auxType) : nat :=                       
  (apply f 1) + (apply f 10).                                
Definition mainDef (x y:nat) (b:bool) : nat :=               
  (auxDef (Plus 3)) * (auxDef (Cond b 5)).                   
Compute mainDef 3 5 true.   (* 357:nat *)                    
Compute mainDef 3 5 false.  (* 68:nat *)                     
</code></pre>
<p>— 0ⁿ1ⁿ example</p>
<p>sml version:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode sml"><code class="sourceCode sml"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* walk : int list -&gt; (int list -&gt; bool) -&gt; bool *)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> walk (<span class="dv">0</span>::xs, k)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    = walk (xs, <span class="kw">fn</span> (<span class="dv">1</span>::ys) =&gt; k ys</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>                 | _       =&gt; <span class="kw">false</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  | walk (xs, k) =  k xs</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Base case: xs == nil *)</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Father... Is it over..? No king rules forever son.. *)</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="co">(* go : int list -&gt; bool *)</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> go xs = walk (xs, <span class="kw">fn</span> l =&gt; l = nil)</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="co">(* go [1,2,3]; *)</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="co">(* val it = false : bool *)</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="co">(* - go [0,0,0,1,1,1]; *)</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="co">(* val it = true : bool *)</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="co">(* *)</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="co">(* Function as argument =&gt; [fn] usages. *)</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="co">(* So there are two of them. *)</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="co">(* *)</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="co">(*************************************)</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="co">(*     Defunctionalized version      *)</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a><span class="co">(*************************************)</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a><span class="kw">datatype</span> kont</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>  = KId</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>  | KWalk <span class="kw">of</span> kont</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a><span class="co">(* apply: kont * int list -&gt; bool *)</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> apply (KId, xs)        = xs=nil</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>  | apply (KWalk k, <span class="dv">1</span>::xs) = apply (k, xs)</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>  | apply (KWalk _, _)     = <span class="kw">false</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a><span class="co">(* walkDef : int list -&gt; kont -&gt; bool *)</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> walkDef (<span class="dv">0</span>::xs) k = walkDef xs (KWalk k)</span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>  | walkDef xs k = apply (k, xs)</span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> goDef xs = walkDef xs KId</span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a><span class="co">(* - goDef [0,0,1,1]; *)</span></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a><span class="co">(* val it = true : bool *)</span></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a><span class="co">(* - goDef [0,0,1]; *)</span></span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a><span class="co">(* val it = false : bool *)</span></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a><span class="co">(********* Peano arithmetic **************************************)</span></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a><span class="co">(* apply: int * int list -&gt; bool *)</span></span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> applyP (<span class="dv">0</span>, xs)        = xs=nil</span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>  | applyP (k, <span class="dv">1</span>::xs) = applyP (k<span class="dv">-1</span>, xs)</span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>  | applyP _     = <span class="kw">false</span></span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a><span class="co">(* walkDef : int list -&gt; int -&gt; bool *)</span></span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> walkDefP (<span class="dv">0</span>::xs) k = walkDefP xs (k+<span class="dv">1</span>)</span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a>  | walkDefP xs k = applyP (k, xs)</span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> goDefP xs = walkDefP xs <span class="dv">0</span></span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a><span class="co">(* - goDefP [1,1,0]; *)</span></span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a><span class="co">(* val it = false : bool *)</span></span>
<span id="cb19-59"><a href="#cb19-59" aria-hidden="true" tabindex="-1"></a><span class="co">(* - goDefP [0,0,1,1]; *)</span></span>
<span id="cb19-60"><a href="#cb19-60" aria-hidden="true" tabindex="-1"></a><span class="co">(* val it = true : bool *)</span></span>
<span id="cb19-61"><a href="#cb19-61" aria-hidden="true" tabindex="-1"></a><span class="co">(* - goDefP [0,0,0,1,1,1]; *)</span></span>
<span id="cb19-62"><a href="#cb19-62" aria-hidden="true" tabindex="-1"></a><span class="co">(* val it = true : bool *)</span></span></code></pre></div>
<p>Coq version:</p>
<pre class="coq"><code>Require Import List.                                           
Import ListNotations.                                          

Definition isnil {A:Type} (l:list A) : bool :=                 
  match l with                                                 
  | nil =&gt; true                                                
  | _ =&gt; false                                                 
  end.                                                         

Module goHof.
  Fixpoint walk (l:list nat) (k:list nat -&gt; bool) : bool :=
    match l with                                                 
    | 0::xs =&gt; walk xs                                           
        (fun xs =&gt; match xs with                                 
                   | 1 :: xs =&gt; k xs                             
                   | _ =&gt; false                                  
                   end)                                          
    | _ =&gt; k l                                                   
    end.                                                         
  Definition go (l:list nat) : bool := walk l (fun xs=&gt;isnil xs).
  Compute go [0;0;1;1].                                          
  Compute go [0;0;1].                                            
End goHof.

Module goDefun.                                          
  Inductive kont : Set :=                                
  | KId: kont                                            
  | KWalk: kont -&gt; kont.                                 

  Fixpoint apply (k:kont) (l:list nat) : bool :=         
    match k with                                         
    | KId =&gt; isnil l                                     
    | KWalk kk =&gt;                                        
        match l with                                     
        | 1::xs =&gt; apply kk xs                           
        | _ =&gt; false                                     
        end                                              
    end.                                                 

  Fixpoint walkDef (l:list nat) (k:kont) : bool :=       
    match l with                                         
    | 0::xs =&gt; walkDef xs (KWalk k)                      
    | _ =&gt; apply k l                                     
    end.                                                 
  Definition goDef (l:list nat) : bool := walkDef l KId. 
  Compute goDef [0;0;1;1].                               
  Compute goDef [0;0;1].                                 
End goDefun.                                             

Module goDefunPeano.                                   
  Fixpoint apply (k:nat) (l:list nat) : bool :=        
    match k with                                       
    | O =&gt; isnil l                                     
    | S kk =&gt;                                          
        match l with                                   
        | 1::xs =&gt; apply kk xs                         
        | _ =&gt; false                                   
        end                                            
    end.                                               

  Fixpoint walkDef (l:list nat) (k:nat) : bool :=      
    match l with                                       
    | 0::xs =&gt; walkDef xs (S k)                        
    | _ =&gt; apply k l                                   
    end.                                               
  Definition goDef (l:list nat) : bool := walkDef l O. 
  Compute goDef [0;0;1;1].                             
  Compute goDef [0;0;1].                               
End goDefunPeano.
</code></pre>
<p>—</p>
<h2 id="march">March</h2>
<p>Moggi, E., <strong>1988</strong>. <a
href="https://www.lfcs.inf.ed.ac.uk/reports/88/ECS-LFCS-88-66/ECS-LFCS-88-66.pdf"><em>Computational
lambda-calculus and monads</em></a>. University of Edinburgh, Department
of Computer Science, Laboratory for Foundations of Computer Science.</p>
<p>Paper that inspired use of monads in Haskell.</p>
<hr />
<p><a href="https://math.ucr.edu/home/baez/rosetta.pdf">Physics,
Topology, Logic and Computation: A Rosetta Stone</a> - John C. Baez,
Mike Stay</p>
<p>In Physics,</p>
<ul>
<li>Relativity: Explains gravity without considering quantum
theory.</li>
<li>Standard model of particle: Explains every other forces while also
considering quantum theory.</li>
</ul>
<p>Search is still on to have a 'unified' theory.</p>
<table>
<tbody>
<tr class="odd">
<td>Category</td>
<td>Logic</td>
<td>Computation</td>
<td>Physics</td>
<td>Topology</td>
</tr>
<tr class="even">
<td>Object</td>
<td>Proposition</td>
<td>Type</td>
<td>System</td>
<td>Manifold</td>
</tr>
<tr class="odd">
<td>Morphism</td>
<td>Proof</td>
<td>Program?</td>
<td>Process</td>
<td>Cobordism</td>
</tr>
</tbody>
</table>
<p>Linear operators as diagrams in quantum field theory: Feynman
diagrams</p>
<pre><code>\   /
 \ /
  +
  ⟆
  ⟆
  +
 / \
/   \
</code></pre>
<p>New stuff:</p>
<ul>
<li>Hilbert space and linear operators</li>
</ul>
<hr />
<p><em>Choice Trees: Representing Nondeterministic, Recursive, and
Impure Programs in Coq</em> - Nicolas Chappe, Paul He, Ludovic Henrio,
Yannick Zakowski, Steve Zdancewic <a
href="https://github.com/vellvm/ctrees">https://github.com/vellvm/ctrees</a></p>
<p>Choice tree Builds over Interaction trees.</p>
<blockquote>
<p>The key idea is to update Xia, et al.’s interaction trees (ITrees)
framework [Xia et al. 2020] with native support for nondeterminisic
“choice nodes” that represent internal choices made during
computation.</p>
</blockquote>
<blockquote>
<p>How "deep" the embedding is affects the amount of effort needed to
implement a formal semantics - "shallower" embeddings typically allow
more re-use of metalanguage features, e.g., meta-level function
application can obviate the need to define and prove properties about a
substitution operation; "deeper" embeddings can side-step meta-level
limitations (such as Coq’s insistence on pure, total functions) at the
cost of additional work to define the semantics.</p>
</blockquote>
<blockquote>
<p>to use QuickChick, one must be able to extract an executable
interpreter from the semantics</p>
</blockquote>
<ul>
<li>CCS (Calculus of Communicating Systems): Robin Milner 1981</li>
<li>CPS (Calculus of Sequential Processes): Tony Hoare</li>
<li>Pi calculus: Milner, et al. 1980s
<ul>
<li>Extends CCS.</li>
</ul></li>
</ul>
<p>In ITree monad, eutt: Equivalence up-to taus:</p>
<ul>
<li>Weak bisimulation</li>
<li>Allows us to ignore finite sequence of <code>tau~s (~later</code> in
CTree)</li>
</ul>
<pre class="coq"><code>Inductive ctree E res
| Ret: res -&gt; ctree E res
| Vis: ctree E res
| Later: ctree E res -&gt; ctree E res.
</code></pre>
<p>Dbts:</p>
<ul>
<li>Sidestepped some issue with implementing CCS. What issue was
that?</li>
<li>Weak vs strong bisimulation</li>
</ul>
<p>Effect type: <code>E A</code> where <code>A</code> is the type of the
'answer' given to the system.</p>
<hr />
<p><a
href="https://web.archive.org/web/20170922035945/https://www.cl.cam.ac.uk/~so294/documents/jfp09.pdf">Brzozowski</a>:
regex to dfa</p>
<p>regex derivative</p>
<hr />
<p><a
href="http://strictlypositive.org/CJ.pdf">http://strictlypositive.org/CJ.pdf</a></p>
<h2 id="feb">Feb</h2>
<p>An article. <a
href="https://www.ams.org/notices/200811/tx081101408p.pdf">Formal
Proof—Getting Started</a> by Freek Wiedijk</p>
<ul>
<li>Gödel's incompleteness theorem has been made in Coq by Natarajan
Shankar</li>
</ul>
<hr />
<p>Kleene Algebra with Tests and the Static Analysis of Programs: Kozen,
Dexter <a
href="https://hdl.handle.net/1813/5627">https://hdl.handle.net/1813/5627</a></p>
<blockquote>
<p>The automaton can be used for runtime enforcement of the security
policy as well as specification. The program code is instrumented to
call the automaton before all critical operations (ones that could
change state of the automaton)</p>
</blockquote>
<hr />
<ol>
<li>Kennedy. Compiling with continuations, continued. In Proceedings of
the International Conference on Functional Programming, pages 177–190,
New York, NY, USA, 2007. ACM.</li>
</ol>
<p>'monadic terms can be translated into CPS in linear-time'</p>
<hr />
<p><a
href="https://se.cs.uni-tuebingen.de/publications/mueller23continuation.pdf">Continuation-Passing
to Direct Style: Typed and Tight</a></p>
<ul>
<li>Accepted for OOPSLA'23.</li>
<li><a
href="https://github.com/ps-tuebingen/oopsla-2023-btdstt-artifact/blob/master/BtDS.idr">https://github.com/ps-tuebingen/oopsla-2023-btdstt-artifact/blob/master/BtDS.idr</a></li>
</ul>
<p>CPS:</p>
<ul>
<li><strong>no term ever returns</strong>. Instead, they will jump to
the next continuation</li>
</ul>
<hr />
<ol>
<li>Farvardin and J. Reppy. From folklore to fact: Comparing
implementations of</li>
</ol>
<p>stacks and continuations. In Proceedings of the 41st ACM SIGPLAN
Conference on Programming Language Design and Implementation, PLDI 2020,
page 75–90, New York, NY, USA, 2020. Association for Computing
Machinery. ISBN 9781450376136. doi: 10.1145/3385412.3385994. URL <a
href="https://doi.org/10.1145/3385412.3385994">https://doi.org/10.1145/3385412.3385994</a>.
12 M. Felleisen, D. P. Friedman, E. Kohlbecker, and B. Duba. A syntactic
theory of</p>
<hr />
<p>Beckett, R., Greenberg, M. and Walker, D., <strong>2016</strong>,
June. <em>Temporal netkat</em>. In Proceedings of the 37th ACM SIGPLAN
Conference on Programming Language Design and Implementation (pp.
386-401).</p>
<ul>
<li>Past-time LTL with KAT</li>
<li>Predicates (à la test) and policies (à la action)
<ul>
<li>Syntax: <code>predicate; policy</code></li>
</ul></li>
<li>Combinators: Composability matters</li>
<li>'sound and complete equational theory akin to that of the original
NetKAT language'</li>
<li>LTL𝑓: LTL over finite traces</li>
<li>They have <strong>benchmarks</strong>!</li>
<li>Offtopic: Pyretic's buckets</li>
<li><code>h</code>: packet history</li>
<li>Equational theory seems to mean just some rewrite rules.</li>
</ul>
<p>TODO: Conversion of past-LTL to LTL</p>
<p>Past-LTL:</p>
<ul>
<li>◯p: last</li>
<li>◇p: ever (at some point in the past p was true)</li>
<li>□p: always (at all points in the past p was true)</li>
<li>pSq: since (p has been true ever since q was true??)
<ul>
<li>Both ◇ and □ can be defined in terms of S</li>
</ul></li>
</ul>
<hr />
<p>Greenberg, M., Beckett, R. and Campbell, E., <strong>2022</strong>,
June. <em>Kleene algebra modulo theories: a framework for concrete
KATs</em>. In Proceedings of the 43rd ACM SIGPLAN International
Conference on Programming Language Design and Implementation (pp.
594-608).</p>
<p>KAT consists:</p>
<ul>
<li>predicates (like guards for actions)</li>
<li>actions
<ul>
<li>Action fires if the guarding predicate is true</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb23"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> i<span class="op">&lt;</span><span class="dv">50</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> i<span class="op">&lt;</span><span class="dv">100</span>:</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    j <span class="op">+=</span> <span class="dv">2</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> j<span class="op">&gt;</span><span class="dv">100</span></span></code></pre></div>
<p>If:</p>
<table>
<thead>
<tr class="header">
<th>Predicates</th>
<th>Actions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>α: i&lt;50</td>
<td>p: i+=1</td>
</tr>
<tr class="even">
<td>β: i&lt;100</td>
<td>q: j+=2</td>
</tr>
<tr class="odd">
<td>γ: j&gt;100</td>
<td></td>
</tr>
</tbody>
</table>
<p>then in KAT, this is:</p>
<pre><code>α⋅(β⋅p⋅q)*⋅¬β⋅γ
</code></pre>
<p>One step of unrolling of this gives:</p>
<pre><code>   α⋅¬β⋅γ + α⋅β⋅p⋅q⋅(β⋅p⋅q)*⋅¬β⋅γ
≡  α⋅(1 + β⋅p⋅q⋅(β⋅p⋅q)*)⋅¬β⋅γ
</code></pre>
<p>KMT for nat based on above example:</p>
<ul>
<li>New actions:
<ul>
<li>inc(x)</li>
<li>x := n</li>
</ul></li>
<li>New test (ie, predicates):
<ul>
<li>x &gt; n</li>
</ul></li>
<li>New values:
<ul>
<li>n ∈ ℕ</li>
</ul></li>
</ul>
<pre><code>       V      (variables)
σ: V → ℕ      (program state. ie, env)

         t    (trace of states)
act: σ → σ

pred: σ → ℙ
</code></pre>
<p>KMT for 𝔹:</p>
<ul>
<li>New values:
<ul>
<li>t f ∈ 𝔹</li>
</ul></li>
</ul>
<p>Refs to look at:</p>
<ul>
<li>[51], [23]</li>
<li><a
href="https://github.com/mgree/kmt">https://github.com/mgree/kmt</a>
<ul>
<li>Common, Syntax, kat, kmt, boolean, incnat</li>
</ul></li>
</ul>
<hr />
<p>Handbook of theoretical computer science - Volume B: Lambda calculus
chapter</p>
<p>Reduction of terms done using rewrite rules. No more reductions
possible =&gt; normal form. Normal form =&gt; output</p>
<p>Church-Rosser property: normal form obtained is independent of order
of evaluation of subterms.</p>
<p>SKI calculus:</p>
<pre><code>I := λx. x
K := λx y. x
S := λx y z. x z (y z)
</code></pre>
<hr />
<p>Harrison, W.L., Hathhorn, C. and Allwein, G., <strong>2021</strong>,
September. <em>A Mechanized Semantic Metalanguage for High Level
Synthesis</em>. In 23rd International Symposium on Principles and
Practice of Declarative Programming (pp. 1-14).</p>
<ul>
<li>DBT: multiple clock domains</li>
<li>FIRRTL of Chisel (HDL). Aim is to be an IR that can then be
translated as needed.
<ul>
<li><a
href="https://www.chisel-lang.org/firrtl/">https://www.chisel-lang.org/firrtl/</a></li>
</ul></li>
</ul>
<h2 id="jan">Jan</h2>
<p>Oliveira, B.C. and Cook, W.R., <strong>2012</strong>, September. <a
href="https://www.cs.utexas.edu/~wcook/Drafts/2012/graphs.pdf"><em>Functional
programming with structured graphs</em></a>. In Proceedings of the 17th
ACM SIGPLAN international conference on Functional programming (pp.
77-88).</p>
<p>Code: <a
href="https://github.com/michaelt/structured-graphs">https://github.com/michaelt/structured-graphs</a></p>
<p>PHOAS: By necessitating that the universally quantified
<code>a</code> be kept abstract, we ensure that only names bound with a
<code>PAbs</code> can be used in a <code>PVar</code>.</p>
<p>Generic graph:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">GraphP</span> f a <span class="ot">=</span> <span class="dt">Var</span> a                        <span class="co">-- ^ Variable</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>                <span class="op">|</span> <span class="dt">Mu</span> ([a] <span class="ot">-&gt;</span> [f (<span class="dt">GraphP</span> f a)]) <span class="co">-- ^ Multi-binder. &#39;Multi-forks&#39;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>                <span class="op">|</span> <span class="dt">In</span> (f (<span class="dt">GraphP</span> f a))          <span class="co">-- ^ Recursive step</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Graph</span> <span class="ot">=</span> <span class="dt">Hide</span> {</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  reveal ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">GraphP</span> f a</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>where <code>f</code> is a type.</p>
<p>(I guess <code>Mu</code> is <code>([a] -&gt; [f (GraphP f a)])</code>
instead of <code>([a] -&gt; [(GraphP f a)])</code> to avoid empty
looping.)</p>
<p>—</p>
<p>Application to grammars.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Re</span> a <span class="ot">=</span> <span class="dt">Cat</span> (<span class="dt">Re</span> a) (<span class="dt">Re</span> a)   <span class="co">-- ^ Seq</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Split</span> (<span class="dt">Re</span> a) (<span class="dt">Re</span> a) <span class="co">-- ^ Alt</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Acc</span>                 <span class="co">-- ^ Accept</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Match</span>               <span class="co">-- ^ Accept</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Loop</span>                <span class="co">-- ^ Recurse</span></span></code></pre></div>
<hr />
<p>Parravicini, D., Conficconi, D., Sozzo, E.D., Pilato, C. and
Santambrogio, M.D., <strong>2021</strong>. <em>Cicero: A domain-specific
architecture for efficient regular expression matching</em>. ACM
Transactions on Embedded Computing Systems (TECS), 20(5s), pp.1-24.</p>
<ul>
<li>Powerset algorithm for NFA to DFA =&gt; number of states increases
exponentially.</li>
</ul>
<p>—</p>
<blockquote>
<p>Despite significant algorithmic improvements, software solutions
cannot keep pace with the increasing size of the processed data (either
input strings or REs). For this reason, hardware ac- celeration is a
valid alternative for computationally-intensive kernels such as those
for RE matching</p>
</blockquote>
<p>Hardware is better at RE matching?</p>
<p>— CICERO instructions</p>
<blockquote>
<p>CICERO instructions are stateless</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>Kind</th>
<th>Instr</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Match</td>
<td>MatchAny</td>
<td><code>.</code></td>
</tr>
<tr class="even">
<td></td>
<td>Match(c)</td>
<td><code>c</code></td>
</tr>
<tr class="odd">
<td></td>
<td>NoMatch(c)</td>
<td><code>[^c]</code></td>
</tr>
<tr class="even">
<td>Control</td>
<td>Split d</td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td>Jmp d</td>
<td></td>
</tr>
<tr class="even">
<td>Accept</td>
<td>AcceptPartial</td>
<td>Match when word needn't be over</td>
</tr>
<tr class="odd">
<td></td>
<td>Accept</td>
<td>Match when word over</td>
</tr>
</tbody>
</table>
<p>— CICERO compiler</p>
<ul>
<li>No backrefs in input regex</li>
<li>Optimizations to make a balanced decision tree</li>
<li>DBT: Multi-engine arch?</li>
</ul>
<p>— Single char mechanism example:</p>
<ul>
<li>regex: ab(b|a)b</li>
</ul>
<table>
<thead>
<tr class="header">
<th>No</th>
<th>Instr</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Match a</td>
</tr>
<tr class="even">
<td>2</td>
<td>Match b</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Split 7</td>
</tr>
<tr class="even">
<td>4</td>
<td>Match a</td>
</tr>
<tr class="odd">
<td>5</td>
<td>Match b</td>
</tr>
<tr class="even">
<td>6</td>
<td>Jmp 10</td>
</tr>
<tr class="odd">
<td>7</td>
<td>Match b</td>
</tr>
<tr class="even">
<td>8</td>
<td>Match b</td>
</tr>
<tr class="odd">
<td>9</td>
<td>Jmp 10</td>
</tr>
<tr class="even">
<td>10</td>
<td>Accept<sub>partial</sub></td>
</tr>
</tbody>
</table>
<ul>
<li>word: ababcd</li>
</ul>
<table>
<thead>
<tr class="header">
<th>FIFO-0</th>
<th>FIFO-1</th>
<th>Parsed</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Match a</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>Match b</td>
<td>a</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Comment:</p>
<ul>
<li>FIFO of current character</li>
<li>Fetch current character</li>
</ul>
<p>—</p>
<ul>
<li>Checkout: google re2 (C++): <a
href="https://github.com/google/re2">https://github.com/google/re2</a></li>
</ul>
<hr />
<p>Baaij, C., Kooijman, M., Kuper, J., Boeijink, A. and Gerards, M.,
<strong>2010</strong>, September. <a
href="https://ris.utwente.nl/ws/files/5409836/c%C3%8E%C2%BBash.pdf"><em>Cλash:
Structural descriptions of synchronous hardware using haskell</em></a>.
In 2010 13th Euromicro Conference on Digital System Design:
Architectures, Methods and Tools (pp. 714-721). IEEE.</p>
<ul>
<li>Haskell as an HDL</li>
</ul>
<p>Possible mapping to hardware:</p>
<ul>
<li>Functions: components (like mux)</li>
<li>Arguments: Input ports</li>
<li>Result: Output port
<ul>
<li>Multiple output ports possible if result type is a tuple</li>
</ul></li>
<li>Function application: Component instantiation</li>
</ul>
<p>Eg:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- res = a*b + c</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>mac a b c <span class="ot">=</span> add (mul a b) c</span></code></pre></div>
<pre><code>      +--------------------------+
      |   +-----+       +-----+  |
a ----|---|     |-------| add |  |
b ----|---| mul |    +--|     |--|---&gt;
      |   +-----+    |  +-----+  |
c ----|--------------+           |
      +--------------------------+
</code></pre>
<p>—</p>
<p>Choices:</p>
<ul>
<li>Haskell's <code>if-else</code> can be reduced to <code>case</code>
expressions.</li>
<li><code>case</code> expressions are mapped to mux components.
<ul>
<li>Selection line generated based on value on which <code>case</code>
is done.</li>
</ul></li>
<li>Pattern matching. Not available in most HDLs.</li>
<li>Guards</li>
</ul>
<p>—</p>
<blockquote>
<p>Not all of Haskell’s typing constructs have a clear translation to
hardware</p>
</blockquote>
<p>TODO: An example of a construct that can't be translated to
hardware?</p>
<p>—</p>
<p>Type annotation:</p>
<table>
<thead>
<tr class="header">
<th>VHDL</th>
<th>Clash</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Entity</td>
<td>Type annotation</td>
</tr>
<tr class="even">
<td>Mandatory</td>
<td>Can often be inferred</td>
</tr>
</tbody>
</table>
<p>— Built-in types:</p>
<ul>
<li>Bit: High, Low</li>
<li>Bool: True, False
<ul>
<li>For condition in <code>if</code></li>
</ul></li>
<li>Signed, Unsigned
<ul>
<li>Represent integers</li>
<li>Parametrized over size</li>
<li>Overflow =&gt; wrap-around</li>
</ul></li>
<li>Vector</li>
<li>Index: To index into a Vector value</li>
</ul>
<p>User-defined datatypes with multiple constructors where at least one
constructor accepts an argument is not supported.</p>
<p>TODO: Try:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Eg</span> <span class="ot">=</span> <span class="dt">One</span> <span class="dt">Int</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">Two</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
<p>Works but I guess won't synthesize.</p>
<pre><code>&gt; :{
| data Eg = One Int
|         | Two
|         deriving Show
| :}
&gt; One 2
One 2
</code></pre>
<p>—</p>
<p>Advantages of clash as HDL:</p>
<ul>
<li>Parametric polymorphism</li>
</ul>
<p>Ad-hoc polymorphism:</p>
<ul>
<li>Via type classes</li>
<li>Based on context, type is inferred.</li>
</ul>
<p>Top level (<code>topEntity</code>) cannot be left polymorphic and
must have a concrete type. Only the design is polymorphic.</p>
<p>Higher order functions:</p>
<p>Eg: <code>negVector v = map not v</code></p>
<p>— Todo:</p>
<ul>
<li>Example of netlist</li>
</ul>
<hr />
<p>Harper, R., Duba, B.F. and MacQueen, D., <strong>1993</strong>.
<em>Typing first-class continuations in ML</em>. Journal of functional
programming, 3(4), pp.465-484.</p>
<p>Continuations:</p>
<ul>
<li>represents the 'rest of the computation'</li>
</ul>
<p>callcc:</p>
<ul>
<li>call with current continuation</li>
<li>Takes a function and calls it with current continuation.
<ul>
<li>DBT: What does calling a function with a continuation mean?</li>
</ul></li>
</ul>
<p>throw:</p>
<ul>
<li>Takes a continuation and a value.</li>
<li>Gives the value to that continuation.</li>
</ul>
<p>Milner-style soundness theorem: 'Well-typed programs cannot go
wrong'</p>
<hr />
<p>Oliveira, B.C. and Cook, W.R., <strong>2012</strong>, September.
<em>Functional programming with structured graphs</em>. In Proceedings
of the 17th ACM SIGPLAN international conference on Functional
programming (pp. 77-88).</p>
<hr />
<p>Pnueli, A. and Zaks, <strong>2006</strong>. A., <a
href="https://cs.nyu.edu/media/publications/TR2006-881.pdf">PSL Model
Checking and Run-time Verification via Testers Technical Report:
TR2006-881</a>. Notations used:</p>
<ul>
<li>P = set of atomic propositions</li>
<li>Σ = alphabet
<ul>
<li>ie, set of letters</li>
<li>Σ = 2ᴾ U {⊤, ⊥}</li>
</ul></li>
<li>v[i,j] =&gt; inclusive of both limits</li>
</ul>
<p>Boolean semantics (<code>⊫</code>):</p>
<ul>
<li>Defined over letters =&gt; finite</li>
<li><code>l ⊫ b</code>: letter <code>l</code> satisfies boolean formula
<code>b</code>
<ul>
<li><code>⊫ ⊆ Σ ⨯ 𝔹</code></li>
<li><code>∀b, ⊤ ⊫ l</code></li>
<li><code>∀b, ⊥ ⊯ l</code></li>
</ul></li>
</ul>
<p>∀(p ∈ P) (b b₁ b₂ ∈ 𝔹) then,</p>
<ol>
<li><code>l ⊫ p</code> iff <code>p ∈ l</code></li>
<li><code>l ⊫ ¬b</code> iff <code>l ⊯ b</code></li>
<li><code>l ⊫ true</code> , <code>l ⊯ false</code></li>
<li><code>l ⊫ b₁ ∧ b₂</code> iff <code>l ⊫ b₁</code> and
<code>l ⊫ b₂</code></li>
</ol>
<p>—</p>
<p>(Unclocked) SERE semantics (<code>⫢</code>):</p>
<ul>
<li>Defined over <em>finite</em> words from <code>Σ</code>.</li>
</ul>
<p>∀ (r r₁ r₂ : Unclocked SERE)</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>v ⫢ {r} ↔︎ v ⫢ r</td>
<td>just the bracket for grouping</td>
</tr>
<tr class="even">
<td>v ⫢ b ↔︎ │v│=1 ∧ v[0] ⊫ b</td>
<td></td>
</tr>
<tr class="odd">
<td>v ⫢ r₁;r₂ ↔︎</td>
<td></td>
</tr>
<tr class="even">
<td>v ⫢ r₁:r₂ ↔︎</td>
<td></td>
</tr>
<tr class="odd">
<td>v ⫢ r₁│r₂ ↔︎</td>
<td></td>
</tr>
<tr class="even">
<td>v ⫢ r₁ &amp;&amp; r₂ ↔︎</td>
<td></td>
</tr>
<tr class="odd">
<td>v ⫢ [*0] ↔︎ v = ε</td>
<td></td>
</tr>
</tbody>
</table>
<p>—</p>
<p>FL = Foundation language</p>
<p>FL Formula semantics (<code>⊨</code>):</p>
<ul>
<li>Defined over finite <em>or</em> infinite word</li>
</ul>
<p>—</p>
<blockquote>
<p>Theorem 1. For every SERE r of length n, there exists an associated
grammar G with the number of productions O(2n). If we restrict SERE’s to
the three traditional operators: concatenation ( ; ), union ( | ), and
Kleene closure ( [∗] ), the number of productions becomes linear in the
size of r.</p>
</blockquote>
<hr />
<p>Sheon Han, <strong>2022</strong>. <a
href="https://www.quantamagazine.org/computing-expert-says-programmers-need-more-math-20220517/"><em>How
to Write Software With Mathematical Perfection</em></a>. Quanta
Magazine</p>
<ul>
<li><p>An article about Leslie Lamport with an interview.</p></li>
<li><p><a
href="https://en.wikipedia.org/wiki/Lamport%27s_bakery_algorithm">Bakery
algorithm</a></p></li>
<li><p><a href="https://en.wikipedia.org/wiki/Byzantine_fault">Byzantine
generals problem</a></p>
<ul>
<li>In distributed systems.</li>
<li>'A Byzantine fault is any fault presenting different symptoms to
different observers.'</li>
</ul></li>
<li><p>1978 paper on causality</p>
<ul>
<li><a
href="https://dl.acm.org/doi/10.1145/359545.359563">https://dl.acm.org/doi/10.1145/359545.359563</a></li>
</ul></li>
<li><p>Logic locks</p>
<ul>
<li>aka Lamport locks.</li>
<li>A way to reason about concurrent systems.</li>
</ul></li>
<li><p>Paxos consensus algorithm</p>
<ul>
<li>The paper wasn't widely read at first.</li>
<li><a
href="https://dl.acm.org/doi/10.1145/279227.279229">https://dl.acm.org/doi/10.1145/279227.279229</a></li>
</ul></li>
<li><p><a href="https://lamport.azurewebsites.net/tla/tla.html">TLA+</a>
specification language</p>
<ul>
<li>'employs the precise language of mathematics to prevent bugs and
avoid design flaws'</li>
<li><a
href="https://www.youtube.com/channel/UCajiu4Cj_GHOX0if3Up-eRA">TLA+
video course by Lamport</a> is on youtube.</li>
<li>Lamport also had made <a
href="https://en.wikipedia.org/wiki/PlusCal">PlusCal</a>, a formal
specification language that looks more imperative.</li>
</ul></li>
</ul>
<blockquote>
<p>Lamport laments how programmers often cobble together a system before
writing a proper specification, whereas chefs would never cater a
banquet without first knowing that their recipes will work.</p>
</blockquote>
<blockquote>
<p>In the 1970s, when people were reasoning about programs, they were
proving properties of the program itself stated in terms of programming
languages. Then people realized that they should really be stating what
the program is supposed to accomplish first — the program’s
behaviors.</p>
</blockquote>
<blockquote>
<p>one practical method of writing these higher-level specifications for
concurrent systems was writing them as abstract algorithms. With TLA+, I
was able to express them <strong>mathematically in a completely rigorous
fashion</strong>. And everything clicked. What that involves is
basically not trying to write algorithms in a programming language: If
you really want to do things right, you need to <strong>write your
algorithm in the terms of mathematics</strong>.</p>
</blockquote>
<blockquote>
<p>The <strong>importance of thinking and writing before you
code</strong> needs to be taught in undergraduate computer science
courses</p>
</blockquote>
<blockquote>
<p>True, most of the code written by programmers across the world
doesn’t require very precise statements about what it’s supposed to do.
But there are things that are important and need to be correct. …
<strong>For the kind of application where precision is important, you
need to be very rigorous.</strong></p>
</blockquote>
<blockquote>
<p><strong>Model checking</strong> is a method for exhaustively testing
all executions of a small model of the system. It <strong>just shows the
correctness of the model, not of the algorithm</strong>. … In practice,
model checking checks all executions of a small instance of the
algorithm. And if you’re lucky, you can check large enough instances
that it gives you enough confidence in the algorithm. But the
<strong>proof can prove its correctness for a system of any size and for
any use of the algorithm</strong>.</p>
</blockquote>
<hr />
<p>Thompson, K., <strong>1968</strong>. <em>Programming techniques:
Regular expression search algorithm</em>. Communications of the ACM,
11(6), pp.419-422.</p>
<ul>
<li>'Simulate' NFA.</li>
<li>Subset construction?</li>
</ul>
<p>Operations:</p>
<ul>
<li><code>.</code>: concatenation. ie, sequential</li>
<li><code>*</code>: Kleene star</li>
</ul>
<table>
<tbody>
<tr class="odd">
<td>a(b│c)*d</td>
<td>Input</td>
</tr>
<tr class="even">
<td>a.(b│c)*.d</td>
<td>With explicit concat</td>
</tr>
<tr class="odd">
<td>abc│*.d.</td>
<td>Postfix form</td>
</tr>
</tbody>
</table>
<h1 id="section-3">2022</h1>
<p><a
href="https://dl.acm.org/doi/pdf/10.1145/1297666.1297670">Automata-Based
Assertion-Checker Synthesis of PSL Properties</a> - Marc Boulé and
Zeljko Zilic Runtime Verification for LTL and TLTL - Andreas Bauer,
Martin Leucker, Christian Schallhart</p>
<h2 id="dec">Dec</h2>
<p>Manna, Z. and Pnueli, A., <strong>1991</strong>. <em>Completing the
temporal picture</em>. Theoretical Computer Science, 83(1),
pp.97-130.</p>
<hr />
<p>Pnueli, A. and Arons, T., <strong>2003</strong>. <em>Tlpvs: A
pvs-based ltl verification system</em>. In Verification: Theory and
Practice (pp. 598-625). Springer, Berlin, Heidelberg.</p>
<p>tlpvs: <a
href="https://cs.nyu.edu/acsys/tlpvs/tlpvs.html">https://cs.nyu.edu/acsys/tlpvs/tlpvs.html</a></p>
<ul>
<li><p>strong and weak fairness</p></li>
<li><p>compassion, justice</p></li>
<li><p>Distributed rank rule</p></li>
</ul>
<p>—</p>
<blockquote>
<p>The advantage of using this system [TLPVS] over using a general
theorem prover is that the included rules and strategies <strong>free
the user from much of the drudge work</strong>.</p>
</blockquote>
<p>—</p>
<p>About using an existing theorem prover:</p>
<blockquote>
<p>In so doing we enable the user to beneﬁt from the abilities of a well
developed theorem prover, with a large community of users who
continuously develop and improve the prover’s power. Basing our system
on pvs, and making the theories available, makes it extremely ﬂexible.
When necessary users are able to modify or extend the framework to ﬁt
their own needs; they are not restricted by the existing set of proof
rules and strategies.</p>
</blockquote>
<p>—</p>
<p>ref: [4] (STeP)</p>
<ul>
<li>STeP: <a
href="http://i.stanford.edu/pub/cstr/reports/cs/tr/95/1562/CS-TR-95-1562.pdf">http://i.stanford.edu/pub/cstr/reports/cs/tr/95/1562/CS-TR-95-1562.pdf</a>
<ul>
<li><a
href="https://exhibits.stanford.edu/stanford-pubs/catalog/rx504kz0314">https://exhibits.stanford.edu/stanford-pubs/catalog/rx504kz0314</a></li>
</ul></li>
</ul>
<hr />
<p>Boulé, M. and Zilic, Z., <strong>2006</strong>, November.
<em>Efficient automata-based assertion-checker synthesis of PSL
properties</em>. In 2006 IEEE International High Level Design Validation
and Test Workshop (pp. 69-76). IEEE.</p>
<ul>
<li>Paired <a
href="https://en.wikipedia.org/wiki/Interconnect_(integrated_circuits)">interconnect</a>?</li>
<li>Conditional mode
<ul>
<li>A property must hold</li>
</ul></li>
<li>Obligation mode
<ul>
<li>A property must not fail</li>
</ul></li>
</ul>
<p>—</p>
<blockquote>
<p>PSL expressions will be implicitly clocked to the default clock,
specified with PSL's default <code>clock</code> directive.</p>
</blockquote>
<p>DBT: What's the <code>clock</code> directive?</p>
<p>—</p>
<blockquote>
<p>Some forms of properties are not suitable for simulation and can only
be evaluated by formal methods. The portion of PSL suitable for
simulation is referred to as the <strong>simple subset of
PSL</strong>.</p>
</blockquote>
<hr />
<p>Leucker, M. and Schallhart, C., <strong>2009</strong>. <em>A brief
account of runtime verification</em>. The journal of logic and algebraic
programming, 78(5), pp.293-303.</p>
<p>3 ways:</p>
<ul>
<li>Model checking</li>
<li>Theorem proving</li>
<li>Testing</li>
</ul>
<table>
<thead>
<tr class="header">
<th>MC</th>
<th>ITP</th>
<th>Testing</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Rigorous</td>
<td>Rigorous</td>
<td>Not rigorous</td>
</tr>
<tr class="even">
<td>Not scalable</td>
<td>Scalable</td>
<td>Scalable</td>
</tr>
<tr class="odd">
<td>Formal</td>
<td>Formal</td>
<td>Informal</td>
</tr>
<tr class="even">
<td>Automatic</td>
<td>Manual</td>
<td>Automatic</td>
</tr>
<tr class="odd">
<td>Ony finite syst</td>
<td>Infinite syst as well</td>
<td>Infinite syst as well</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>MC</th>
<th>RV</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Infinite trace examined</td>
<td>Finite trace examined</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Furthermore, model checking suffers from the so-called state
explosion problem, which terms the fact that analyzing all executions of
a system is typically been carried out by generating the whole state
space of the underlying system, which is often huge. Considering a
single run, on the other hand, does usually not yield any memory
problems, <em>provided that when monitoring online only a
<strong>finite</strong> history of the execution has to be
stored</em>.</p>
</blockquote>
<p>RV vs Testing:</p>
<ul>
<li>RV is similar to <em>oracle-based testing</em></li>
</ul>
<blockquote>
<p>Nevertheless, the implementation might behave slightly different than
predicted by the model. Runtime veriﬁcation may then be used to easily
check the actual execution of the system, to make sure that the
implementation really meets its correctness properties. <em>Thus,
runtime veriﬁcation may act as a partner to theorem proving and model
checking</em>.</p>
</blockquote>
<p>DBT: μ-calculus?</p>
<p>Ref: [43], [9]/[11]</p>
<hr />
<p>Hunt Jr, W.A., Kaufmann, M., Moore, J.S. and Slobodova, A., 2017.
Industrial hardware and software verification with ACL2. Philosophical
Transactions of the Royal Society A: Mathematical, Physical and
Engineering Sciences, 375(2104), p.20150399.</p>
<hr />
<ul>
<li>Cyrluk, D., Rajan, S., Shankar, N. and Srivas, M.K.,
<strong>1994</strong>, September. <em>Effective theorem proving for
hardware verification</em>. In International Conference on Theorem
Provers in Circuit Design (pp. 203-222). Springer, Berlin,
Heidelberg.</li>
</ul>
<blockquote>
<p>The attractiveness of using theorem provers for system design
verification lies in their generality</p>
</blockquote>
<p>DBT: How can Skolem constants simply acquire the place of a
(universally) quantified variable?</p>
<p>—</p>
<blockquote>
<p>The microprocessor verification problem is to show that the traces
induced by the implementation transition system are a subset of the
traces induced by the specification transition system, where subset has
to be carefully defined by use of an abstraction mapping.</p>
</blockquote>
<p>Kind of resonates with runtime verification..</p>
<p>—</p>
<ul>
<li>Ground temporal logic (GTL2)
<ul>
<li>DBT: Validity problem for GTL is Π¹₁ complete. What does Π¹₁
mean?</li>
<li>GTL is meant for helping with RTL design verification.</li>
</ul></li>
</ul>
<hr />
<ul>
<li>Berg, C., Jacobi, C. and Kroening, D., <strong>2001</strong>,
February. <em>Formal verification of a basic circuits library</em>. In
APPLIED INFORMATICS-PROCEEDINGS- (No. 2, pp. 252-255). UNKNOWN.</li>
</ul>
<hr />
<p>Schneider, K. and Kropf, T., <strong>1995</strong>. <em>Verifying
hardware correctness by combining theorem proving and model
checking</em>. Higher Order Logic Theorem Proving and Its Applications:
Short Presentations, 89, p.104.</p>
<ul>
<li>Data path dominated hardware designs vs Control dominated hardware
designs</li>
</ul>
<hr />
<p>Beyer, S., Jacobi, C., Kroening, D. and Leinenbach, D.,
<strong>2002</strong>. <em>Correct hardware by synthesis from PVS</em>.
Submitted for publication.</p>
<p>DBT: I wonder why this was so?<br />
</p>
<blockquote>
<p>While model checking is a good way to verify control dominated
designs, the verification of combinatorially complex designs such as
floating point units is currently beyond the scope of model-checkers</p>
</blockquote>
<hr />
<p>Shankar, N., <strong>1996</strong>, November. <a
href="https://www.cis.upenn.edu/group/verinet/references/Shankar96.ps.gz"><em>PVS:
Combining specification, proof checking, and model checking</em></a>. In
International Conference on Formal Methods in Computer-Aided Design (pp.
257-264). Springer, Berlin, Heidelberg.</p>
<ul>
<li>Model checking works (sort of automatically) when the state space is
small. But state explodes too quickly.</li>
<li>Theorem provers (at least used to) meant more 'manual' work.</li>
<li>Toy example involving 3-stage pipeline processor.</li>
<li>LTL model checking incorporated into PVS?</li>
<li><a
href="https://en.wikipedia.org/wiki/Modal_%CE%BC-calculus">mu-calculus</a>??:
<a
href="https://www.labri.fr/perso/igw/Papers/igw-mu.pdf">https://www.labri.fr/perso/igw/Papers/igw-mu.pdf</a>
<ul>
<li>Used in model checking.</li>
<li>Least and greatest fixpoints</li>
</ul></li>
<li>nu-calculus??</li>
</ul>
<p>—-</p>
<ul>
<li>Katz, G., Barrett, C., Dill, D.L., Julian, K. and Kochenderfer,
M.J., <strong>2017</strong>, July. <em>Reluplex: An efficient SMT solver
for verifying deep neural networks</em>. In International conference on
computer aided verification (pp. 97-117). Springer, Cham.</li>
</ul>
<hr />
<ul>
<li>Girard, J.Y., <strong>1987</strong>. <em>Linear logic</em>.
Theoretical computer science, 50(1), pp.1-101.
<ul>
<li>Intuitionistic logic can faithfully be translated into linear
logic.</li>
<li>Tarskian/phase semantics:</li>
</ul></li>
</ul>
<pre><code>| bilinear and     | Ⓧ | Multiplicatives |
| bilinear or      | ⅋ |                 |
| bilinear implies | ⊸ |                 |
|------------------+---+-----------------|
| linear or        | ⊕ | Additives       |
| linear and       | &amp; |                 |
|------------------+---+-----------------|
| □                | ! | Exponentials    |
| ◇                | ? |                 |
</code></pre>
<hr />
<ul>
<li>Coquand, T., <strong>2014</strong>. <a
href="http://www.cse.chalmers.se/~coquand/paperbourbaki.pdf"><em>Théorie
des types dépendants et axiome d’univalence</em></a>. Séminaire
Bourbaki, 66, p.1085.</li>
</ul>
<ul>
<li>Kaiser, J.O., Ziliani, B., Krebbers, R., Régis-Gianas, Y. and
Dreyer, D., <strong>2018</strong>. <em>Mtac2: typed tactics for backward
reasoning in Coq</em>. Proceedings of the ACM on Programming Languages,
2(ICFP), pp.1-31.
<ul>
<li>'Coq supports a range of built-in tactics, which are engineered
primarily to support backward reasoning.'</li>
<li>'Coq supports two tactic languages - OCaml and Ltac - that enable
users to roll their own tactics.'</li>
</ul></li>
<li>Havelund, K. and Rosu, G., <strong>2001</strong>, November.
<em>Monitoring programs using rewriting</em>. In Proceedings 16th Annual
International Conference on Automated Software Engineering (ASE 2001)
(pp. 135-143). IEEE.</li>
</ul>
<hr />
<p>Ishio, C. and Asai, K., <strong>2022</strong>, November. <em>Type
System for Four Delimited Control Operators</em>. In Proceedings of the
21st ACM SIGPLAN International Conference on Generative Programming:
Concepts and Experiences (pp. 45-58).</p>
<ul>
<li><a
href="https://github.com/chiaki-i/type4d/blob/main/code/4D.agda">https://github.com/chiaki-i/type4d/blob/main/code/4D.agda</a></li>
<li>Ways to allow programmer to work with continuations.
<ul>
<li>Control operators: <code>control / prompt</code>,
<code>shift / reset</code></li>
<li>Algebraic effect handlers</li>
</ul></li>
<li>shift: S</li>
<li>control: F</li>
<li>shift0: S0</li>
<li>control0: F0</li>
</ul>
<p>An example expression involving shift/reset. Shift is <code>S</code>
and reset is the <code>&lt;&gt;</code>.</p>
<pre><code>  &lt;(Sk. k (k 2)) + 3&gt; + 4
= &lt;k (k 2) [λx. &lt;x+3&gt; / k]&gt; + 4
= (λx. &lt;x + 3&gt;) ((λx. &lt;x + 3&gt;) 2) + 4
= [(λx. &lt;x + 3&gt;) 5] + 4
= 8 + 4
= 12
</code></pre>
<pre><code>  &lt;(Fk1. (2+k1 1)) + Fk2. (4+k2 3)&gt;
= &lt;(2+k1 1)[(λx. x + Fk2. (4+k2 3)) / k1]&gt;
= &lt;(2+(λx. x + Fk2. (4+k2 3)) 1)&gt;
= &lt;(2+ (1 + Fk2. (4+k2 3))&gt;
= &lt;(4+k2 3)[ (λx. 2 + (1 + x)) / k2 ]&gt;
= &lt;(4+(λx. 2 + (1 + x)) 3)&gt;
= &lt;(4+(2 + (1 + 3)))&gt;
= 10
</code></pre>
<pre><code>  &lt;&lt;(S0k1. S0k2. e) + 2&gt; + 3&gt;
= 
</code></pre>
<ul>
<li>Turns out there is a relation between the control operations and
effect handlers.
<ul>
<li><code>shift0</code> related to deep effect handlers</li>
<li><code>control0</code> related to shallow effect handlers</li>
</ul></li>
</ul>
<hr />
<ul>
<li><p>Levy, P.B., <strong>2022</strong>. <em>Call-by-push-value</em>.
ACM SIGLOG News, 9(2), pp.7-29.</p>
<ul>
<li>From at least 1999.</li>
<li>CBPV subsumes both call by value (CBV) and call by name (CBN) in
lambda calculus.</li>
<li>'Force' thunks or 'return'.</li>
</ul></li>
<li><p>Gordon, M., <strong>2000</strong>, May. <em>From LCF to HOL: a
short history</em>. In Proof, language, and interaction (pp.
169-186).</p></li>
<li><p>Gerth, R., Peled, D., Vardi, M.Y. and Wolper, P.,
<strong>1995</strong>, June. <em>Simple on-the-fly automatic
verification of linear temporal logic</em>. In International Conference
on Protocol Specification, Testing and Verification (pp. 3-18).
Springer, Boston, MA.</p></li>
<li><p>Lichter, M., <strong>2016</strong>. <em>Büchi Automata in
Coq</em>.: <a
href="https://www.ps.uni-saarland.de/~lichter/memo_buechi_automata.pdf">https://www.ps.uni-saarland.de/~lichter/memo_buechi_automata.pdf</a></p></li>
<li><p>Neumann, R., <strong>2014</strong>, July. <em>Using promela in a
fully verified executable LTL model checker</em>. In Working Conference
on Verified Software: Theories, Tools, and Experiments (pp. 105-114).
Springer, Cham.</p>
<ul>
<li>Promela is a modeling language.</li>
<li>This LTL implementation takes spec in the form of models in
Promela.</li>
</ul></li>
<li><p>Esparza, J., Lammich, P., Neumann, R., Nipkow, T., Schimpf, A.
and Smaus, J.G., <strong>2013</strong>, July. <em>A fully verified
executable LTL model checker</em>. In International Conference on
Computer Aided Verification (pp. 463-478). Springer, Berlin,
Heidelberg.</p>
<ul>
<li>LTL checker. Formally verified is Isabelle/HOL, using the
'Refinement framework'.</li>
<li>Output is in ML? So I guess Isabelle supports extraction?
<ul>
<li>'like in PVS and Coq'. So PVS as well?</li>
</ul></li>
<li>Refinement</li>
<li>B-method</li>
<li><a
href="https://www.isa-afp.org/entries/CAVA_LTL_Modelchecker.html#download-popup">https://www.isa-afp.org/entries/CAVA_LTL_Modelchecker.html#download-popup</a></li>
<li>DBT: Difference: generalized and normal Büchi automata?
<ul>
<li>Ordinary =&gt; only one accepting state?</li>
<li>Generalized =&gt; many accepting states, and each accepting states
got to be visited infinitely often?</li>
</ul></li>
</ul></li>
</ul>
<ul>
<li>Coupet-Grimal, S. and Jakubiec, L., <strong>1996</strong>, August.
<a
href="https://lim.univ-reunion.fr/staff/fred/Enseignement/Verif-M2/Articles/Coq-And-Hardware-Verification-Coupet-Grimal-Jakubiec-1996.pdf"><em>Coq
and hardware verification: A case study</em></a>. In International
Conference on Theorem Proving in Higher Order Logics (pp. 125-139).
Springer, Berlin, Heidelberg.
<ul>
<li>"A multiplier first introduced by M.Gordon in [13] has been proven
in [11], later extended by C. Paulin-Morhing in [23] to a more general
proof of this circuit, using a codification of streams in type theory as
infinite objects.[3] is a verification of a multiplier specified at the
bit vector level."</li>
</ul></li>
<li>Pollack, R., <strong>1998</strong>. <a
href="https://www.brics.dk/RS/97/18/BRICS-RS-97-18.pdf"><em>How to
believe a machine-checked proof</em></a>. Twenty Five Years of
Constructive Type Theory, 36, p.205.</li>
<li>Lamport, L., <strong>1994</strong>. <em>The temporal logic of
actions</em>. ACM Transactions on Programming Languages and Systems
(TOPLAS), 16(3), pp.872-923.</li>
<li>Ringer, T., Yazdani, N., Leo, J. and Grossman, D.,
<strong>2018</strong>, January. <em>Adapting proof automation to adapt
proofs</em>. In Proceedings of the 7th ACM SIGPLAN International
Conference on Certified Programs and Proofs (pp. 115-129).
<ul>
<li>DBT: Rippling [20]</li>
</ul></li>
<li>Ringer, T., Yazdani, N., Leo, J. and Grossman, D.,
<strong>2019</strong>. <a
href="https://drops.dagstuhl.de/opus/volltexte/2019/11081/pdf/LIPIcs-ITP-2019-26.pdf"><em>Ornaments
for proof reuse in Coq</em></a>. In 10th International Conference on
Interactive Theorem Proving (ITP 2019). Schloss Dagstuhl-Leibniz-Zentrum
fuer Informatik.
<ul>
<li>Ornament: Something like a relation between two inductive types
having the same structure.
<ul>
<li>'expresses relations between types that preserve inductive
structure, and which enable lifting of functions and proofs along these
relations'.</li>
</ul></li>
<li>Eg: <code>list A ≃ Σ (n:nat). vector A n</code>
<ul>
<li>where <code>Σ</code> indicates dependent type.</li>
</ul></li>
<li>Dependently typed vectors are apparently not pleasant to work with
even for experienced people.
<ul>
<li><a
href="https://sympa.inria.fr/sympa/arc/coq-club/2017-12/msg00079.html">https://sympa.inria.fr/sympa/arc/coq-club/2017-12/msg00079.html</a></li>
<li><a
href="https://sympa.inria.fr/sympa/arc/coq-club/2017-01/msg00099.html">https://sympa.inria.fr/sympa/arc/coq-club/2017-01/msg00099.html</a></li>
</ul></li>
</ul></li>
<li>Meijer, E. and Drayton, P., <strong>2004</strong>, October. <a
href="https://www.ics.uci.edu/~lopes/teaching/inf212W12/readings/rdl04meijer.pdf"><em>Static
typing where possible, dynamic typing when needed: The end of the cold
war between programming languages</em></a>. OOPSLA.</li>
<li>Vitousek, M.M., Kent, A.M., Siek, J.G. and Baker, J.,
<strong>2014</strong>, October. <em>Design and evaluation of gradual
typing for Python</em>. In Proceedings of the 10th ACM Symposium on
Dynamic languages (pp. 45-56).</li>
<li>Siek, J. and Taha, W., <strong>2007</strong>, July. <em>Gradual
typing for objects</em>. In European Conference on Object-Oriented
Programming (pp. 2-27). Springer, Berlin, Heidelberg.</li>
</ul>
<h2 id="nov">Nov</h2>
<ul>
<li>Harrison, J., 2008. Formal proof—theory and practice. <a
href="http://web.archive.org/web/20220121055340/http://www.ams.org/notices/200811/200811-full-issue.pdf">Notices
of the AMS</a>, 55(11), pp.1395-1406.
<ul>
<li>DBT: Dedekind cuts</li>
<li>DBT: Zermelo or von Neumann hierarchy: <a
href="https://en.wikipedia.org/wiki/Von_Neumann_universe">https://en.wikipedia.org/wiki/Von_Neumann_universe</a></li>
</ul></li>
<li>Pédrot, P.M., <strong>2019</strong>. <a
href="https://www.pédrot.fr/articles/coqpl2019.pdf"><em>Ltac2: tactical
warfare</em></a>. In The Fifth International Workshop on Coq for
Programming Languages, CoqPL (pp. 13-19).
<ul>
<li>Ltac2 has algebraic types
<ul>
<li>Ltac1 has data structures like lists, but dynamically typed.</li>
</ul></li>
<li>DBT: Prenex polymorphism
<ul>
<li><a
href="https://en.wikipedia.org/wiki/Prenex_normal_form">https://en.wikipedia.org/wiki/Prenex_normal_form</a></li>
</ul></li>
<li>DBT: Remind me what <em>thunk</em> is…</li>
<li>DBT: Why is Ltac1's <code>Tactic Notation</code> infamous?</li>
</ul></li>
<li>Leroy, X., <strong>2000</strong>. <a
href="https://xavierleroy.org/publi/modular-modules-jfp.pdf"><em>A
modular module system</em></a>. Journal of Functional Programming,
10(3), pp.269-303.</li>
<li><input type="checkbox" disabled="" /><a
href="https://dspace.mit.edu/bitstream/handle/1721.1/64850/23882173-MIT.pdf">Lambda-calculus
models of programming languages</a> - James Morris (PhD thesis)</li>
<li>Ringer, T., Palmskog, K., Sergey, I., Gligoric, M. and Tatlock, Z.,
<strong>2019</strong>. <a
href="https://arxiv.org/abs/2003.06458"><em>QED at large: A survey of
engineering of formally verified software</em></a>. Foundations and
Trends in Programming Languages, 5(2-3), pp.102-281.
<ul>
<li>Proof repair</li>
<li>Machine learning proof search, proof evolution, etc</li>
</ul></li>
<li><input type="checkbox" disabled="" />LTL Satisfiability Checking
Revisited</li>
<li><input type="checkbox" disabled="" /><a
href="https://www.cs.rice.edu/~vardi/papers/spin07rj.pdf">LTL
Satisfiability Checking</a> (2007)<ul>
<li>Kristin Y. Rozier, NASA Ames Research Center, Moffett Field,
California</li>
<li>Moshe Y. Vardi, Rice University, Houston, Texas</li>
</ul></li>
</ul>
<h2 id="oct">Oct</h2>
<ul>
<li>Xia, L.Y., Zakowski, Y., He, P., Hur, C.K., Malecha, G., Pierce,
B.C. and Zdancewic, S., <strong>2019</strong>. <a
href="https://arxiv.org/pdf/1906.00046.pdf"><em>Interaction trees:
representing recursive and impure programs in Coq</em></a>. arXiv
preprint arXiv:1906.00046.
<ul>
<li><a
href="https://github.com/DeepSpec/InteractionTrees">https://github.com/DeepSpec/InteractionTrees</a></li>
</ul></li>
</ul>
<pre class="coq"><code>CoInductive ITree 
(* Halt. Leaf *)
| Ret: ITree

(* Visible stuff. One child node *)
| Tau: ITree -&gt; ITree

(* Internal stuff. Two children node *)
| Vis:
</code></pre>
<p>Continuation tree. Free monad</p>
<p>A reminder of monadic laws:</p>
<pre><code>x &lt;- ret v ;; k x ≡ k v
x &lt;- t ;; ret x ≡ t
(x &lt;- (y &lt;- s ;; t) ;; u) ≡ (y &lt;- s ;; x &lt;- t ;; u)
</code></pre>
<ul>
<li>itree for computation that can interact with an external
environment.</li>
<li>Computations may produce events, to which env may respond.</li>
<li>Can model finite and infinite computation!</li>
</ul>
<p><code>itree E R</code></p>
<ul>
<li><code>R</code>: type of value computed by the computation</li>
</ul>
<p><code>E: Type -&gt; Type</code> is the type of external
interactions.</p>
<pre class="coq"><code>CoInductive itree (E:Type -&gt; Type) (R:Type) : Type :=
| Ret (r:R) : itree E R                    (* Done. Result is [r] *)
| Tau (t:itree E R) : itree E R            (* Keep going with [t] *)
| Vis: forall {A:Type} (e:E A),
    (A -&gt; itree E R) -&gt; itree E R
  (* Got a result, gave back an answer of type [A]
     from where the continuation resumes computation *)
</code></pre>
<ul>
<li><code>Tau</code> can model jump instructions.
<ul>
<li>Internal step. No visible event. Keeps going as another itree.</li>
</ul></li>
<li><code>Vis</code>: Continuation in this constructor is a coq function
=&gt; more power and flexibility.
<ul>
<li>Allows for branching. Makes tree structure possible if needed.</li>
</ul></li>
</ul>
<p>—</p>
<p>Example:</p>
<pre class="coq"><code>(*            answer type
                 ^
                 |
                 |        *)
Inductive IO : Type -&gt; Type :=
| Input: IO nat
| Output: nat -&gt; IO unit.
</code></pre>
<p><code>Input</code>: expects nothing as input, but wants
<code>nat</code> as output <code>Output</code>: expects <code>nat</code>
as input, but wants nothing (<code>unit</code>) as output</p>
<p>A program that keeps reading input and echoing it:</p>
<pre class="coq"><code>CoFixpoint echo : itree IO void :=
  Vis Input (fun x =&gt;
    Vis (Output x) (fun _ =&gt; echo)).
</code></pre>
<p><code>void</code> is notation from <code>Empty_set</code> from <a
href="https://coq.inria.fr/library/Coq.Sets.Ensembles.html">Coq.Ensembles</a>.
It has no constructor, making it impossible for us to make a value of
that type.</p>
<p>Another example: An infinite loop:</p>
<pre class="coq"><code>CoFixpoint spin: itree IO void := Tau spin.
(* The value of [E], which is in this case [IO], is irrelevant in this I guess.. *)
</code></pre>
<p>The above two examples never halt. Here's an example that halts when
input is 9:</p>
<pre class="coq"><code>CoFixpoint kill9: itree IO unit :=
  Vis Input (fun x:nat =&gt;
    if Nat.eqb x 9 then (Ret tt)
    else kill9).
</code></pre>
<p>This program doesn't give out 'output'. If we wanted some kind of
output as well, I suppose we can do:</p>
<pre class="coq"><code>CoFixpoint kill9&#39;: itree IO unit :=
  Vis Input (fun x:nat =&gt;
    if Nat.eqb x 9 then (Ret tt)
    else (Vis (Output x) (fun _ =&gt; kill9&#39;)).
</code></pre>
<p>Notations:</p>
<ul>
<li><code>A ⤳ B</code> is <code>forall X:Type, A X -&gt; B X</code></li>
</ul>
<pre class="coq"><code>(* Empty type. Like [False], but in [Type]. *)
Inductive void : Type :=.

(* Interactive tree type *)
CoInductive itree {E:Type -&gt; Type} {R:Type}: Type :=
| Ret: R -&gt; itree
| Tau: itree -&gt; itree
| Vis: forall {A:Type},
    E A -&gt; (A -&gt; itree) -&gt; itree.
Arguments itree : clear implicits.

(* Env interaction type *)
(*           Answer/response type
                |                    *)
Inductive IO: Type -&gt; Type :=
| Input: IO nat
| Output: nat -&gt; IO unit.

(* Idle infinite loop *)
CoFixpoint spin: itree IO void := Tau spin.

(* Echo infinite loop *)
CoFixpoint echo: itree IO void :=
  Vis Input (fun n:nat =&gt;
    Vis (Output n) (fun _:unit =&gt; echo)).

(* Halt when input is 9 while spinning otherwise *)
CoFixpoint kill9: itree IO unit :=
  Vis Input (fun n:nat =&gt;
    if Nat.eqb n 9 then Ret tt
    else kill9).

(* Halt when input is 9 while echoing otherwise *)
CoFixpoint kill9out: itree IO unit :=
  Vis Input (fun n:nat =&gt;
    if Nat.eqb n 9 then Ret tt
</code></pre>
<p>These are just the interaction tree. We define handler function to
give semantics to itree values.</p>
<p>Effects =&gt; external events E. A monad.</p>
<p>— Todo:</p>
<ul>
<li>How would I run kill9out and echo?
<ul>
<li>How to supply input and obtain output?</li>
</ul></li>
<li>How to use itree for evaluation of our asm?</li>
</ul>
<p>Doubts:</p>
<ul>
<li>Positive vs negative coinductive types</li>
</ul>
<hr />
<ul>
<li>Boulé, M. and Zilic, Z., <strong>2008</strong>. <em>Automata-based
assertion-checker synthesis of PSL properties</em>. ACM Transactions on
Design Automation of Electronic Systems (TODAES), 13(1), pp.1-21.</li>
</ul>
<div class="sourceCode" id="cb47"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Sere</span> <span class="dt">A</span> <span class="op">:=</span> <span class="dt">Cat</span> <span class="dt">A</span> (<span class="dt">Sere</span> <span class="dt">A</span>)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">Alt</span> (<span class="dt">Sere</span> <span class="dt">A</span>) (<span class="dt">Sere</span> <span class="dt">A</span>)</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">And</span> (<span class="dt">Sere</span> <span class="dt">A</span>) (<span class="dt">Sere</span> <span class="dt">A</span>)</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">Fuse</span> (<span class="dt">Sere</span> <span class="dt">A</span>) (<span class="dt">Sere</span> <span class="dt">A</span>)</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">Star</span> (<span class="dt">Sere</span> <span class="dt">A</span>)</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span> <span class="dt">Property</span> <span class="op">*</span>)</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a><span class="dt">Ppty</span> <span class="dt">A</span> <span class="op">:=</span> <span class="dt">Bool</span> (<span class="dt">A</span><span class="ot">-&gt;</span>𝔹)</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">Neg</span> (<span class="dt">A</span><span class="ot">-&gt;</span>𝔹)</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">Re</span> (<span class="dt">Sere</span> <span class="dt">A</span>)</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">Abort</span> (<span class="dt">Ppty</span> <span class="dt">A</span>) (<span class="dt">A</span><span class="ot">-&gt;</span>𝔹)</span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">PAnd</span> (<span class="dt">Ppty</span> <span class="dt">A</span>) (<span class="dt">Ppty</span> <span class="dt">A</span>)</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">Impl</span> (<span class="dt">Sere</span> <span class="dt">A</span>) (<span class="dt">Ppty</span> <span class="dt">A</span>)</span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">Iff</span> (<span class="dt">A</span><span class="ot">-&gt;</span>𝔹) (<span class="dt">A</span><span class="ot">-&gt;</span>𝔹)</span></code></pre></div>
<p><code>s!</code>: strong sequence. Should definitely be matched before
the end of execution.</p>
<ul>
<li>but then again, that's if the execution is to terminate, I
suppose..</li>
</ul>
<h1 id="section-4">2021</h1>
<ul>
<li>The MetaCoq project</li>
</ul>
<pre><code>                Quote
     +-----------------------------+
     |                             |
     ∧                             ∨
     |                             |
concrete synatx             reified syntax
     |                             |
     ∧                             ∨
     |                             |
     +-----------------------------+
              Unquote
</code></pre>
<hr />
<ul>
<li>Sozeau, M., Boulier, S., Forster, Y., Tabareau, N. and Winterhalter,
T., <strong>2019</strong>. <em>Coq coq correct! verification of type
checking and erasure for coq, in coq</em>. Proceedings of the ACM on
Programming Languages, 4(POPL), pp.1-28.</li>
<li>Pit-Claudel, C. and Bourgeat, T., <strong>2021</strong>. <a
href="https://people.csail.mit.edu/bthom/coqpl21.pdf"><em>An experience
report on writing usable DSLs in Coq</em></a>. CoqPL'21:
TheSeventhInternationalWorkshoponCoqforPL.</li>
</ul>
</div>
</body>
</html>
