<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>GCC: Incompatibilities between C and C++</title>
  <style>
    body {
      max-width: 38rem;
      padding: 2rem;
      margin: auto;
      background-color: #FAF0E6;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
  </style>

</head>
<body>


<div id="header">
<a href="https://ju-sh.github.io">Home</a>
 | 
<a href="https://ju-sh.github.io/blog/index.html">Blog</a>
 | 
<a href="https://ju-sh.github.io/wiki/index.html">Wiki</a>
 | 
<a href="https://ju-sh.github.io/about.html">About</a>
</div>

<header id="title-block-header">
<h1 class="title">GCC: Incompatibilities between C and C++</h1>
</header>

<ul>
    <li>Date created: 01-May-2017</li>
      <li>Last updated: 22-Dec-2021</li>
  </ul>

<div>
  <p>
    Tags: / 
    <code>
      <a href="https://ju-sh.github.io/blog/pages/tags/c cpp.html">c cpp</a>
    </code> /
  <p>
</div>


<div id="description">
About features that work differently in C and C++ for GCC compilers..
</div>

<div id="content-container">
<p><!--UPDATED: 25-Jun-2021--> <sub><sup><a href="../misc/old-blog.html">From my old blog</a>.</sup></sub></p>
<p><!-- http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf: final draft of C11 --></p>
<hr />
<h2 id="works-in-c-but-not-c">Works in C but not C++</h2>
<h3 id="constant-variable-initialisation">Constant variable initialisation</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>{</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="dt">const</span> <span class="dt">int</span> a;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="co">//const int a=10;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>The above code will compile successfully as a C program, but will give the following error when run as a C++ program.</p>
<pre><code>main.c:4:19: error: uninitialized const ‘a’ [-fpermissive]
        const int a;
            ^
</code></pre>
<p>This is because in C, we need not give the value of the constant variable while declaring it (though it seems that we won't be able to give a value to it later as well since it is a constant. If that's the case, one wonders what's the point of making such declarations in the first place).</p>
<p>But in C++, a constant variable needs to be initialized when it is declared.</p>
<h3 id="typedef-names">Typedef names</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="kw">typedef</span> <span class="dt">int</span> n;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="kw">struct</span> n</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>{</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    n a; <span class="co">//Here, n is the typedef-ed name of int</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    <span class="kw">struct</span> n* link; <span class="co">//Here, n is the structure.</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>};</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>{</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">%d&quot;</span>, <span class="kw">sizeof</span>(n)); <span class="co">//Prints 4 = sizeof(int) in C</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">%d&quot;</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> n)); <span class="co">//Prints 8 = sizeof(int) + sizeof(struct n) in C</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a>}</span></code></pre></div>
<p>This will run all right as C.</p>
<p>And gives this error in C++:</p>
<pre><code>main.c:5:12: error: using typedef-name ‘n’ after ‘struct’
    struct n
        ^
main.c:3:17: note: ‘n’ has a previous declaration here
    typedef int n;
            ^
</code></pre>
<p>C++ treats the name of struct, union, enum, etc (the type tag) as implicit typedef names.</p>
<p>But in C, we MUST use the struct keyword before the name of the structure when declaring its variables.</p>
<p>The above program, when treated as C++, first <code>int</code> is given an alias name of 'n'. Then we define a structure of the same name 'n'. Since C++ considers the structure name alone ('n') implicitly a typedef name of that structure, we get an error like "using typedef-name 'n' after struct".</p>
<p>But in C, no such implicit typedef-ing is done and an alias name same as that of a structure (or union or enum) can be made using typedef keyword.</p>
<p>So in C, while declaring a structure variable, the type of the variable is the name of the structure preceded by the struct keyword. Eg: <code>struct n variable;</code></p>
<p>In C++, the <code>struct</code> is optional (but there are exceptions: "a notorious example where even C++ needs the struct keyword is POSIX' stat system call").</p>
<p>Eg:</p>
<pre><code>n variable;
</code></pre>
<p>But</p>
<pre><code>n variable;
struct n variable;
</code></pre>
<p>is also valid.</p>
<h3 id="void-pointer-assignments"><code>void</code> pointer assignments</h3>
<p>In C, a pointer of type <code>void</code> is automatically cast into the target pointer type when assigned to a pointer of any other type. So no explicit type-casting is required.</p>
<p>Whereas in C++, an explicit type-cast is required when a <code>void</code> pointer is assigned to pointer of another type.</p>
<p>The <code>malloc()</code> function returns a <code>void</code> pointer if it was successful. So,</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="dt">int</span> *a = malloc( <span class="kw">sizeof</span>(<span class="dt">int</span>) );</span></code></pre></div>
<p>would be all right in C.</p>
<p>But not in C++, it would give an error like:</p>
<pre><code>/home/famubu/main.c: In function ‘int main()’:
/home/famubu/main.c:5:20: error: invalid conversion from ‘void*’ to ‘int*’
    int *a = malloc(sizeof(int));
        ~~~~~~^~~~~~~~~~~~~
</code></pre>
<p>We can add an explicit type cast to fix this.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>/home/famubu/main.c: In function ‘int main()’:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="dt">int</span> *a = (<span class="dt">int</span> *) malloc( <span class="kw">sizeof</span>(<span class="dt">int</span>) );</span></code></pre></div>
<p>Still, both C and C++ allow a pointer of any data type to be assigned to a pointer of type <code>void</code>.</p>
<p>Eg:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="dt">int</span> a = <span class="dv">3</span>;</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="dt">int</span> *int_ptr = &amp;a;</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="dt">void</span> *void_ptr = int_ptr;  <span class="co">// Legal in both C and C++</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>int_ptr = void_ptr;        <span class="co">// Legal in C but not in C++</span></span></code></pre></div>
<h3 id="kr-style-function-definitions">K&amp;R style function definitions</h3>
<p>Before C came to standardised,</p>
<p>This is known as the K&amp;R style function definitions (or non-prototyped function definitions).</p>
<p>This syntax was used in the first edition of the K&amp;R C book.</p>
<p>Though this syntax is now considered obsolete, gcc (and clang) would still accept it when used in a C program. But not for C++ programs.</p>
<p>Consider this program:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>{</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>    fn(<span class="dv">3</span>,<span class="dv">2</span>);</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>}</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="dt">void</span> fn(a, b)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a><span class="dt">int</span> a;  <span class="co">// This is optional</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a><span class="dt">int</span> b;  <span class="co">// This is optional</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>{</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>    printf(<span class="st">&quot;a: %d, b: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, a, b);</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>}</span></code></pre></div>
<p>It works fine as a C program but gives an error when compiled as C++.</p>
<p>I had heard of the old-style syntax but didn't know it would still work until reading an article. As the teacher who taught me C said, "gcc compiler is backward compatible with K&amp;R C".</p>
<p>C++ doesn't allow this style and the function definition must be prototyped.</p>
<p>The above function may be re-written as:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="dt">void</span> fn(<span class="dt">int</span> a, <span class="dt">int</span> b)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>{</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>    printf(<span class="st">&quot;a: %d, b: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, a, b);</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>}</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>{</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>    fn(<span class="dv">3</span>,<span class="dv">2</span>);</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>}</span></code></pre></div>
<h3 id="crossing-an-initialisation">Crossing an initialisation</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>{</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    <span class="cf">switch</span>(<span class="dv">1</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>    {</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>    <span class="dt">int</span> i = <span class="dv">3</span>;</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>    <span class="cf">case</span> <span class="dv">1</span>:</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">%d&quot;</span>, i);</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>    }</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>This is valid C but invalid C++.</p>
<p>When compiled as C, it would print some garbage value that was in the variable 'i'.</p>
<p>In C++, it wouldn't compile and would give an error like</p>
<pre><code>error: crosses initialisation of &#39;int i&#39;
</code></pre>
<p>This is because in C++, a <code>goto</code> or <code>switch</code> cannot cross a variable initialisation.</p>
<p>Hence the following is also valid C but invalid C++:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>{</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a><span class="cf">goto</span> label;</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>    <span class="dt">int</span> i=<span class="dv">3</span>;</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>    label:</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>When <code>goto label;</code> is encountered, the <code>int i=3;</code> which is an initialisation is skipped. GCC C++ compiler prohibits crossing an initialisation.</p>
<h3 id="function-arguments">Function arguments</h3>
<p>In C, if fn() is a function, the difference between the following functions</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="dt">int</span> fn1()</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="dt">int</span> fn2(<span class="dt">void</span>)</span></code></pre></div>
<p>is that the first function takes an unspecified number of arguments. Meaning, it can receive any number of arguments (including zero arguments). But it seems that there is no way to access these arguments in this case.</p>
<p>The second function takes no arguments. So it would be an error to pass arguments to it.</p>
<p>ie,</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>fn1();</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>fn1(<span class="dv">2</span>);</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>fn1(<span class="dv">2</span>, <span class="fl">2.0</span>, <span class="ch">&#39;c&#39;</span>);</span></code></pre></div>
<p>are all valid function invocations but</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>fn2(<span class="dv">2</span>);</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>fn(<span class="dv">2</span>, <span class="fl">2.0</span>, <span class="ch">&#39;c&#39;</span>);</span></code></pre></div>
<p>are both wrong.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>fn2();</span></code></pre></div>
<p>is the correct way of invoking the second function.</p>
<p>But in C++,</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="dt">int</span> fn();</span></code></pre></div>
<p>means that that the function takes no arguments</p>
<p>ie, it is same as</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="dt">int</span> fn(<span class="dt">void</span>);</span></code></pre></div>
<p>Therefore, if we try to call function fn() with arguments, it would generate error like "too many arguments".</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="dt">void</span> fn()</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>{</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">Hello world&quot;</span>);</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>}</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>{</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>    fn(<span class="dv">2</span>);</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>Hence, this program would work fine in C but not C++.</p>
<h3 id="enumerator-value">Enumerator value</h3>
<p>In C, enum seems to have been almost meaningless as a variable of type enum could be assigned any value without it being an error as in the following program.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>{</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>    <span class="kw">enum</span> Dir { UP, DOWN};</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>    <span class="kw">enum</span> Dir d = <span class="dv">1</span>; <span class="co">//No error in C. Error in C++</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>But C++ enum is more meaningful. Only the values specified in the declaration can be assigned. Following would work in C++:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>{</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>    <span class="kw">enum</span> Dir { UP, DOWN};</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>    <span class="kw">enum</span> Dir d = (<span class="kw">enum</span> Dir) <span class="dv">1</span>; <span class="co">//Valid C and C++</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>}</span></code></pre></div>
<h3 id="string-overflow">String 'overflow'</h3>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>{</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>    <span class="dt">char</span> arr[<span class="dv">5</span>]=<span class="st">&quot;Hello&quot;</span>;</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>Here, the size of the character array arr is only 5 but the string with which it is initialised needs 6 bytes (one extra for NUL character). So if we try to print arr, the output is likely to have some characters after the 'Hello' but still C compiler will not complain about it.</p>
<p>In C++, on the other hand, the program wouldn't even compile. Would get an error like:</p>
<pre><code>error: initialiser string for array of chars is too long [-fpermissive]
</code></pre>
<h3 id="anonymous-structures">Anonymous structures</h3>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>{</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a>    <span class="kw">union</span> u</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a>    {</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a>    <span class="dt">int</span> a;</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a>    <span class="kw">struct</span> <span class="co">//anonymous structure. Anonymous structure and nameless structure ARE DIFFERENT!</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true"></a>    {</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true"></a>        <span class="dt">char</span> b[<span class="dv">4</span>];</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true"></a>    };</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true"></a>    };</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true"></a>}</span></code></pre></div>
<p>Anonymous structures are valid in C but not C++. The above program works in C but not C++.</p>
<h3 id="compound-literals">Compound literals</h3>
<p>Compound literals are "literals having types other than primitive types (eg: array types)". In C, it is possible to specify compound literals in constant expressions.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a><span class="dt">int</span> foo(<span class="dt">int</span> *a)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>{</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a>    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">%d&quot;</span>, a[<span class="dv">2</span>]);</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>}</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a>{</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a>    foo( (<span class="dt">int</span> []) {<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">4</span>} ); <span class="co">// An array literal</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>But C++ does not allow this and would give an error like "taking address of temporary array".</p>
<h2 id="works-in-c-but-not-c-1">Works in C++ but not C</h2>
<h3 id="default-arguments">Default arguments</h3>
<p>C++ functions can have default arguments but not C functions.</p>
<p>Hence following is valid C++ but invalid C.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a><span class="dt">int</span> fn(<span class="dt">int</span> a, <span class="dt">int</span> b=<span class="dv">4</span>) <span class="co">//default argument</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>{</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a>}</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a>{</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true"></a>    fn(<span class="dv">3</span>);</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true"></a>}</span></code></pre></div>
<h3 id="variadic-function-prototype">Variadic function prototype</h3>
<p>Prototype of variadic functions in C must have at least one specified argument followed by a comma and an ellipsis to denote undefined number of arguments like this:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="dt">void</span> fn(<span class="dt">int</span> n, …);</span></code></pre></div>
<p>In C++, the prototype of a variadic function need not have even a single specified argument. Just the ellipsis would do.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="dt">void</span> fn(…);</span></code></pre></div>
<p>Hence,</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a><span class="dt">int</span> fn(...);</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>{</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>Gives error like "ISO C requires a named argument before …" when compiled as a C program but works fine as a C++ program.</p>
<p>Also, the comma is important in C function prototypes like:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="dt">void</span> fn(<span class="dt">int</span> n, …); <span class="co">//Valid C, valid C++</span></span></code></pre></div>
<p>But in C++, the comma is optional:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="dt">void</span> fn(<span class="dt">int</span> n …); <span class="co">//Invalid C, valid C++</span></span></code></pre></div>
<p>The second case would give the following error when compiled as C:</p>
<pre><code>error: expected &#39;;&#39;, &#39;,&#39; or &#39;)&#39; before &#39;...&#39; token
</code></pre>
<h3 id="bool-keyword"><code>bool</code> keyword</h3>
<p>The <code>bool</code> keyword is not present in C89. But was added in C99 in the form of <code>_Bool</code> with <code>bool</code> as a macro for <code>_Bool</code>.</p>
<p>But in C++, <code>bool</code> is a built-in data type.</p>
<p>Consider the following</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a><span class="co">//#include&lt;stdbool.h&gt;  //If this is included, will compile as C program as well</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>{</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a>    <span class="dt">bool</span> b;</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>This program will compile as a C++ program but not as C.</p>
<p>To use bool of C99, we may include the stdbool header file and then it will compile as C as well.</p>
<h3 id="constructor-and-destructor-for-a-structure">'Constructor' and 'destructor' for a structure</h3>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a><span class="co">//Works in C++</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a><span class="kw">struct</span> n</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true"></a>{</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true"></a>    n()</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true"></a>    {</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true"></a>    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">Hello&quot;</span>);</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true"></a>    }</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true"></a>    ~n()</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true"></a>    {</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true"></a>    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">Bye&quot;</span>);</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true"></a>    }</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true"></a>};</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true"></a>{</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true"></a>    <span class="kw">struct</span> n a;</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true"></a>    n b;</span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true"></a>}</span></code></pre></div>
<p>'Constructor' and 'destructor' for a structure is valid C++ but invalid C. These 'constructors' &amp; 'destructors' behave like that of a class. The 'constructor' is automatically called whenever a structure variable of this structure is created and the 'destructor' is automatically invoked whenever a structure variable of this structure runs out of scope.</p>
<p>For example, in the above program, two structure variables of type 'n' are declared. Hence, the 'constructor' gets called twice and <code>"Hello"</code> is printed two times as output due to the 'constructor' and <code>"Bye"</code> is printed twice because of the 'destructor'.</p>
<p>As per <a href="https://en.wikipedia.org/wiki/C%2B%2B_classes">Wikipedia:C++ classes</a> (accessed around 2017. Contents might have changed now),</p>
<blockquote>
<p>In C++, a structure is a class defined with the struct keyword. Its members and base classes are public by default. A class defined with class keyword has private members and base classes by default. This is the only difference between structs and classes in C++.</p>
</blockquote>
<p>Eg: the following structure and class are functionally equivalent in C++.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a><span class="kw">struct</span> name</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a>{</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a>    <span class="dt">char</span> c;</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true"></a>    <span class="dt">int</span> a;</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true"></a>};</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true"></a></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true"></a>class name</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true"></a>{</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true"></a>public:</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true"></a>    <span class="dt">char</span> c;</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true"></a>    <span class="dt">int</span> a;</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true"></a>};</span></code></pre></div>
<p>structs in C++ can even have member functions.</p>
<h2 id="different-output-in-c-and-c">Different output in C and C++</h2>
<h3 id="result-of-a-boolean-expression">Result of a Boolean expression</h3>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a>{</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true"></a>    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">%d&quot;</span>, <span class="kw">sizeof</span>(<span class="dv">1</span>==<span class="dv">1</span>));</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>This would print <code>4</code> as a C program and <code>1</code> as a C++ program.</p>
<p><code>1==1</code> is a Boolean expression. C doesn't have a separate data type to store Boolean values (though C99 added this with <code>_Bool</code>. The header file <code>stdbool.h</code> also provides <code>bool</code> as an alias for <code>_Bool</code> along with macros <code>true</code> and <code>false</code>. Any assignment other than <code>0</code> or <code>1</code> to a variable of type <code>_Bool</code> is stored as <code>1</code>).</p>
<p>Hence the resultant value, which is <code>1</code>, is considered to be an integer. In gcc, the size of <code>int</code> is 4 bytes and hence the output.</p>
<p>But C++ has a separate Boolean data type, the result of a Boolean expression is a value of type bool. The size of bool is 1 byte. So the output of the above program when run as a C++ program is 1.</p>
<h3 id="structure-with-no-members">Structure with no members</h3>
<p>It seems that syntax of C forbids an empty structure. But gcc allows this as an extension.</p>
<p>As <a href="https://gcc.gnu.org/onlinedocs/gcc/Empty-Structures.html">gcc docs</a> says,</p>
<p>&gt; GCC permits a C structure with no members. The structure <code>struct empty { };</code> has size zero. In C++, empty structures are part of the language. G++ treats empty structures as if they had a single member of type char."</p>
<p>So in gcc at least, the following program gives output <code>0</code> in C and <code>1</code> in C++.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a><span class="kw">struct</span> n</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true"></a>{</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true"></a>};</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true"></a>{</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true"></a>    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">%d&quot;</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> n)); <span class="co">// Prints 0 in C and 1 in C++</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true"></a>}</span></code></pre></div>
<h3 id="size-of-a-character-literal">Size of a character literal</h3>
<p>This I got from <a href="https://computingforbeginners.blogspot.com/search/label/C">this blog</a>.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true"></a>{</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true"></a>    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">%d&quot;</span>, <span class="kw">sizeof</span>(<span class="ch">&#39;a&#39;</span>));</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>This prints <code>4</code> in C as <code>'a'</code> is treated as an <code>int</code> whereas in C++ the output is <code>1</code> since it is treated as a <code>char</code>.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf">Final draft of C11</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf</a></a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Empty-Structures.html"><a href="https://gcc.gnu.org/onlinedocs/gcc/Empty-Structures.html">https://gcc.gnu.org/onlinedocs/gcc/Empty-Structures.html</a></a></li>
<li><a href="https://computingforbeginners.blogspot.com/2014/06/yet-another-difference-between-c-and-c.html"><a href="https://computingforbeginners.blogspot.com/2014/06/yet-another-difference-between-c-and-c.html">https://computingforbeginners.blogspot.com/2014/06/yet-another-difference-between-c-and-c.html</a></a></li>
<li><a href="https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B">Wikipedia: Compatibility of C and C++</a></li>
<li><a href="https://en.wikipedia.org/wiki/C%2B%2B_classes">Wikipedia: C++ classes</a></li>
</ul>
</div>
</body>
</html>
