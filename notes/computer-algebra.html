<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Computational algebra and number theory</title>
  <style>
    body {
      max-width: 38rem;
      padding: 2rem;
      margin: auto;
      background-color: #FAF0E6;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
  </style>

</head>
<body>


<div id="header">
<a href="https://ju-sh.github.io">Home</a>
 | 
<a href="https://ju-sh.github.io/blog/index.html">Blog</a>
 | 
<a href="https://ju-sh.github.io/wiki/index.html">Wiki</a>
 | 
<a href="https://ju-sh.github.io/about.html">About</a>
</div>

<header id="title-block-header">
<h1 class="title">Computational algebra and number theory</h1>
</header>

<ul>
    </ul>




<hr/>

<div id="content-container">
<p>Notes that I had made from the <em>Computational algebra and number
theory</em> course given by <a
href="https://piyush-kurur.github.io/teaching/Computational-number-theory-and-algebra/index.html">Piyush
sir</a>.</p>
<p>All mistakes my own. Corrections very much appreciated.</p>
<p>Moreover, there's still a lot of formatting to fix.</p>
<hr />
<h1 id="extra">Extra</h1>
<h2 id="references">References</h2>
<ul>
<li><p><em>Modern Computer Algebra</em> (3e) - Joachim von zur Gathen,
Jürgen Gerhard</p></li>
<li><p><em>Ideals, varieties, and algorithms</em> - David Cox, John
Little, Daniel O'Shea</p></li>
<li><p><a
href="https://www.math.colostate.edu/~pries/467/Judson12.pdf"><em>Abstract
algebra: Theory and applications</em></a> - Thomas W. Judson, Stephen
F.</p></li>
<li><p><em>Finite fields and applications</em> - Gary L. Mullen, Carl
Mummert</p></li>
<li><p><em>Handbook of finite fields</em> - Gary L. Mullen, Daniel
Panario</p></li>
<li><p><em>Contemporary abstract algebra</em> (7e) - Joseph A.
Gallian</p></li>
<li><p><em>Fundamentals of error-correcting codes</em> - W. Cary
Huffman, Vera Pless</p></li>
<li><p><em>Error control coding: fundamentals and applications</em> -
Daniel J. Costello, Shu Lin</p></li>
</ul>
<h2 id="supplementary-notes">Supplementary notes</h2>
<h3 id="inverse-of-a-matrix">Inverse of a matrix</h3>
<ul>
<li>A.A⁻¹ = A⁻¹.A = I</li>
</ul>
<p>Inorder for inverse to exist:</p>
<ul>
<li>A must be square matrix.</li>
<li>|A| ≠ 0</li>
</ul>
<p>Eg:</p>
<pre><code>⎡3 4⎤ 
⎣6 8⎦
</code></pre>
<p>doesn't have inverse as its determinant is zero.</p>
<p>Matrices with determinant zero are known as <strong>singular
matrices</strong>.</p>
<h3 id="tip-inverse-of-a-2x2-matrix">Tip: Inverse of a 2x2 matrix</h3>
<p>If A is:</p>
<pre><code>⎡a b⎤
⎣c d⎦ 
</code></pre>
<p>A⁻¹, if it exists, is</p>
<pre><code> 1  ⎡ d -b⎤
─── ⎢     ⎥ 
|A| ⎣-c  a⎦
</code></pre>
<p>Ref: <a
href="https://www.mathsisfun.com/algebra/matrix-inverse.html">https://www.mathsisfun.com/algebra/matrix-inverse.html</a></p>
<h3 id="inverse-of-a-matrix-1">Inverse of a matrix</h3>
<p>Flow: Minors -&gt; Cofactors -&gt; Adjugate -&gt; Inverse</p>
<p>Ref: <a
href="https://www.mathsisfun.com/algebra/matrix-inverse-minors-cofactors-adjugate.html">https://www.mathsisfun.com/algebra/matrix-inverse-minors-cofactors-adjugate.html</a></p>
<h3 id="third-root-of-unity">Third root of unity</h3>
<p>ie, cube root of 1: <code>∛1</code></p>
<p>Has three roots:</p>
<ul>
<li>1 (real)</li>
<li>ω (imaginary)</li>
<li>ω² (imaginary)</li>
</ul>
<p>where</p>
<pre><code>      -1 + i√3  
ω  = ──────────
         2      


      -1 - i√3  
ω² = ──────────
         2      
</code></pre>
<p>Derivation:</p>
<pre><code>              a  = ∛1
=&gt;            a³ = 1
=&gt;          a³-1 = 0
=&gt; (a-1)(a²+a+1) = 0

Finding roots of the second term:
   a²+a+1 = 0

     -1 ± √(1²-4*1*1)  
a = ──────────────────
          2*1*1     


     -1 ± √(-3)  
  = ────────────
          2         


     -1 ± i√3  
  = ────────────
          2         
</code></pre>
<p><a
href="https://www.cuemath.com/algebra/cube-root-of-unity/">https://www.cuemath.com/algebra/cube-root-of-unity/</a></p>
<h3 id="left-and-right-cosets">Left and right cosets</h3>
<p>Normal subgroup =&gt; left and right cosets are the same.</p>
<h3 id="trivial-group">Trivial group</h3>
<ul>
<li>aka zero group</li>
<li>Since all trivial groups are essentially the same (ie, isomorphic),
we say <em>the</em> trivial group.</li>
</ul>
<h3 id="zero-ring">Zero ring</h3>
<ul>
<li>The trivial ring.</li>
<li>Has only one element.</li>
</ul>
<h3 id="a-hierarchy">A 'hierarchy'</h3>
<p>From <a
href="https://en.wikipedia.org/wiki/Unique_factorization_domain">here</a>:</p>
<p>rings ⊃ integral domains ⊃ <a
href="https://en.wikipedia.org/wiki/Unique_factorization_domain">UFD</a>
⊃ <a href="https://en.wikipedia.org/wiki/Principal_ideal_domain">PID</a>
⊃ Euclidean domain ⊃ fields</p>
<h3 id="gcd-of-polynomials"><span class="todo TODO">TODO</span> gcd of
polynomials</h3>
<pre><code>gcd(x²+7x+6, x²-5x-6)

x²+7x+6  =  (x²-5x-6)(1) + (12x)
x²-5x-6  =  (12x)(
</code></pre>
<pre><code>gcd(x⁵+2x⁴-x²+1, x⁴-1)
gcd(x^5+2*x^4-x^2+1, x^4-1)

x⁵+2x⁴-x²+1 =        (x⁴-1)(x+2) + (-x²-x+3)
       x⁴-1 = (-x²-x+3)(-x²-x-4) + (7x+11)
    -x²-x+3 = (-7x+6)
</code></pre>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>sage: R.<span class="op">&lt;</span>x<span class="op">&gt;=</span>PolynomialRing(ZZ)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>sage: gcd(x<span class="op">^</span><span class="dv">2</span><span class="op">+</span><span class="dv">7</span><span class="op">*</span>x<span class="op">+</span><span class="dv">6</span>, x<span class="op">^</span><span class="dv">2</span><span class="op">-</span><span class="dv">5</span><span class="op">*</span>x<span class="op">-</span><span class="dv">6</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>sage: gcd(x<span class="op">^</span><span class="dv">5</span><span class="op">+</span><span class="dv">2</span><span class="op">*</span>x<span class="op">^</span><span class="dv">4</span><span class="op">-</span>x<span class="op">^</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span>, x<span class="op">^</span><span class="dv">4</span><span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span></code></pre></div>
<p>DBT:</p>
<ul>
<li>Which polynomial is greater?</li>
</ul>
<h3 id="semiring">Semiring</h3>
<p>Like rings. But the additive operation needn't have inverse.</p>
<ul>
<li>Semiring + additive inverses =&gt; ring</li>
<li>Ring + multiplicative inverses =&gt; field</li>
</ul>
<h3 id="semigroup">Semigroup</h3>
<p>Like groups, but doesn't need additive inverses or identity.</p>
<p>ie, Semigroup + inverses + identity = group</p>
<h1 id="dbts">DBTS</h1>
<ul>
<li>Whats does characterisation of all possible finite fields mean?
<ul>
<li>We are categorizing them?</li>
</ul></li>
</ul>
<h1 id="finite-field-lemmas">Finite field lemmas</h1>
<h2 id="lemma-1">Lemma 1</h2>
<p>Given:</p>
<ul>
<li><code>F</code> is a finite field</li>
<li><code>K</code> is a subfield of <code>F</code></li>
<li><code>|K| = q</code></li>
</ul>
<p>Then:</p>
<ul>
<li><code>F</code> can be viewed as a vector space of dimension
<code>m</code> over <code>K</code></li>
<li><code>|F| = qᵐ</code></li>
</ul>
<h2 id="lemma-2">Lemma 2</h2>
<p>Given:</p>
<ul>
<li>F is a finite field</li>
<li>p = char(F)</li>
<li><code>m</code> is degree of F over prime subfield of F</li>
</ul>
<p>Then:</p>
<ul>
<li>|F| = pᵐ</li>
</ul>
<h2 id="more">More</h2>
<ul>
<li>Integers modulo n do not form a field if n is not a prime number.
(They will be rings though).</li>
<li>Fq is a field =&gt; q = pᵐ for some prime p.
<ul>
<li>And Fq is a vector space of dimension m over Fₚ</li>
</ul></li>
<li>∀α∈Fq, pα=0</li>
<li>GF(q) is unique upto isomorphism.</li>
<li>A commutative ring with unity + All non-zero elements have
multiplicative inverse =&gt; field</li>
</ul>
<h2 id="informal-1">Informal 1</h2>
<ul>
<li>Intersection of any set of subfields of a finite field F is itself a
subfield of F.</li>
<li>Order of a finite field is always a prime or a positive power of a
prime.</li>
<li>For each such power of prime pᵏ, there exists exactly one (upto
isomorphism) finite field.
<ul>
<li>Usually written as Fpᵏ</li>
</ul></li>
<li>Any two fields with the same cardinality are isomorphic to each
other.</li>
<li>A field is a unique factorization domain (UFD). ie, every element in
the field has a unique factorization.</li>
<li>Ring of polynomials over any finite field is a UFD.</li>
</ul>
<h1 id="frobenius-map">Frobenius map</h1>
<p>α: GF(p) → GF(pⁿ)</p>
<p>—</p>
<p>We can say that:</p>
<ul>
<li>if: p∉{0,p}</li>
<li>then: pCi is divisible by p</li>
</ul>
<pre><code>          p!
pCi = ───────────
       (p-i)! i!


       p.(p-1).(p-i+1)
    = ────────────────
             i!
</code></pre>
<p>and since i&lt;p, <code>i!</code> has no factor of
<code>p</code>.</p>
<p>∴ <code>p | pCi</code>.</p>
<p>—</p>
<p>Binomial theorem tells us that:</p>
<pre><code>           p
(a + b)ᵖ = Σ  pCᵢ.aⁱ.bᵖ⁻ⁱ
          i=0

Since all multiples of p become 0 in Fₚ,

(a + b)ᵖ = aᵖ + bᵖ              
</code></pre>
<p>Frobenius map is an automorphim (ie, isomorphic endomorphism) in
Fₚ.</p>
<p>—</p>
<p>Field automorphisms (ie, the set of functions from a field to
itself), form a group under function composition.</p>
<p>σ: Fₚ → Fₚ</p>
<ul>
<li>σ(a+b) = σ(a) + σ(b)</li>
<li>σ(a⋅b) = σ(a)⋅σ(b)</li>
</ul>
<p>Frobenius map is the only automorphism possible within a field??</p>
<p>σ(a) = aᵖ</p>
<p>aka Frobenius automorphism.</p>
<h1 id="repeated-squaring">Repeated squaring</h1>
<p>Given:</p>
<ul>
<li>polynomail <code>f</code> of degree <code>n</code></li>
</ul>
<p>Find:</p>
<ul>
<li><code>Xᴹ mod f</code> in <code>O(n.logM)ᶜ</code> some constant
<code>c</code></li>
</ul>
<p>If M is a power of 2,</p>
<ol>
<li>Start with X² and then keep squaring it (ie, X⁴, X⁸, etc) till some
<code>Xᵏ</code> for some <code>k&gt;M</code>.</li>
<li>Do <code>Xᵏ mod f</code>
<ul>
<li>This brings the power of <code>X</code> to less than or equal to
<code>n-1</code>.</li>
</ul></li>
<li>'Rinse and repeat' all these steps logM times.</li>
</ol>
<p>If M is not a power of 2, we can use binary representation of M.</p>
<p>A use of repeated squaring: We can do distinct degree factorization
of polynomials.</p>
<h1 id="formal-derivative">Formal derivative</h1>
<p><em>Looks</em> pretty much like the 'normal derivative'..</p>
<ul>
<li>An operation on the elements of a polynomial ring</li>
<li>But doesn't depend on the notion of limit. <a
href="https://en.wikipedia.org/wiki/Formal_derivative">ʷ</a></li>
</ul>
<p>Eg:</p>
<ul>
<li>f(X) = X²ᵖ - 3Xᵖ + 5
<ul>
<li>f'(X) = 2p.X²ᵖ⁻¹ - 3pXᵖ⁻¹</li>
</ul></li>
<li>f(X) = a0 + a1x + … + anxⁿ ∈ Fₚ[X], then
<ul>
<li>f'(X) = a1 + 2a2x + …. + xn.an.xⁿ⁻¹ ∈ Fₚ[X]</li>
</ul></li>
</ul>
<p>Some properties:</p>
<ul>
<li>(f+g)'(X) = f'(X) + g'(X)</li>
<li>(fg)'(X) = f(X).g'(X) + g(X).f'(X)</li>
<li>(f(X)ᵐ)' = m.f(X)ᵐ⁻¹.f'(X)</li>
</ul>
<p>Another property:</p>
<pre><code>If

f(x)=f₁(x)ᵃ¹.f₂(x)ᵃ²....fₙ(x)ᵃⁿ

where a1,..,an are positive integers and the fᵢ(x) are distinct and irreducible over Fₚ, then

       f(x)
──────────────────  =  f₁(x).f₂(x)....fₙ(x)
 gcd(f(x), f&#39;(x))
</code></pre>
<p>This property means that if f(x) and f'(x) are co-prime, f(x) has no
repeated irreducible factors (ie, square-free??)</p>
<p>Also, xⁿ-1 has no repeated irreducible roots over GF(p) only if n and
p are relatively prime.</p>
<h1 id="cyclotomic-polynomail">Cyclotomic polynomail</h1>
<p>Polynomials of the form <code>Xʳ-1</code></p>
<p>Roots are r-th roots of unity.</p>
<ul>
<li>which over ℚ are e<sup>(2πi/r)</sup>, where r∈[0,n)</li>
</ul>
<h1 id="roots-of-unity">Roots of unity</h1>
<ul>
<li>i-th root of unity is ζᵢ</li>
<li>Roots unity forms a group under multiplication.
<ul>
<li>ζᵢ and ζⱼ are roots unity =&gt; ζᵢζⱼ is also a root of unity</li>
</ul></li>
<li>An r-th root of unity ζ is r-th <strong>primitive root of
unity</strong> if ζ is a generator for the group of roots of unity.</li>
</ul>
<h1 id="sage">Sage</h1>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># https://doc.sagemath.org/html/en/reference/number_fields/sage/rings/number_field/number_field_ideal.html</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>sage: K.<span class="op">&lt;</span>a<span class="op">&gt;</span> <span class="op">=</span> NumberField(x<span class="op">^</span><span class="dv">2</span><span class="op">-</span><span class="dv">5</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>sage: K</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>Number Field <span class="kw">in</span> a <span class="cf">with</span> defining polynomial x<span class="op">^</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">5</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>sage: <span class="bu">type</span>(K)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span><span class="kw">class</span> <span class="st">&#39;sage.rings.number_field.number_field.NumberField_quadratic_with_category&#39;</span><span class="op">&gt;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>sage: <span class="bu">type</span>(a)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span><span class="kw">class</span> <span class="st">&#39;sage.rings.number_field.number_field_element_quadratic.NumberFieldElement_quadratic_sqrt&#39;</span><span class="op">&gt;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="co"># https://doc.sagemath.org/pdf/en/reference/rings/rings.pdf</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 𝔽{5⁴}/𝔽{5²}</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>sage: GF(<span class="dv">5</span><span class="op">^</span><span class="dv">4</span>).over(GF(<span class="dv">5</span><span class="op">^</span><span class="dv">2</span>))</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>Field <span class="kw">in</span> z4 <span class="cf">with</span> defining polynomial x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> (<span class="dv">4</span><span class="op">*</span>z2 <span class="op">+</span> <span class="dv">3</span>)<span class="op">*</span>x <span class="op">+</span> z2 over its base</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<h1 id="more-1">More</h1>
<p>Elements of (ring of) Integers are uniquely factorizable. But not all
rings have this property.</p>
<p>Eg: In the polynomial ring with ℤ₈ coefficients,</p>
<p><code>X²-1</code> can be factorized in more than one way:</p>
<ul>
<li><code>(X+1)(X-1)</code></li>
<li><code>(X+3)(X-3)</code> (∵ 9 ≡ 0 mod 8)</li>
<li><code>(X+5)(X-5)</code> (∵ 25 ≡ 0 mod 8)</li>
<li><code>(X+7)(X-7)</code> (∵ 49 ≡ 0 mod 8)</li>
</ul>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>sage: z8x <span class="op">=</span> z8[x]</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>sage: z8x</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>Univariate Polynomial Ring <span class="kw">in</span> x over Ring of integers modulo <span class="dv">8</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>sage: aaa <span class="op">=</span> x<span class="op">^</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>sage: aaa.factor()</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>(x <span class="op">+</span> <span class="dv">1</span>)<span class="op">*</span>(x <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>But, of course, ℤ₈ is not an integral domain.</p>
<p>(∵ 4∈ℤ₈ and 2∈ℤ₈, 4⋅2 = 0. Yet 4≠0 and 2≠0.)</p>
<h1 id="ℝx">ℝ[X]</h1>
<p>Means <em>all</em> polynomials with ℝ coefficients. That means
<em>any</em> degree.</p>
<p>For example, all of the following are elements in ℝ[X]:</p>
<ul>
<li>X²-1</li>
<li>X¹⁵+X⁶-3</li>
</ul>
<h1 id="quiz-1">Quiz-1</h1>
<h2
id="factorize-the-polynomial-x³-1-over-the-finite-field-ℤ7ℤ">Factorize
the polynomial X³-1 over the finite field ℤ/7ℤ</h2>
<p>ℤ/7ℤ is a field with 7 elements.</p>
<p>ie, ℤ/7ℤ ≃ GF(7)</p>
<p>f = X³-1 f' = 3X²</p>
<p>gcd(f, f') =</p>
<hr />
<p>ℤ/7ℤ = {0,1,2,3,4,5,6}</p>
<p>Substitute each of these elements in X³-1 and see if it ends up being
0.</p>
<ul>
<li>0: -1</li>
<li>1: 0 ✓</li>
<li>2: 7=0 ✓</li>
<li>3: 8=1</li>
<li>4: 63=0 ✓</li>
<li>5: 5</li>
<li>6: 216=6</li>
</ul>
<p>So roots are: {1,2,4}</p>
<h1 id="thu"><span class="done DONE">DONE</span> [2023-01-19 Thu]</h1>
<p>Euclid's algorithm only gives the gcd.</p>
<pre><code>gcd(a,0) = a
gcd(a,b) = gcd(b, a mod b)
</code></pre>
<p>where remainders are kept but quotients are merely discarded.</p>
<p>Extended Euclid's algorithms finds Bezout's coefficients x and y in
addition to the gcd such that</p>
<pre><code>xa + yb = gcd(a, b)
</code></pre>
<h2 id="extended-euclids-algorithm">Extended Euclid's algorithm</h2>
<p>Aim:</p>
<ul>
<li>Given: a,b ∈ ℕ</li>
<li>Find: gcd(a,b)</li>
</ul>
<p>Solution:</p>
<ul>
<li>a₀ = a</li>
<li>a₁ = b</li>
<li>Compute <code>aᵢ₊₂ = aᵢ % aᵢ₊₁</code> till 0.</li>
<li>Value just before 0 is gcd.</li>
</ul>
<p><code>log n</code> steps. ie, input size (as number of bits needed to
represent n) halves at every step.</p>
<p>Proof involves 2 cases:</p>
<ul>
<li>aᵢ₊₁ ≤ ½.aᵢ</li>
<li>aᵢ₊₁ &gt; ½.aᵢ</li>
</ul>
<p>in each case we got to prove that</p>
<ul>
<li>aᵢ ≤ ½.aᵢ₊₁</li>
</ul>
<p>The algorithm needs at most 2.logn <code>%</code> operations. TODO:
<em>Comment</em>?</p>
<p>An example from <a
href="https://www.math.cmu.edu/~bkell/21110-2010s/extended-euclidean.html">here</a>
done in sage:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>sage: a,b <span class="op">=</span> <span class="dv">1398</span>,<span class="dv">324</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>sage: g,s,r <span class="op">=</span> xgcd(a,b)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>sage: g,s,r</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>(<span class="dv">6</span>, <span class="op">-</span><span class="dv">19</span>, <span class="dv">82</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>sage: s<span class="op">*</span>a <span class="op">+</span> r<span class="op">*</span>b</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>sage: s<span class="op">*</span>a <span class="op">+</span> r<span class="op">*</span>b <span class="op">==</span> g</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="va">True</span></span></code></pre></div>
<h2 id="a-theorem">A theorem</h2>
<p>Given:</p>
<ul>
<li>a,b ∈ ℤ</li>
<li>d = gcd(a,b)</li>
</ul>
<p>To prove:</p>
<ul>
<li>∃x,y ∈ ℤ such that <code>xa + yb = d</code></li>
</ul>
<p>Let's see an algorithm to calculate <code>x</code> and
<code>y</code>.</p>
<hr />
<p>Recall Euclid's algorithm:</p>
<ul>
<li>a₀ = a</li>
<li>a₁ = b</li>
<li>aᵢ₊₂ = aᵢ % aᵢ₊₁</li>
</ul>
<p>Let qᵢ be the quotient upon aᵢ/aᵢ₊₁. Then,</p>
<pre><code>   aᵢ₊₂ = aᵢ % aᵢ₊₁
=&gt;   aᵢ = qᵢ.aᵢ₊₁ % aᵢ₊₂
</code></pre>
<p>ie, in matrix form:</p>
<pre><code>⎡aᵢ  ⎤ = ⎡qᵢ  1⎤ * ⎡aᵢ₊₁⎤
⎣aᵢ₊₁⎦ = ⎣1   0⎦   ⎣aᵢ₊₂⎦

         |     |
         └──┬──┘
            ↓   
Let this be Qᵢ
</code></pre>
<p>determinant(Qᵢ) is 1 ≠ 0.<br />
∴ Invertible.</p>
<p>Inverse would be:</p>
<pre><code>⎡ 0   -1⎤
⎣-1   qᵢ⎦ 
</code></pre>
<p>which is also an ℤ matrix.</p>
<p>Coming back:</p>
<pre><code>⎡aᵢ  ⎤  =  ⎡qᵢ 1⎤ * ⎡aᵢ₊₁⎤         -------- (B)
⎣aᵢ₊₁⎦  =  ⎣1  0⎦   ⎣aᵢ₊₂⎦
</code></pre>
<p>I guess what we are really interested in is the first row of
result.<br />
∵ that would give</p>
<pre><code>⎡aᵢ  ⎤  =  ⎡qᵢ 1⎤ * ⎡aᵢ₊₁⎤
⎣aᵢ₊₁⎦  =  ⎣1  0⎦   ⎣aᵢ₊₂⎦
</code></pre>
<p>Anyway, using the earlier formula (B),</p>
<pre><code>⎡a⎤  =  ⎡a₀⎤
⎣b⎦     ⎣a1⎦


     = Q₀ * ⎡a1⎤
            ⎣a2⎦


     = Q₀.Q₁ * ⎡a2⎤
               ⎣a3⎦

     ....
     ....

     = Q₀.Q₁..Qᵣ₋₁ * ⎡aᵣ  ⎤
                     ⎣aᵣ₊₁⎦
</code></pre>
<p>Adjust <code>r</code> such that:</p>
<ul>
<li>aᵣ is gcd(a,b), which is what we want</li>
<li>aᵣ₊₁ is 0.</li>
</ul>
<p>ie,</p>
<pre><code>⎡a⎤   = Q₀.Q₁ .. Qᵣ₋₁ * ⎡aᵣ  ⎤
⎣b⎦                     ⎣aᵣ₊₁⎦

would become

⎡a⎤   = Q₀.Q₁ .. Qᵣ₋₁ * ⎡d⎤
⎣b⎦                     ⎣0⎦

where d = gcd(a,b)
</code></pre>
<p>Multiplying both sides by appropriate inverses,</p>
<pre><code>⎡ d ⎤ = Q₀⁻¹.Q₁⁻¹ .. Qᵣ₋₁⁻¹ * ⎡ a ⎤
⎣ 0 ⎦                         ⎣ b ⎦
</code></pre>
<p>All the inverses are ℤ 2x2 matrices.</p>
<p>∴ its product will also be an ℤ 2x2 matrix. Let it be
<code>Q</code>.</p>
<pre><code>Q₀⁻¹.Q₁⁻¹ .. Qᵣ₋₁⁻¹ = Q = ⎡q11  q12⎤
                          ⎣q21  q22⎦
</code></pre>
<p>in which case we would have</p>
<ul>
<li>q11 = x</li>
<li>q12 = y</li>
</ul>
<p>ie,</p>
<pre><code>Q = ⎡x    y  ⎤
    ⎣q21  q22⎦
</code></pre>
<p>All the <code>Qᵢ</code> matrices ∈ SL₂(ℤ).</p>
<ul>
<li>SL₂(ℤ) is the set of all 2x2 ℤ matrices whose determinant is 1.</li>
</ul>
<p>TODO: How can we be sure about that?</p>
<p>A joke made by our instructor:</p>
<blockquote>
<p>Mathematicians don't care about signs (because it just[?] changes
with order?)<br />
Computer scientists don't care about constants (think big-O)</p>
</blockquote>
<hr />
<p>We are interested in the lower bound of the computation needed to
calculate x and y (the <a
href="https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity">Bezout's
coefficients</a>).<br />
Since x and y can be found from Q, the problem reduces to finding lower
bound on calculation of Q.</p>
<pre><code>     i
Pᵢ = Π  Qᵣ₋ₖ
    k=0
</code></pre>
<p>Λᵢ biggest entry in Pᵢ</p>
<pre><code>Pi₊₁ = Pi . Qᵣ₋₁-k
</code></pre>
<p>Λ maximum possible entry among all Qᵢ Λ ≥ a₀</p>
<pre><code>Λᵢ₊₁ ≤ 2.Λᵢ.Λ
</code></pre>
<p>Then,</p>
<pre><code>    Λᵢ ≤  2.Λᵢ₋₁.Λ
=&gt;        2.[2Λᵢ₋₂.Λ.Λ]
          4.[Λᵢ₋₂.Λ²]
         2².[Λᵢ₋₂.Λ²]
         ...
         ...
         2ᵏ[Λᵢ₋ₖ.Λᵏ]
</code></pre>
<p>Taking log₂,</p>
<pre><code>Λᵣ ≤ 2ʳ.Λʳ.Λ
     r + r.logΛ  ≤   

     r + r.logΛ + logΛ



loga + loga*loga
=&gt; 𝑂(log²a)
</code></pre>
<p>Polynomial in logn</p>
<p>Size here =&gt; number of bits required to represent it.</p>
<p>Efficient algorithm =&gt; P Number of steps required by algorithms
shouldn't blow up. Should remain small number of steps.</p>
<hr />
<p>What can we say about relation between x and y?</p>
<p><strong>Whatever you say, make sure you can prove it.</strong></p>
<p>x and y are called Bezout's coefficients.</p>
<hr />
<p>Bezout identity.</p>
<h1 id="tue"><span class="done DONE">DONE</span> [2023-01-24 Tue]</h1>
<p>We had seen that Euclid's gcd(a,b) algo takes 𝑂(log |a|²) bit
operations.</p>
<p>Extended Euclid's algorithms tells us that: xa + yb = gcd(a,b)</p>
<p>This runs in polynomial time as well: 𝑂(log a) DBT: Comment?</p>
<p>x and y should be small:</p>
<ul>
<li>size(x) = log x = 𝑂(polynomial in log|a|)</li>
<li>size(y) = log y = 𝑂(polynomial in log|a|)</li>
</ul>
<p>size =&gt; number of bits needed to represent the number.</p>
<pre><code>⎡aᵢ  ⎤  =  ⎡qᵢ 1⎤ * ⎡aᵢ₊₁⎤
⎣aᵢ₊₁⎦  =  ⎣1  0⎦   ⎣aᵢ₊₂⎦
           |    |
           +----+
             |
            Qi
</code></pre>
<table>
<tbody>
<tr class="odd">
<td>Qi</td>
<td>= -1</td>
</tr>
</tbody>
</table>
<p>∴ Qi is invertible with ℤ-coefficients (ie, an ℤ-matrix).</p>
<pre><code>Qi⁻¹ = adj Qi
       ──────
        |Qi|


⎡ 0  -1⎤
⎣-1  qᵢ⎦

Anyway,

⎡a⎤   = Q₀.Q₁ .. Qᵣ₋₁ * ⎡d⎤
⎣b⎦                     ⎣0⎦

where d = gcd(a,b)

So,

⎡a⎤ .Q₀⁻¹.Q₁⁻¹ .. Qᵣ₋₁⁻¹ = ⎡d⎤
⎣b⎦                        ⎣0⎦


Q is:

 ⎡q11  q12⎤
 ⎣q21  q22⎦

where q11=x, q12=y
</code></pre>
<p>We need to have a bound on all the sizes of all the intermediate
values as well.</p>
<p>It should be small enough, sizewise. 𝑂(log a)?? At most a. In the
case of matrix, size of <em>each element</em> in it.</p>
<h2 id="rings">Rings</h2>
<p>Ring is an abelian group under <code>+</code> with an additional
binary operation called multiplication <code>·</code> such that<a
href="http://www.math.uchicago.edu/~may/VIGRE/VIGRE2010/REUPapers/Gallagher.pdf">²</a>:</p>
<ul>
<li>Closure under multiplication</li>
<li>Associativity for multiplication</li>
<li>Multiplicative identity</li>
<li>Multiplication distributes over addition</li>
</ul>
<p>ie,</p>
<ul>
<li><code>a,b ∈ G</code> means <code>a·b ∈ A</code></li>
<li><code>a·(b·c) = (a·b)·c</code></li>
<li><code>∃1 ∈ G</code> such that
<code>∀a ∈ G, a·1 = 1·a = a</code></li>
<li><code>a·(b+c) = (a·b)+(a·c)</code> and
<code>(a·b)+c = (a·c)+(b·c)</code></li>
</ul>
<p>(Abelian group =&gt; group whose operation is commutative as
well.)</p>
<ul>
<li>(R,+,0): commutative group</li>
<li>(R,⋅,1): commutative monoid</li>
</ul>
<p>Multiplicative inverse of x =&gt; x⋅i=1 Additive inverse of x =&gt;
x⋅i=0</p>
<p>Eg: A ring on ℤ:</p>
<pre><code>(ℤ, +, ·, 0, 1)
</code></pre>
<p>This is a ring-with-1 (ie, ring with (multiplicative) identity).</p>
<p>Rings without identity requirement are sometimes called
<strong>rng</strong> (ie, rings without the 'i').</p>
<pre><code>rng ⊂ ring ⊂ commutative ring
</code></pre>
<p>—</p>
<p><strong>Unity</strong> / <strong>identity</strong>:</p>
<ul>
<li>An element i∈R where i≠0 is a unity of R if
<ul>
<li>∀x∈R, i⋅x = x⋅i = x</li>
</ul></li>
</ul>
<p><strong>unit</strong>:</p>
<ul>
<li>An element a∈R, where a≠0, is a unit of R if there exists an element
a⁻¹∈R such that a⋅a⁻¹ = a⁻¹⋅a = 1</li>
<li>Fun fact: In a field, every element is a unit. Because every element
in a field is invertible.</li>
</ul>
<p>A field is a commutative division ring.</p>
<p>—</p>
<p>If G is a ring, then:</p>
<ol>
<li>(G,+,0) is a group</li>
<li>(G,⋅,1) is a monoid
<ul>
<li>ie, group without inverse element requirement</li>
</ul></li>
</ol>
<p>—</p>
<p>Group: (G,⋅,0)</p>
<ol>
<li>⋅ is associative</li>
<li>Identity element 0</li>
</ol>
<p>— Careful about the inverses. Works generally only if ⋅ is
commutative.</p>
<pre><code>   x⋅y = z
=&gt; (x⋅y)⋅y⁻¹ = z⋅y⁻¹
=&gt; x⋅(y⋅y⁻¹) = z⋅y⁻¹
=&gt; x⋅e = z⋅y⁻¹
=&gt; x = z⋅y⁻¹
</code></pre>
<p>—</p>
<p>ℤ is a ring.</p>
<ul>
<li>+: plus</li>
<li>*: mult</li>
<li>e: zero</li>
</ul>
<p>(𝔹, xor, ∧, true, false) is a ring. (ℤ/nℤ, mod n,</p>
<p>If R1 and R2 are rings, then R1⨯R2 is a ring (via cartesian product).
This is a product ring.</p>
<p>—</p>
<p>Consider another ring:</p>
<pre><code>(ℤ/2ℤ, +, ·, 0, 1)
</code></pre>
<p>where ℤ/2ℤ is set of integers modulo 2.</p>
<p>Here, addition is modulo 2.</p>
<p>(Hence the name <em>ring</em>..)</p>
<p>—</p>
<p><strong>Residue classes</strong>:</p>
<ul>
<li>Special case of equivalence classes.</li>
</ul>
<p>Remark: Equivalence class and congruence class are apparently the
same.</p>
<hr />
<p>Application of extended Euclid's algorithm.</p>
<p>ℤ/2ℤ is the set of residue classes on division on ℤ by 2. Only two
(equivalence?) classes: odd and even. All elements in the same residue
class considered the same.</p>
<p>5 ≡ 7 mod 2 means 5 and 7 considered same.</p>
<p>Eg: 2 * 3 is same as 0 * 1 = 1</p>
<p>This is quotienting. All elements in the same class considered
same.</p>
<p>This is the simplest example of a <strong>quotient ring</strong>.</p>
<p>Equivalence classes. a ~ b</p>
<p>:DBT: Difference: residue and equivlaence classes.</p>
<p>Consider (ℤ/3ℤ, +, *, 0, 1)</p>
<p>Eg: 1 + 2 = 0</p>
<p>In general, we can talk about ℤ/aℤ where a ∈ ℕ₁</p>
<p>ℤ/aℤ = {0, 1, 2, …, a-1}</p>
<p>Additive inverse of ℤ/aℤ?</p>
<p>ℤ/3ℤ: a-3 a-2 is 1.</p>
<h2 id="chinese-remainder-theorem">Chinese remainder theorem</h2>
<p>Given:</p>
<ul>
<li>a, b such that a and b <strong>are coprime</strong>
<ul>
<li>ie, gcd(a,b) is 1</li>
</ul></li>
<li>Two integers x1 and x2</li>
</ul>
<p>Then, we can find a <strong>unique</strong> x such that:</p>
<pre><code>x ≡ x1 mod a
x ≡ x2 mod b
</code></pre>
<p>Also could say??</p>
<ul>
<li>x1 ∈ ℤ/aℤ</li>
<li>x2 ∈ ℤ/bℤ</li>
<li>x ∈ ℤ/abℤ</li>
</ul>
<p>Eg:</p>
<pre><code>x ≡ 2 (mod 3)  |  x ≡ r1 (mod m1)
x ≡ 3 (mod 5)  |  x ≡ r2 (mod m2)
x ≡ 2 (mod 7)  |  x ≡ r3 (mod m3)
</code></pre>
<p>where the <code>rᵢ</code> are residues and <code>mᵢ</code> are the
moduli.</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>sage: x <span class="op">=</span> crt([<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>],   <span class="co"># residues</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>....:         [<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>])   <span class="co"># moduli</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>sage: x</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="dv">23</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>sage: x<span class="op">%</span><span class="dv">3</span>, x<span class="op">%</span><span class="dv">5</span>, x<span class="op">%</span><span class="dv">7</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>)</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>sage: (x<span class="op">%</span><span class="dv">3</span>, x<span class="op">%</span><span class="dv">5</span>, x<span class="op">%</span><span class="dv">7</span>) <span class="op">==</span> (<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">2</span>)</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a><span class="va">True</span></span></code></pre></div>
<h2 id="proof">Proof</h2>
<p>a and b are coprime. =&gt; gcd(a,b) = 1</p>
<p>∴ from Bezout's identity, αa + βb = 1 where α β ∈ ℤ</p>
<p>Find u and v such that</p>
<ul>
<li>u ≡ 1 mod a</li>
<li>u ≡ 0 mod b</li>
<li>v ≡ 0 mod a</li>
<li>v ≡ 1 mod b</li>
</ul>
<p>Use of this u and v is that:</p>
<p>x = x1.u + x2.v Taking moda on both sides,</p>
<p>x.moda = x1.u.moda + x2.v.moda =&gt; x.moda = x1(u.moda) + x2(v.moda)
=&gt; x.moda = x1(u.moda) + 0</p>
<p>Now let's say:</p>
<pre><code> αa  +  βb  = 1
|  |   |  |
+--+   +--+
 u      v
</code></pre>
<p>x can act like a secret.</p>
<p>Computation is efficient ∵ it's 𝑂(loga)</p>
<hr />
<p>ℤ/abℤ =~ ℤ/aℤ ⨯ ℤ/bℤ</p>
<p>These two are the same ring ∵ there's is an isomorphism between
them.</p>
<p>Map from ℤ/aℤ ⨯ ℤ/bℤ is the Chinese remainder theorem. It's inverse
of the morphism in the other direction.</p>
<p>(u,v) where u∈ℤ/aℤ and v∈ℤ/bℤ</p>
<p>(u1, v1) + (u2,v2) = (u1+u2, v1+v2) (u1, v1) * (u2,v2) = (u1+u2,
v1+v2)</p>
<hr />
<p>ℤ/15ℤ =~ ℤ/5ℤ ⨯ ℤ/3ℤ</p>
<p>Multiplicative inverse of 7. Not in 15. (the inverse may not always
exist)</p>
<p>So map it to other side by taking mod.</p>
<p>7 ——-&gt; (7mod5, 7mod3) (2, 1)</p>
<p>7</p>
<p>Taking inverse,</p>
<p>2*3 is 6 and 6mod5 is 1. 1mod3 is 1.</p>
<p>So,</p>
<p>(2,1) —-&gt; (1,1) (1mod5, 1mod3)</p>
<p>Identity is 1. So inverse aims at it.</p>
<p>Going back with CRT,</p>
<p>91mod15 is 1.</p>
<p>13 is inverse of 7mod15 (found this by own. But CRT can do it.)</p>
<p>We did the arithmetic in terms of the components. Instead of doing it
on the bigger ring,</p>
<p>Additive inverse = negative Multiplicative inverse = inverse</p>
<pre><code>      take mod
   +------&gt;----+
   |           |
ℤ/abℤ =~ ℤ/aℤ ⨯ ℤ/bℤ
   |           |
   +------&lt;----+
        CRT
</code></pre>
<hr />
<p>Find inverse of 53 in ℤ/210ℤ</p>
<p>ℤ/210ℤ =~ ℤ/2ℤ * ℤ/3ℤ * ℤ/5ℤ * ℤ/7ℤ</p>
<p>Taking 53 to smaller rings:</p>
<p>(1, 2, 3, 4)</p>
<p>Taking multiplicative inverses:</p>
<p>(1, 2, 2, 2)</p>
<p>Now we can bring this back to ℤ/210ℤ via CRT.</p>
<h2 id="extended-crt">Extended CRT</h2>
<p>Given:</p>
<ul>
<li>a1, a2,…,ar which are pairwise coprime
<ul>
<li>ie, every pair have to be coprime.</li>
</ul></li>
</ul>
<p>Then,</p>
<p>ℤ/a1.a2…arℤ =~ ℤ/a1 * ℤ/a2 * … * ℤ/ar</p>
<h3 id="proof-1">Proof</h3>
<p>Induction on r.</p>
<p>ui = 1 mod ai vi = 0 mod aj, j≠i</p>
<p>a = ai</p>
<p>b = Π aj j≠i</p>
<p>αai + βb = 1</p>
<p>αai + β Π aj = 1 j≠i</p>
<p>Taking mod???</p>
<p>Π aj becomes 0 (by definition) j≠i</p>
<p>après: Guassian elimination for finding determinant:</p>
<ul>
<li>𝑂(n³) but there is no bound on the size of numbers that we might
encounter</li>
<li>Needs division??</li>
</ul>
<p>Soln: CRT =&gt; entries won't blow up</p>
<p>Additive inverses (negatives) exist. But multiplicative inverses
(inverses) needn't. 0 never has inverse 1's inverse is itself.</p>
<p>Inverse exists only if number is coprime with n.</p>
<p>Residue classes of ℤ/nℤ = {0, 1, 2, … n-1}</p>
<p>Eg: ℤ/nℤ = {0, 1, 2, … n-1}</p>
<p>Consider ℤ/6ℤ. This ring has no inverse for 2.</p>
<p>∵ if 2 had an inverse,</p>
<pre><code>   2x ≃ 1 
=&gt; 6x ≃ 1
=&gt; 6x (mod 6) ≃ 1 (mod 6)
=&gt; 0 ≃ 1
</code></pre>
<p>which is not true.</p>
<p>So 2 is not invertible in ℤ/6ℤ.</p>
<p>Among the residue classes of ℤ/6ℤ, only those value which are coprime
with 6 have inverses.</p>
<pre><code>{0, 1, 2, 3, 4, 5}
       ✗  ✗  ✗   


 - 0 can&#39;t have an inverse.
 - 1 is its own inverse.
 - inv(5) is 5
   + 25mod6 ≡ 1

 - gcd(6,2) = 2
 - gcd(6,3) = 3
 - gcd(6,4) = 2
</code></pre>
<hr />
<p>Extended Euclid also</p>
<p>αx + βn =1 1 mod n????</p>
<h1 id="tue-1"><span class="done DONE">DONE</span> [2023-01-31 Tue]</h1>
<p><code>u ~ v</code> =&gt; u and v are in the same residue class.</p>
<p>or <code>u ≡ v (mod a)</code></p>
<p>ie, both u and v give same remainder when divided by a.</p>
<p><code>a / (u-v)</code> (ie, u-v divides a completely).</p>
<hr />
<p>Revisiting the last proof of the previous class:</p>
<p>Find e1 and e2 such that</p>
<p>e1 ≡ 1 moda e1 ≡ 0 modb e2 ≡ 0 moda e2 ≡ 1 modb</p>
<p>Find α and β such that</p>
<p>e2 e1</p>
<table>
<tbody>
<tr class="odd">
<td></td>
</tr>
</tbody>
</table>
<p>α.a + β.b = 1</p>
<p>Taking moda on both sides,</p>
<p>0 + βb(mod a) = 1</p>
<hr />
<h2 id="crt">CRT</h2>
<p>Let a₁,.. aₖ be a set of pairwise coprime integers.</p>
<p>Then solve:</p>
<p>x ≡ x₁ mod a₁ x ≡ x₂ mod a₂ … … x ≡ xₖ mod aₖ</p>
<p>Let a = a₁ b = a₂.a₃…aₖ</p>
<p>a and b are coprime. So,</p>
<p>ei ≡ 1 mod aj, j≠i ei ≡ 0 mod ai</p>
<p>e1 ≡ 1 mod a e1 ≡ 0 mod b</p>
<hr />
<p>Consider ℤ/abℤ</p>
<p>2 ∈ ℤ/15ℤ</p>
<p>Here, 2 represents the residue class in which 2 lies.</p>
<p>17 and 2 are same with respect to ℤ/15ℤ.</p>
<p>∵ 2 ≡ 17(mod 15)</p>
<p>Addition =&gt; add and the result's residue class is the actual
result.</p>
<p>Ring =&gt; Addition always commutative. So commutativity in ring
=&gt; commutativity wrt the multiplication operation</p>
<p>In this course, unless specified otherwise all rings are
commutative.</p>
<p>CRT says the LHS and RHS of the following are identical:</p>
<pre><code>ℤ/abℤ ≅ ℤ/abℤ ⨯ ℤ/abℤ 
</code></pre>
<p>Ring homomorphism: A map that preserves ring operations.</p>
<p>Invertible homomorphism =&gt; isomorphism</p>
<p>Homomorphism: may be 1-way Isomorphism: definitely 2-way</p>
<p>Advantage: A problem may be difficult in one ring. If it's easier in
another ring with which there is an isomorphism, do it!</p>
<p>Gaussian elimination to find determinant of a matrix had these
disadvantages:</p>
<ul>
<li>division involved</li>
<li>intermediate values can be very large though final result is
small.</li>
</ul>
<p>Let's try for a better way using CRT.</p>
<p>Λ max possible value, which needs logΛ space.</p>
<p>For an nxn matrix, we need n².logΛ space.</p>
<p>We need a bound on the size of the result determinant in terms of n
and logΛ (n.logΛ)</p>
<p>Sign part of determinant may be ignored as we are just interested in
the size.</p>
<p>(a,b) =&gt; use b instead of a and vice versa.</p>
<p>odd number of transposition =&gt; sign = -1 else 1.</p>
<p>Permutations. ∵ that's how things are done in Gaussian elimination, I
suppose.</p>
<p>log(n!) = n.logn</p>
<p>n Π aᵢ i=1</p>
<p>size(det) ≤ n(logn + logΛ)</p>
<p>Then the <em>value</em> of the det would be</p>
<p>-2<sup>nlogn + nlogΛ</sup> ≤ det ≤ 2<sup>nlogn + nlogΛ</sup> -B ≤ det
≤ B</p>
<p>Let N &gt; 2B+1</p>
<p>Find det (mod N) and then you get the whole thing between 0 and
N.</p>
<p>Bigprime method: Choose a number p &gt; 2B+1</p>
<p>Smallprime method: Pick the first k prime numbers such that</p>
<pre><code> k
 Π pᵢ ≥ 2B+1
i=1
</code></pre>
<pre><code>det ≡ x₁ mod p₁
det ≡ x₁ mod p₁
      ...
det ≡ xₖ mod pₖ
</code></pre>
<p>where <code>xᵢ</code> is the determinant of the matrix (ie,
<code>M mod pᵢ</code>).</p>
<p>prime number theorem?? number of primes &lt;= k is k /logₑx</p>
<p>Eg:</p>
<pre><code>A = ⎡5  4⎤
    ⎣2  3⎦

Largest number = N = 5
Small prime method.

Primes ≤N are: 2,3,5

A(mod 2) = │⎡1  0⎤│ = 1 = x1
           │⎣0  1⎦│

A(mod 3) = │⎡2  1⎤│ = -2 = x2
           │⎣2  0⎦│

A(mod 5) = │⎡0  4⎤│ = -8 = x3
           │⎣2  3⎦│

det(A) ≡ x1 (mod p1)  =  1 (mod 2)  =  1 (mod 2)
       ≡ x2 (mod p2)  = -2 (mod 3)  =  1 (mod 3)
       ≡ x3 (mod p3)  = -8 (mod 5)  =  2 (mod 5)

ie,

det(A) ≡ 1 (mod 2)
       ≡ 1 (mod 3)
       ≡ 2 (mod 5)

The only value of det(A) that satisfies this set of equations is 7.

∴ det(A) = 7.
</code></pre>
<h1 id="thu-1"><span class="done DONE">DONE</span> [2023-02-02 Thu]</h1>
<p>We wanted to find det(A) where A is an nxn ℤ matrix.</p>
<p>We wish to find an upper bound on size of det(A). We would like this
bound to be small. ie, polynomial over size(A).</p>
<p>ie, at most <code>n.max(aᵢⱼ)</code> where
<code>i,j ∈ [1,n]</code>.</p>
<p>Find first k prime numbers such that</p>
<p>k Π pᵢ ≥ 2.2<sup>size(detA)</sup> i=1</p>
<p>≥ 2B + 1</p>
<p>detA &lt; B</p>
<p>det A = D if D &lt; N else (N-D)</p>
<h2 id="modular-method">Modular method</h2>
<p>f(x1,..xn) ∈ ℤ[x1,…,xn] polynomial on ℤ??</p>
<ol>
<li>firwst bound values of f(a) in terms of a this should be small</li>
<li>FInd f(a) mod pi fo the first k primes pᵢ</li>
</ol>
<p>For a large N, if we know λmodN then we can find λ provied 2|λ| + 1
&lt; N.</p>
<p>Prime number theorem. Number of primes &lt; n is bounded by
x/logx</p>
<p>π(x)</p>
<p>Rndomly pick 1/logx probabilyt.</p>
<p>We want k such that p1…pk ≥ B Obvisouly, 2ᵏ &lt; p1..pk` 2ᵏ &lt; B k
&lt; logB</p>
<p>Eg: In 2ᵏ &lt; p1..pk` Take k = B.</p>
<p>x = (2logB.loglogB) / (loglogB+ logloglogB +1)</p>
<p>Power of modular arithmetic.</p>
<p>Split the big computation into several small ones and tehn we can put
it back together. We can let smaller computer do the small work and
combine the results to make the big result which would've been difficult
to for a single computer to do.</p>
<h2 id="example-det-computation">Example det computation</h2>
<pre><code>⎡ 5    10  ⎤
⎣ 200  135 ⎦

det(A mod 2) is 1

⎡1 0⎤
⎣0 1⎦

det(A mod 3) is -2

⎡2 1⎤
⎣2 0⎦

det(A mod 5) is 0

⎡0 0⎤
⎣0 0⎦

det(A mod 7) is -2

⎡5 3⎤
⎣4 2⎦

det(A mod 11) is -5

⎡5 10⎤
⎣2  3⎦


det(A) (mod 2) ≡ 1
det(A) (mod 3) ≡ -2 = 3
det(A) (mod 5) ≡ 0
det(A) (mod 7) ≡ -2 = 5
det(A) (mod 11) ≡ -5 = 6
</code></pre>
<p>We stopped at 11, but we stop based on the bound that we already
infer.</p>
<p>200 was largeset number</p>
<pre><code>|A|  =    Σ   sign(σ)
         n.Λⁿ
</code></pre>
<p>The prime p values are very small with respect to other numbers.</p>
<h2 id="rings-1">Rings</h2>
<p>We had seen that</p>
<p>ℤ/nℤ =~ ℤ/p1ℤ ⨯ … ⨯ ℤ/pₖℤ</p>
<p>if n = p₁ * …. * pₖ</p>
<p>Ring isomorphic: "Same ring under different attire"</p>
<p>HW: is 𝔹 forming a ring.</p>
<p>nxn matrix over any commutative ring form a ring but is a
non-commutative ring.</p>
<ul>
<li>ℚ</li>
<li>ℂ</li>
<li>ℝ</li>
</ul>
<p>If <code>R</code> is a commutative ring, <code>R[x]</code> is the
ring of polynomials in <code>x</code> over the coefficient ring
<code>R</code>.</p>
<ol>
<li>: symbol for disjoint union</li>
</ol>
<p>R U R2 U … U Rⁿ</p>
<p>(a0,…,an) = a0 + a1X + a2X² + … + anXⁿ</p>
<p>Not the function associated with the polynomial. Think of the
polynomial itself. As a formal object.</p>
<p>Could think of polynomial as infinite sequences which after some time
coefficients are all zero. Only finitely many coefficients are
non-zero.</p>
<p>Addition</p>
<p>Product:</p>
<pre><code> Σ  aᵢbⱼ Xⁱ⁺ʲ
i j
</code></pre>
<p>Bivariant polynomial is the ring of univariant polynomials over the
ring osf univarieant polynomials.</p>
<p>If the ring is <em>suitably good</em>, CRT is applicable there as
well.</p>
<p>Bivariant =&gt; may not have unique factorization. Polynomial rings
=&gt; always have unique factorization.</p>
<p>ℤ[√-5] ring doesn't have unique factorization. ∵. ∈ ℂ.</p>
<p>—</p>
<p><strong>Ring homomorphism</strong>: structure preserving map from one
ring to another ring.</p>
<p><strong>Ring isomorphism</strong> if the transformation done by this
map is isomorphic with respect to the rings, in which case the rings are
said to be isomorphic to each other.</p>
<h1 id="tue-2"><span class="done DONE">DONE</span> [2023-02-07 Tue]</h1>
<p><strong>Monic polynomial</strong>: Univariate polynomial (ie,
polynomial of only single variable) whose leading coefficient (ie,
coefficient of largest degree term) is 1. Eg: x² + 3x</p>
<p><strong>Square-free polynomial</strong>: No repeated roots</p>
<p>Zero polynomial assumed to have degree <code>-∞</code>.</p>
<p>—</p>
<pre><code>aᵢXᵢ + bᵢXᵢ = (aᵢ+bᵢ)Xᵢ
</code></pre>
<pre><code>aᵢXᵢ ⋅ bᵢXᵢ = (aᵢ⋅bᵢ)Xᵢ
</code></pre>
<p>Think of polynomails not as functions but as 'standalone' objects
that we can manipulate. But we can evaluate a polynomial at points of
our choice.</p>
<p><strong>Integral domain</strong>: Rings with an additional property:
if product of 2 elements is 0, one of them is zero.</p>
<p>A commutative ring is an integral domain if:</p>
<ul>
<li>∀a,b∈R, a⋅b=0 then a=0 ∨ b=0</li>
</ul>
<p>ie,</p>
<pre><code>a⋅b = 0   →   a=0 ∨ b=0
</code></pre>
<p>Eg: ℤ (surprise, surprise!)</p>
<p>Non-example: ℤ/6ℤ</p>
<p>∵ 2,3 ∈ ℤ/6ℤ yet 2⋅3 is 0.</p>
<p>A non-zero element <code>a</code> in a ring is a
<strong>zero-divisor</strong> if there is a non-zero element
<code>b</code> such that <code>a⋅b=0</code>. In the case of ℤ/6ℤ, 2 and
3 are zero-divisors.</p>
<p>Another example: In ℤ/12ℤ, 4⋅3=0. So 4 and 3 are zero-divisors.</p>
<p>ℤ/nℤ is always a non-integral domain if n is a composite number but
is an integral domain if n is prime.</p>
<p>ab = 0 in ℤ/pℤ means p divides one of a or b in which case a (mod p)
= 0 or b(mod p) = 0.</p>
<h2 id="fields">Fields</h2>
<p>Eg: ℚ, ℂ, ℝ, ℤ/pℤ (where p is a prime).</p>
<p>If R is a ring, then R* is the multiplicative group of units in
R.</p>
<p>—</p>
<p>unit: R*</p>
<p>a⁻¹</p>
<p>Field if R* \ {0} is a unit.</p>
<p>xa+yp=1 =&gt; x is inverse of a</p>
<p>Fermat's little theorem may also be used.</p>
<pre><code>     aᵖ⁻¹ ≡ 1 mod p
=&gt; aᵖ⁻².a ≡ 1 mod p
</code></pre>
<p>ie, aᵖ⁻² is inverse of a.</p>
<p>p=2 =&gt; manually verify. Otherwise little theorem could help.</p>
<p>len[(ℤ/pℤ)*] is p-1</p>
<p>&lt;a&gt; ⊆ ℤ/pℤ</p>
<p>where &lt;a&gt; is subgroup</p>
<p>In ℤ/nℤ, <code>a ~ b</code> if <code>n/(a-b)</code>. ie, a and b are
in the same residual class wrt n.</p>
<h2 id="ideals-of-a-ring">Ideals of a ring</h2>
<p>First introduced by Kummer.</p>
<p>Ideal numbers.</p>
<p>Was used to prove Fermat's last theorem.</p>
<p>We can kind of quotient a ring with ideals like we did with residual
classes.</p>
<p>In the case of residue classes, [a] + [b] ≜ [a+b] [a] * [b] ≜
[a*b]</p>
<p>(where ≜ means congreunce.)</p>
<p>Well defined definition.</p>
<p>An ideal of a ring is a subset of that ring. An ideal can be used to
construct a quotient ring. For any ideal, every element of R can be
written as xI.</p>
<p>:HW: Chinese remainder theorem can be generalized to ideals.</p>
<hr />
<p>Subring: S is a subring of R (ie, S ⊂ R) if:<a
href="https://sites.millersville.edu/bikenaga/abstract-algebra-1/ideals-and-subrings/ideals-and-subrings.pdf">³</a></p>
<ul>
<li>Zero element (additive inverse) of R is in S (ie, 0 of S and R are
the same)</li>
<li>S is closed under addition
<ul>
<li>ie, a,b∈S ⇒ a+b∈S</li>
</ul></li>
<li>S is closed under additive inverses
<ul>
<li>ie, a∈S ⇒ -a∈S</li>
</ul></li>
<li>S is closed under multiplication
<ul>
<li>ie, a,b∈S ⇒ a⋅b∈S</li>
</ul></li>
</ul>
<p>Ideal: 'Sub-objects' of rings<a
href="https://sites.millersville.edu/bikenaga/abstract-algebra-1/ideals-and-subrings/ideals-and-subrings.pdf">³</a>.</p>
<p>I ⊆ R is an ideal if</p>
<ul>
<li>I is an additive subgroup of R
<ul>
<li>Additive inverse also in I</li>
</ul></li>
<li>∀x∈R, y∈I then x⋅y∈I</li>
</ul>
<p>ie,</p>
<p>I ⊆ R</p>
<ul>
<li>Zero element (additive inverse) of R is in I (ie, 0 of I and R are
the same)
<ul>
<li>ie, 0 ∈ I (ie, additive identity element)</li>
</ul></li>
<li>I is closed under addition
<ul>
<li>ie, a,b∈I ⇒ a+b∈I</li>
</ul></li>
<li>S is closed under additive inverses</li>
<li>If a∈I and f∈R then a⋅f∈I and f⋅a∈I
<ul>
<li>ie, I is closed under multiplication on either side by elements from
parent ring.</li>
<li>This is two-sided ideal (since we are dealing with commutative
rings, that's understood)</li>
<li>If only f⋅a∈I is there: left ideal</li>
<li>If only a⋅f∈I is there: right ideal</li>
</ul></li>
</ul>
<p>Ideals needn't be rings? But must be subset of a ring.</p>
<p>Ideal vs subring: Multplication closure for subrings is only for
elements within the subring. But for ideals it's for elements in the
parent ring as well.</p>
<p>Lemma: R itself and {0} are ideals for any ring R.</p>
<p>—</p>
<ul>
<li>Proper ideal: ideal is not R itself</li>
<li>Non-trivial ideal: ideal is not {0}</li>
</ul>
<p>—</p>
<p>Statement: ℤ ⊂ ℝ but ℤ is not an ideal of ℝ.</p>
<ul>
<li>Additive identity = 0 ∈ ℤ ✓</li>
<li>Closed under addition ✓
<ul>
<li>∀a,b∈ℤ → a+b∈ℤ</li>
</ul></li>
<li>Closed under additive inverses ✓
<ul>
<li>∀a∈ℤ → -a+a=0 ∧ -a∈ℤ</li>
</ul></li>
<li>Closed under multiplication ✓
<ul>
<li>∀a,b∈ℤ → a⋅b∈ℤ</li>
</ul></li>
</ul>
<p>∴ ℤ is a subring of ℝ</p>
<p>But, π∈ℝ ∧ 1∈ℤ still π⋅1∉ℤ</p>
<p>∴ ℤ is not an ideal of ℝ.</p>
<p>Proof by contradiction.</p>
<p>—</p>
<p>Principal ideals of a commutative ring R:</p>
<p>If a∈R, then the principal ideal of R generated by <code>a</code>
is:</p>
<pre><code>&lt;a&gt; = {x⋅a | x ∈ R}
</code></pre>
<p>Eg: In the ring of polynomials with real coefficients (ie, R[X]), the
principal ideal generated by <code>x²+1</code> is:</p>
<pre><code>&lt;x²+1&gt; = {f(x)⋅(x²+1) | f(x) ∈ R[X]}
</code></pre>
<p>which ends up being the set of all R[X] elements which are multiples
of <code>x²+1</code>.</p>
<p>—</p>
<p>Quotient rings:</p>
<p>:DBT: How are ideals used to construct quotient rings. :DBT:
Quotienting means just the parition into 'residue-class'-like
partitions?</p>
<p>:DBT: Rings where unique factorization failed —</p>
<p>Eg:</p>
<ul>
<li>{0} (this is the smallest possible sub-group of R)</li>
<li>ℝ</li>
</ul>
<p>a-b ∈ I =&gt; same class.</p>
<p>[a] + [b] = [a+b]</p>
<p>[a+i1] + [b+i2] = a + i1 + b + i2 = a+b i1 + b + i2</p>
<p>[a]⋅[b] = [a⋅b] [a+i1]⋅[b+i2] = ab i1b i2a i1i2</p>
<table>
<tbody>
<tr class="odd">
<td></td>
</tr>
</tbody>
</table>
<p><del>———-</del> ∈ I</p>
<p>ℝ quotient I: ℝ/I = {a+I | a∈ℝ}</p>
<p>ℝ/I is also a (commutative) ring.</p>
<p>Motivation for ℂ:</p>
<ul>
<li>Some polynomials don't have solution</li>
<li>Eg: x2+1</li>
<li>Even degree polynomilas</li>
</ul>
<p>—</p>
<h2 id="ℂ">ℂ</h2>
<p>Starting ring: ℝ[x] ie, polynomial ring over ℝ (ie, coefficients are
in ℝ).</p>
<p>This polynomial <code>f</code> in ℝ[x] has no solution:</p>
<pre><code>x² + 1 =0 
</code></pre>
<p>∵ <code>x² + 1</code> can't be factorized. ie, this polynomial is
irreducible.</p>
<p>But if a solution did exists for this, let it be <code>a</code>.</p>
<p>Then,</p>
<pre><code>f(a) = 0 then
</code></pre>
<p>(x-a).g(x) = f(x)</p>
<p>(We get this courtesy of Euclid's algorithm.</p>
<pre><code>f(x) = q(x-a) +r
</code></pre>
<p>f(a) in our case is 0. q(x-a) )</p>
<p>Principal ideal: ideals that can be generated by a single element of
the ring</p>
<p>aℝ</p>
<p>A quotienting:</p>
<p>ℝ[x] / (x²+1).ℝ[x]</p>
<p>ie, neglect all multiples of x2+1.</p>
<p>ie, polynomial mod (x²+1)</p>
<p>ie, x2 can be replaced with -1.</p>
<p>Elements (non-neglected) will look lke: (a₀ + xa₁)</p>
<p>Ultimately it's just linear polynomials in this case. Degree is
always &lt; 2.</p>
<p>This is just ℂ-arithmetic.</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>sage: RR[x].quotient(x<span class="op">^</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>Univariate Quotient Polynomial Ring <span class="kw">in</span> a over Real Field <span class="cf">with</span> <span class="dv">53</span> bits of precision <span class="cf">with</span> modulus x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> <span class="fl">1.00000000000000</span></span></code></pre></div>
<p>:DBT: But how?</p>
<p>Addn:</p>
<pre><code>  (a₀+a₁x) + (b₀+b₁x)
= a₀+b₀+(a₁+b₁)x
</code></pre>
<p>Multn:</p>
<pre><code>  (a₀+a₁x) * (b₀+b₁x)
= a₀b₀ + (a₀b₁+a₁b₀)x + a₁b₁x²
= a₀b₀ + (a₀b₁+a₁b₀)x + (a₁b₁)(-1)
= (a₀b₀ - a₁b₁) + (a₀b₁+a₁b₀)x
</code></pre>
<p>Again, this is just ℂ-arithmetic. Think of the x as the imaginary
number <code>i</code>.</p>
<p>If a polynomail F is irreducable, we can 'attach a solution' by this
kind of quotienting.</p>
<p>ℚ[x]/(x²-2)ℚ[x]</p>
<p>Here, we got ℂ from ℝ by quotienting: ie, modulo the ideal
(x²+1)ℝ[x]</p>
<h1 id="thu-2"><span class="done DONE">DONE</span> [2023-02-09 Thu]</h1>
<h2 id="euclidean-domains">Euclidean domains</h2>
<p>A domain where Euclidean algorithm works.</p>
<p>R/I is the quotient ring with respect to the ideal I.</p>
<p>R/I consists of equiv classes for the eq relation a ~ b =&gt; a-b ∈
I</p>
<p>Principal ideal of a ring R: Ideal generated by a single element of R
multiplied with every other element of the ring.</p>
<ul>
<li>aR = {ax | x∈R} where a ∈ R
<ul>
<li>left principal ideal</li>
</ul></li>
<li>Ra = {xa | x∈R} where a ∈ R
<ul>
<li>right principal ideal</li>
</ul></li>
</ul>
<p>pℤ is a principal ideal in ℤ/pℤ</p>
<p>:TODO: Fields are integral domains with an additional property (sth
related to zero…)</p>
<p>Fields ⊂ Integral domains</p>
<p>Euclidean domain:</p>
<ul>
<li>An integral domain
<ul>
<li>a⋅b = 0 → a=0 ∨ b=0</li>
</ul></li>
<li>There's a function d:ℝ→ℕ (called <strong>degree</strong>)
<ul>
<li>d(0) = 0 of ring</li>
<li>Every element has natural number 'assigned' to it.</li>
<li>We can find q,r∈ℝ such that b≠0 and d(r)&lt;d(b) and a=qb+r</li>
</ul></li>
</ul>
<p>Eg: let d(x):ℤ→ℕ = |x| Eg: In ℂ[X] (ie, polynomials with ℂ coeff) let
d(x):ℂ→ℕ = deg</p>
<p>ℂ[X]* = ℂ (an abuse of notation to indicate that ℂ is made by
'injecting' into polynomials. const polynomials)</p>
<p>d(g) = degree(g)+1 This is the 'measure'.</p>
<p>Polynomial division of 2 polynomials a and b. Stop when d(a) &lt;
d(b).</p>
<pre><code>                 +------------------------------
bₙXⁿ + ... + b₀  | aₘXᵐ + aₘ₋₁Xᵐ⁻¹ + ..... + a₀
</code></pre>
<p>CRT holds for all Euclidean domains.</p>
<p>Principal ideal domain: A domain in which all ideals are principal
ideals.</p>
<p>All Euclidean domains are principal ideal domains. ie, ideal looks
like <code>aR</code>. ie, just the multiples of a given n???</p>
<p>For example, ℤ is a Euclidean domain. How would we prove that all its
ideals look like nℤ?</p>
<p>Take an aribritrariy ideal a∈I.</p>
<p>We know that aℤ ⊆ I</p>
<p>Pick n = min(|a| such that a∈I) ie, element for which degree is
minimum. here, we made degree as absolute value.</p>
<p>Assume n ∉ I. a ∈ I \ nℤ.</p>
<p>a = nq+r r = a - nq ∈ I</p>
<p>ie, contradiction.</p>
<p>So all ideals are principals.</p>
<p>Same proof applicable for all Euclidean domains. Just plug in the
appropriate degree function.</p>
<p>a|b =&gt; unique q and r such that a = qb + r if r is zero, then a
divides b.</p>
<p>n terms of ideals,</p>
<p>Principal ideals aR will contain principal ideals bR</p>
<p>ie, a|b =&gt; aR ⊇ bR</p>
<hr />
<p>2 ideals I and J</p>
<p>&lt;I union J&gt; = ideal generated by taking I U J Smallest ideal
containing I and J</p>
<p>Iterate? I and J</p>
<p>Top down view: do all and then do their intersection Bottom up view:
do one by one and then do their union till ∞</p>
<pre><code>    I ∪ J  gcd(a,b) Largest ideal contained in both I and J
    /   \
   /     \
aI         Jb
  \       /
   \     /
    I ∩ J  lcm(a,b)  multiples of both and b
</code></pre>
<p>'Language' of ideals can be converted to ….</p>
<p>Largest possible ideal = Ring itslef Smallest ideal = 0</p>
<p>When can ideal be ring itself? units of the ring</p>
<p>Probably wrong: ℂ (and any field) only 2 ideals?? 0 and ring itself.
∵ invertible =&gt; 1 ∈ ideal if 1 is in ideal every is in ideal??</p>
<p>zero (of ring) gives zero ideal.</p>
<p>Prime factorization theorem upto reordring and multiplication by
units. Units were just 1 nad -1 so sort of ignroed.</p>
<p>ℂ[x] =&gt; entire ℂ are units.</p>
<p>Any polynomial f(x) can be written as</p>
<p>f(x) = g1(x) ….. gn(x)</p>
<p>Now we got lcm and gcd in the language of ideals.</p>
<p>Can we show that gcd(a,b) = gcd(b, a rem b) in the language of
ideals.</p>
<p>In the language of ideals, this would look like:</p>
<p>aR ∪ bR</p>
<p>First show that</p>
<p>aR ∪ bR ⊇ R</p>
<p>Computation of the remainder better be effective.</p>
<p>I is an ideal of R a∈I such that d(a) is min I = aR b∈I b=qa+r
d(r)&lt;d(a) then r=0</p>
<p>When will we say that I and J are coprime?</p>
<h1 id="tue-3"><span class="done DONE">DONE</span> [2023-02-14 Tue]</h1>
<p>R together with a fucntion d:R→ℕ</p>
<p>d(0) - 0, d(x) &gt; 0</p>
<p>degree function.</p>
<p>d:</p>
<ul>
<li>ℤ: abs</li>
<li>ℂ[X]: d(0)=0, d(p(x)) = deg(p(x))+1</li>
</ul>
<p><strong>Prinicipal ideal domain</strong>:</p>
<ul>
<li>any ideal is a principal ideal
<ul>
<li>ie, are like <code>aR</code></li>
</ul></li>
</ul>
<p>unique factorization over R. a = p1p2p3…</p>
<p>essentially uniquely ∵ p.ε.p.ε⁻¹ where ε is a unity</p>
<p>Maximal ideals are irreducible.</p>
<ul>
<li>Ideals which don't contain anything more.</li>
</ul>
<p>ℤ/pℤ is a field if p is prime. field =&gt; all elements except 0 are
invertible. Eg: ℚ, ℝ, ℂ, ℤ/pℤ Non-eg: ℤ/6ℤ (try 3⋅2)</p>
<hr />
<p>F = a field</p>
<p>F[X] ring over F =&gt; Both Euclidean algorithm and an integral
domain.</p>
<p>Next up:</p>
<ul>
<li>Finite fields: smallest finite field ℤ/2ℤ</li>
<li>Polynomial factorization over finite fields</li>
</ul>
<p>For efficiency analysis, we need to figure out how to represent
finite fields and polynomials over it.</p>
<p>Ring over any field is a Euclidean domain.</p>
<p>What's true for finite fields is not necessarily true for fields in
general.</p>
<h2 id="finite-fields">Finite fields</h2>
<p>Ring: R,+,⋅,1,0</p>
<ul>
<li>(R,+,0) is Abelian group</li>
<li>(R,⋅,1) is commuative monoid</li>
<li>⋅ distributes over +</li>
</ul>
<p>A ring is a field if every element except 0 are invertible. ie, R \
{0} is invertible.</p>
<p>Start with 1. 2 = 1 + 1 3 = 1 + 1 + 1 n = 1 + 1 + 1 + … (n times)</p>
<p>Finitie field: after some time the numbers will repeat (much like a
ring. How's this different from a field again?).</p>
<p><strong>Characteristic of a ring</strong> is n:</p>
<ul>
<li>smallest n such that n is zero in the finite field. if it exists (ℚ
has no such n)</li>
</ul>
<p>ℤ/6ℤ =&gt; 6 ℤ/20ℤ[X] =&gt; 20</p>
<p>char of ℚ,ℤ is called zero (not ∞)</p>
<p>finite char for finite ring??</p>
<p>Char of a finite field is a prime.</p>
<ul>
<li>n=a.b</li>
</ul>
<p>Lemma: Characterstic of a finite field is prime.</p>
<p>What we are driving at: finite fields are only of certain classes.
One is R/pR.</p>
<p>Supporse cardinality of a field is a prime p. is hter any other filed
of size p other than Z/pZ</p>
<p>If there is another field F, then there should be maps between teh
tow fields. An isomorphsim.</p>
<p>Structure preserving map =&gt; morphism.</p>
<p>That means they are essentially the same ring. 'Differen names'</p>
<p>∴ there is only one field with characterstic(or size??) p.</p>
<p>Every finite field should haeve a finite characteristic. And that
should be a prime??</p>
<p>:DBT: Characteristic zero =&gt; non-finite field??</p>
<p>Field of size 2: F₂ The uField of size p: Fₚ</p>
<p>Every odd degree polynmial on ℝ has a solution in ℝ (ie, closed in
ℝ).</p>
<p>—</p>
<p>Remember ℝ[X]/(X²+1)ℝ[X]</p>
<p>x²+1 is a prime. non-factorizable. irreducible. no soln</p>
<p>ℝ[X]/(X²+1)ℝ[X]</p>
<p>is a field. Complex numbers. A field extension of ℝ. A field
contained in ℝ.</p>
<p>Can we find an exntesnion of F₂? x²+1 is not a prime ∵ x²+1 = (x+1)²
= x2+2x+1 = x2+1</p>
<p>But x2+x+1 is irreducible.</p>
<p>F₂[X]/(X²+X+1)F₂[X]</p>
<p>is {a0+a1X | a0 a1 ∈ F₂} ∴ 2 possibilities, 2 variables =&gt; 4
elements.</p>
<p>Size of finite fields are powers of primes. Charactersitci of this
feild is 2.</p>
<p>-1 is same as +1 in F₂.</p>
<p>Addition:</p>
<pre><code>(a0+a1x)+(b0+b1x)
(a0+b0) + (a1+b1)x
</code></pre>
<p>Okay, it's just pairwise addition.</p>
<p>Let's try multiplication:</p>
<pre><code>(a0+a1x)(b0+b1x)
a0b0 + (a0b1+a1b0)x + a1b1x2 
a0b0 + (a0b1+a1b0)x + a1b1(x+1)
</code></pre>
<p>—</p>
<p>Try F₃.</p>
<p>Sounds like x2+1 is irredicible. 9 elements in F₃ then.</p>
<p>—</p>
<p>Try F₁₃.</p>
<p>Quadratic irreducible polynomial =&gt; 13² is size.</p>
<p>—</p>
<p>Fₚ, irreducible degree k polynomial</p>
<p>THer's a unique extension of size k.</p>
<p>—</p>
<p>ℚ(√2) is extension of ℚ[X]/x2-2</p>
<ul>
<li>elements are a+√2b where a,b∈ℚ</li>
</ul>
<p>ℚ(√3) is extension of ℚ[X]/x2-3</p>
<ul>
<li>elements are a+√3b where a,b∈ℚ</li>
</ul>
<p>—</p>
<p>All degree-k extension of a filed are equivalent.</p>
<p>Algorihtm to factor polynomials fover a finite field.</p>
<p>prime ideal.</p>
<p>R/m is a filed R/p is integral domain</p>
<h2 id="extension-fields-ʷ">Extension fields <a
href="https://en.wikipedia.org/wiki/Field_extension">ʷ</a></h2>
<p>A field E is an extension of another field F if F is a subfield of E.
In which case, F is the <strong>base field</strong>, written as
<code>F ⊂ E</code>.</p>
<p><code>E/F</code> means the field E is an extension of the field
F.</p>
<p>Eg:</p>
<pre><code>F = ℚ(√2)
  = ℚ[X]/(X²-2)ℚ[X]
  = {a + √2b | a,b∈ ℚ }

is an extension of the field of ℚ.
∵ (1,√2) can serve as the basis.
So, degree is 2.

Put b=0 and we get all rational numbers =&gt; ℚ ⊂ ℚ(√2)

---

  Q(√2, √3)
= ℚ(√2)(√3)
= {a+√3b | a,b∈ℚ(√2)}
= {(x+√2y) + √3(p+√2q) | x,y,p,q∈ℚ}
= {x + √2y + √3p + √6q | x,y,p,q∈ℚ}

Here, the basis is (1,√2,√3,√6).
Degree is 4.
</code></pre>
<p><strong>Degree</strong> of a field extension: Dimension of the vector
space of the extension</p>
<ul>
<li>Degree of extension of field is same as that of the field =&gt; both
fields are equivalent.</li>
<li>Degree is a measure of the 'size' of the field extension.</li>
</ul>
<p>:DBT: When we quotient, we are dividing what's already there, right?
Then how do we end up with new elements?</p>
<h2 id="fields-1">Fields</h2>
<p>A commutative ring (with identity) where all elements other than 0
are units.</p>
<ul>
<li>ie, all non-zero elements have an inverse in R.</li>
<li>A field is a commutative division ring.</li>
</ul>
<p>Eg:</p>
<pre><code>ℤ is not a field.

3 ∈ ℤ, but 3⁻¹ is 1/3 ∉ ℤ

1 and -1 are the only elements of ℤ with multiplicative inverses in ℤ (themselves).

---

Under addition and multiplication, ℚ,ℝ,ℂ are fields.
</code></pre>
<p>prime subfield:</p>
<ul>
<li>Every field has a unique minimal subfield. Its <strong>prime
field</strong>. ie, it has no proper sub-fields.</li>
<li>It's the intersection of all subfields of the field.</li>
</ul>
<p>Eg: Prime field of GF(3³) is GF(3)</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>sage: a<span class="op">=</span>GF(<span class="dv">3</span><span class="op">^</span><span class="dv">3</span>)</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>sage: a</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>Finite Field <span class="kw">in</span> z3 of size <span class="dv">3</span><span class="op">^</span><span class="dv">3</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>sage: a.prime_subfield()</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>Finite Field of size <span class="dv">3</span></span></code></pre></div>
<p>Eg: Lattice of subfields of GF(2²⁴): (from Pless book)</p>
<pre><code> GF(2²⁴)
   / \
  /   \ 
F2⁸   F2¹²
  \   /\
   \ /  \
   F2⁴  Fq2⁶
     \   /\
      \ /  \
      F2²  Fq2³
        \  / 
         \/ 
        Fq2 
</code></pre>
<p><strong>Irreducible polynomial</strong>: polynomial that cannot be
factorized further.</p>
<p>In F/X²+1 where X²+1 is some polynomial, the polynomial has to be
irreducible in R. Otherwise the quotient won't be a field.</p>
<p>Quotient is a set. Consists of <strong>cosets</strong>.</p>
<h2 id="characteristic-of-a-ring-ʷ">Characteristic of a ring <a
href="https://en.wikipedia.org/wiki/Characteristic_(algebra)">ʷ</a></h2>
<ul>
<li>Sometimes denoted as <code>char(R)</code>.</li>
</ul>
<p>Smallest number of times multiplicative identity (ie, 1) should be
added up to get the additive identity.</p>
<p>ie,</p>
<pre><code>  1 + 1 + 1 + ...... + 1 = 0
  |                    |
  +--------------------+
            |
            |
Number of &#39;1&#39;s here = char(R)
</code></pre>
<ul>
<li>If no such number exists, char(R) is said to be 0 (ppk said it
would've been nice to just say ∞)</li>
</ul>
<p>Eg:</p>
<pre><code>ℤ/2ℤ:

1 + 1 = 0

∴ char(ℤ/2ℤ) = 2

---

ℤ/6ℤ:

1 + 1 + 1 + 1 + 1 + 1 = 0

∴ char(ℤ/2ℤ) = 6

---

(ℚ,+,⋅,0,1) is a ring.

But no matter how many 1-s we add up, it won&#39;t reach 0.o

So, char(ℚ) = 0
</code></pre>
<p>In the case of fields:</p>
<ul>
<li><strong>Characteristic of any field is either a prime number or
0.</strong></li>
<li>Field with non-zero characteristic =&gt; finite field.</li>
</ul>
<p><strong>Prime ideal</strong>: An ideal I is prime if whenever ab∈I,
a∈I or b∈I.</p>
<ul>
<li>analogous to prime numbers in ℤ, where prime ideals are sets that
contain all the multiples of a given prime number. <a
href="https://en.wikipedia.org/wiki/Prime_ideal">ʷ</a></li>
</ul>
<p>Eg:</p>
<p>I = {0,2,4,6,8,10} is a prime ideal of ℤ₁₂.</p>
<p>∵ for any <code>a,b∈I</code>, ab∈I means a∈I or b∈I</p>
<p>Eg: 2*4 ∈ I, and 2∈I.</p>
<p>Eg: In the ℤ ring, set of even numbers is a prime ideal.</p>
<h1 id="thu-3"><span class="done DONE">DONE</span> [2023-02-16 Thu]</h1>
<p>Our goal for the next few lectures: characterize all possible finite
fields.</p>
<p>Interested in polynomial factorization over all fnite fields.</p>
<p>Representation of elements in finite fields.</p>
<p>char(ℝ) = char(ℚ) = 0 (not ∞) ∵ 'infinite' characteristic.</p>
<p>Finite characteristic =&gt; char(R) ≠ 0 Finite characteristic doesn't
mean finite ring.</p>
<p>char(ℤ/nℤ[X]) is n but here ring isn't finite. char(ℤ/nℤ) is n and
ring is finite.</p>
<p>Characteristic of any field is either a prime number or 0: char(R) is
the smallest such n. if char(R)=n was composite, ab=0 =&gt; a=0∨b=0
(zero divisors. but they shouldn't be possible) which violates the
condition that n is the smallest such number.</p>
<p>Q by iteslf not part of R unless we do an
<strong>embedding</strong></p>
<p>Finite field =&gt; char(F) ≠ 0. Why?</p>
<ul>
<li>n1 = n2 in F</li>
<li>n1 - n2 = 0 in F</li>
<li>we can take char(F) to be n</li>
</ul>
<p>ℝ could be said to be an extesnon of ℚ ℂ extension of ℝ</p>
<p>Any finite field has to be an extension of some finite field Fₚ=ℤ/pℤ
where p is a prime.</p>
<p>Note: Functions which doesn't preserve structure =&gt; forgetful
maps. We don't bother about that here.</p>
<p>So the question is: What are the kinds of such extensions that can be
done? Aim: Completely characterize extensions (finite) of Fₚ where p is
prime.</p>
<p>Remember: char(ℤ/pℤ) = p</p>
<p>Irreducible polynomial in the F =&gt; we get an extension if we do
quotienting.</p>
<p>Fₚ/μ[X] where μ[X] is an irreducible polynomial in Fₚ.</p>
<p><strong>Every extension of the field Fₚ should be of cardinality pᵏ
where k∈ℕ\{0} (ie, a positive power of p).</strong> =&gt; every finite
field has cardinality as a power of a prime p.</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>sage: GF(<span class="dv">36</span>)</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="pp">ValueError</span>: the order of a finite field must be a prime power</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>sage: GF(<span class="dv">1</span>)</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a><span class="pp">ValueError</span>: the order of a finite field must be at least <span class="dv">2</span></span></code></pre></div>
<p>Consider,</p>
<p>(ℂ,+,ℝ⋅, )</p>
<p>where ℝ⋅ means multiplication only be with real. ie, ℝ⋅ℂ only.</p>
<p>Degree of a field extension.</p>
<p>Fun fact: Complex plane is a vector space. X: ℝ, Y-axis: 𝑖.ℝ ie, ℂ ≃
ℝ²</p>
<p>[ℂ:ℝ] is 2.</p>
<p>ie, [ℂ:ℝ] is the degree of the extension ℂ/ℝ.</p>
<p>Abstract vector space. It's something other than ℝ². Like a
<strong>vector space over a field K</strong>.</p>
<p>it's an additive abelian group: (V,+,0) Scalar multiplication is a
function: ⋅: k⨯V → V Scalar multiplication distributes over addition:
α(a+b)=αa+αb α(βα) = (αβ)α</p>
<p>(Velocity, acceleration =&gt; the field is ℝ.)</p>
<p><strong>Additive abelian group</strong> =&gt; normal abelian group
where operation is writen as + and identity is 0.</p>
<p><strong>Any field extension can be seen as a vector space over the
base field.</strong></p>
<p>L/K where L is an extension over K, degree of L is cardinality L can
be thought of a vector space over K.</p>
<p>Think of <code>⋅: K⨯L→L</code>.</p>
<p>Linear algebra stuff:</p>
<ul>
<li>Dimension</li>
<li>Linear independence</li>
</ul>
<hr />
<p>Consider S ⊆ V.</p>
<p>Linear dependence =&gt; There exists uᵢ∈S where i∈n and aᵢ∈K such
that</p>
<p>Σaᵢuᵢ = 0</p>
<p><strong>Basis</strong> B of a vector space V: Subset of the vector
space such that any element of the space can be written as a linear
combination of the elements of the basis.</p>
<p>ie,</p>
<ul>
<li>linearly indepenedent</li>
<li>B ⊆ V</li>
<li>∀v∈V, ∃cᵢ ∈ K such that v = Σcᵢbᵢ where bᵢ∈B</li>
</ul>
<p><strong>Span</strong> of V:</p>
<ul>
<li>set of all vectors which can be expressed as a linear combination of
elements in V.</li>
</ul>
<p>Operations like vector addition and scalar multiplication are defined
only for two elements. So infinite sums don't make sense.</p>
<p><strong>Dimension</strong> of a vector space = cardinality of the
basis of V.</p>
<p>A vector space is finite dimensional if it has finite basis.</p>
<p>:DBT: Do all basis of a vector space have to be of the same
dimension????</p>
<p>Fun fact: Infinite dimension vector space it's tricky.</p>
<p>Eg of finite dimesnional vector space: 3D space?? Eg of finite
dimesnional vector space: polynomals. A basis for a polynomial ring
could like [1,x,x²,….]</p>
<hr />
<p>A lemma: Any two basis of a vector space V should be of the same
cardinality (which is the dimension of that vector space).</p>
<p>Proof is easier for finite dimensional vector space.</p>
<p>degree of ℂ/ℝ is 2. ∵ [a, ib] ??</p>
<p>—</p>
<p>F₂/(X²+X+1) can be thought of as F₂(ω)</p>
<p>where ω is cube root of unity.</p>
<p>ω = X mod (X²+X+1) ω = X³ mod (X²+X+1) = X(X+1) - X²+X = 1</p>
<p>(ω²)³ = X²</p>
<p>F₂(ω)/F₂ is of degree 2.</p>
<p>—</p>
<p>What is the degree of ℝ/ℚ?</p>
<p>It's not a finte extension???</p>
<p>π is not an algebraic sth. It's a transcendental number. Cannot be
the solution of a polynomial.</p>
<p>ℚ(π) B = {1, π, π², .. } is linearly independent. Since π is
transcendental, a linear combination of it never results in zero.</p>
<p>—</p>
<p>ℚ(√2)/ℚ</p>
<p>Degree 2 ∵ (a+√2b) is a basis.</p>
<p>—</p>
<p>We know that Fₚ[X] is the polynomials over the finite field Fₚ.</p>
<p>Fₚ(x) is the set of rational 'functions' over Fₚ.</p>
<p>f(x) = —— g(x)</p>
<p>infinite =&gt; need an infintele linearly independent set.</p>
<p>1,x,x²,…</p>
<p>We would be dealing with fiinite extension. This was just a though
provoker.</p>
<p>HW: L/Fₚ is finite. How to find the cardinality of L? Find the degree
of L first, I guess.</p>
<p>Finite degree exension of Fₚ. First show that degree is finite.</p>
<p>—</p>
<h2 id="finite-fields-1">Finite fields</h2>
<ul>
<li>aka <strong>Galois fields</strong>.</li>
<li><strong>Order</strong> of a finite field: number of elements it has
got. <a href="https://mathworld.wolfram.com/FieldOrder.html">⁵</a></li>
</ul>
<p>ℚ, ℝ, and ℂ are fields. But they are infinite fields.</p>
<p><strong>Adjoin</strong>:</p>
<h1 id="tue-4"><span class="done DONE">DONE</span> [2023-02-21 Tue]</h1>
<p>Every finite field 𝔽 has a prime number as characteristic. F/Fₚ (F
over Fₚ) is a field extension.</p>
<p>General extensions: L/K (L is an extension of K)</p>
<p>[L:K] is the degree of L/K</p>
<p>L/K means L can be thought of as a vector space over K.</p>
<p>That means:</p>
<ul>
<li>Vector addition: field addition</li>
<li>Scalar multiplication: restriction L multiplication to the function
K⨯L→L</li>
</ul>
<p>[L:K] is the dimension of the vector space over K.</p>
<p>Eg:</p>
<ul>
<li>[ℂ: ℝ] is 2</li>
<li>[F₂[X]/X²+X+1 : F₂] is 2</li>
<li>[ℚ(√2): ℚ] is 2</li>
<li>[ℝ:ℚ] is ∞ ✗</li>
</ul>
<p>Infinite degree not that interesting (for us, at least).</p>
<p>Given,</p>
<ul>
<li>K: a field</li>
<li>g(X): an irreducible polynomial on K[X]</li>
<li>K[X]/g(X): smallest field containing a root of K[X]</li>
</ul>
<p>g(X) is irreducible. K[X] is a Euclidean domain =&gt; g(x)K[X] is a
maximal ideal.</p>
<p>:REM: Euclidean domain =&gt; all ideals are principal ideals.</p>
<p>Irreducible polynomial gives a maximal ideal.</p>
<p>Ring qutoitened with maximal idea =&gt; a field.</p>
<p>Ideals of R/a are ideals of R itself but that contain a.</p>
<p>In quadratic extensions (like that for ℂ), we got all roots when we
attached other roots as well. ∵ other root is also linear.</p>
<p>But this won't happen for all kinds of extensions.</p>
<p>Eg:</p>
<p>Given:</p>
<ul>
<li>K: field</li>
<li>g(X): irreducible polynomial in K[X]</li>
<li>K[X]/g(X) is the smallest field extension containing a root of
g(X)</li>
</ul>
<p>X³-2 ∈ ℚ[X]</p>
<p>It was in ℂ[X],</p>
<p>(X-∛2)(X-∛2ω)(X-∛2ω²)</p>
<p>Back to ℚ[X], X³-2 has no roots in ℚ[X]. ∵ ∛2 is irrational.</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>sage: Rational(real_nth_root(<span class="dv">2</span>,<span class="dv">3</span>))</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="pp">TypeError</span>: unable to convert <span class="dv">2</span><span class="op">^</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>) to a rational</span></code></pre></div>
<p>Attaching ∛2 to this won't get the other roots.</p>
<p>ℚ(∛2) ≅ ℚ[X]/X³-2</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>sage: QQ[real_nth_root(<span class="dv">2</span>,<span class="dv">3</span>)]</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>Number Field <span class="kw">in</span> a <span class="cf">with</span> defining polynomial x<span class="op">^</span><span class="dv">3</span> <span class="op">-</span> <span class="dv">2</span> <span class="cf">with</span> a <span class="op">=</span> <span class="fl">1.259921049894873</span>?</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 1.259921049894873? is ∛2</span></span></code></pre></div>
<p>ℚ(∛2) means smallest field containing ℚ and ∛2.</p>
<p>X³-2 does not split in ℚ(∛2). ie, not a splitting field.</p>
<p>—</p>
<p>We chose smallest field earlier. Why? What happens if the field had a
subfield.</p>
<p>Consider a field L which contains one of the roots of an irreducible
polynomail. L/K</p>
<p>:DBT: kernel of a map</p>
<p>Algebraically no difference, analysis might be able to (à la Cauchy
or something).</p>
<p>:DBT: Splitting field. Field with all roots??</p>
<p>—</p>
<p>What is the degree of ℚ[X]/X³-2 / ℚ</p>
<p>L: ℚ[X]/X³-2 Q: ℚ</p>
<p>What is the degree? ie, [L:Q]</p>
<p>A basis: {1, X, X²} So, [L:Q] is 2.</p>
<p>X³ is 2. So X³ is linearly dependent on the others.</p>
<p>NB: Degree is degree the quotienting term.</p>
<p>Basis terms not linearly independent =&gt; we get a smaller
polynomial. And we had started out saying irreducible??</p>
<p>L = K[X]/g(X)</p>
<ul>
<li>g(Y) ∈ K[Y] embedded in L[Y]</li>
<li>h(Y) ∈ K[Y] embedded in L[Y]</li>
</ul>
<p>gcd(g(Y), h(Y)) = h' then g(X) is no longer irreducible.</p>
<p>Finite field =&gt; attach 1 root =&gt; other roots follow binomial
theorem is easier there. Proofs are simpler. Just follow the
definition.</p>
<h1 id="thu-4"><span class="done DONE">DONE</span> [2023-02-23 Thu]</h1>
<p>g(x) ∈ K[X] is an irreducible polynomial in K[X]. Then K[X]/g(x) is
the smallest extension of K that contains a root of g(x).</p>
<p><strong>Splitting field</strong> of a polynomial: smallest field
containing all the roots of that polynomial.</p>
<p>In general, K[X]/g(x) will not be the splitting field of g(x).</p>
<p>Lemma: Let g(x) ∈ Fₚ[X] (a finite field) be an irreducible poly. Then
g(Y) completely splits in Fₚ[X]/g(x).</p>
<p>ie, unlike in the case of rationals, we get all roots.</p>
<p>Frobenius automorphism. σ: L → L σ(α) = αᵖ σFₚ = id (σ fixes
everything in the field F₆)</p>
<p>pCr is definitely divisible by p (provided p is prime??).</p>
<p>Let's prove the 'forward part'.</p>
<p>σ(a+b) = σ(a) + σ(b) (a+b)ᵖ = aᵖ + pC1.aᵖ⁻¹b + …. + bᵖ = aᵖ + bᵖ</p>
<p>Binomail theorem: σ preserves addition. σ preserved mult as well,
obviously.</p>
<p>∴ σ is homomorpism.</p>
<p>So:</p>
<p>σ(g(x)) = g(σ(x))</p>
<p>provided g(x) ∈ Fₚ[X]</p>
<p>g(α) = a₀ + a₁.α + … + aₙαⁿ =</p>
<p>Apply and you can get another root. Apply <em>that</em> and you get
next root (someimtes same root though)</p>
<p>it doesn't matter if you first eval the poly and apply α or the other
way. ∵ eval only involves addn and mult, which are preserved by σ.</p>
<p>automorphism =&gt; homomorphism from a field to itself.</p>
<p>Fermat's little theorem: αᵖ ≡ α (mod p)</p>
<p>Fₚ* = units of Fₚ \ {0}</p>
<p>We know that X mod g(X) is a root of g(Y).</p>
<hr />
<p>Last class, we saw that:</p>
<p>Degree of g(x) = n</p>
<p>[L : Fₚ[X]] = n</p>
<p>βᵢ where i∈</p>
<p>Linear combination of bases.</p>
<p>Cardinality of L: #L is pⁿ</p>
<p>Number of possible linear combinations with basis elements.</p>
<p>∵ finite field.</p>
<p>Units of a finite field F = F \ {0} ∵ every element other than 0 are
invertible.</p>
<p>F* = F \ {0}</p>
<table>
<tbody>
<tr class="odd">
<td>F*</td>
<td>= pⁿ-1</td>
</tr>
</tbody>
</table>
<p>Finite filed =&gt; char is finite infinite basis =&gt; field has ∞
elements =&gt; non-finite field =&gt; contradiction</p>
<p>—</p>
<p>Claim: β∈L, βⁿ - β = 0 βⁿ⁻¹ = 1</p>
<p>where n = |L|</p>
<p>This can heaooen only if it's a automorphism</p>
<hr />
<p>g(x) irreducible poly of dgeree n</p>
<p>L is an exension of degree n L = Fₚ[X]/g(x)</p>
<p>#L is pⁿ = k</p>
<p>β ∈ L βᵏ - β = 0</p>
<p>–</p>
<p>roots of polynomial are exactly the elmenets of L.</p>
<p>T(Y) = Yᵏ-Y T(β) = βᵏ-β = 0</p>
<p>Completely splits =&gt; splitting field.</p>
<p>gcd(g(x), Xᵏ-X) = h(x) but g is ireeducible. So, h(x) is g(x). ∴ all
roots of g are in L.</p>
<p>Unlike in the case of ℚ[x], finite field =&gt; attach one root =&gt;
we get all roots.</p>
<p>α<sup>p<sup>r</sup></sup> = α<sup>p<sup>s</sup></sup>
σʳ<sup>p<sup>r</sup></sup> = σˢ<sup>p<sup>s</sup></sup> =&gt;
α<sup>p</sup> - α = 0</p>
<p>Any finite field of size q can be seen a splitting field of the
polynomial X<sup>q</sup> - X</p>
<p>:HW:</p>
<pre><code>       k
┬─┬   ┬─┬
│ │   │ │       g(x)    =  X^{pⁿ} - X
d|n  g∈Irr(d,X)
</code></pre>
<p>where g is irreducible. d|n =&gt; d divides n.</p>
<p>Irr(d, X) = {g(x) ∈ Fₚ[X] where g is irreducible of degree d}</p>
<p>We can count how many irreducible poly of degree d are there. using
mobius inversion.</p>
<pre><code>          Fpⁿ

Fpᵈ

          Fp 
</code></pre>
<p>Fermat little theorem: αᵖ=α Legrange's theorem implies αᵖ⁻¹=1</p>
<p>Fixed polynomial, then all finite field extensions are essentially
isomorphic??</p>
<h1 id="thu-5"><span class="done DONE">DONE</span> [2023-03-02 Thu]</h1>
<p>In quiz, X²-1=0 in ℤ/15ℤ. has 4 roots. 4,11,1,-1 — Let g1(x) and
g2(x) be irreducible polynomials over Fp.</p>
<p>[L1:Fp] is same as degree of the polynomial. ie, d [L2:Fp] is same as
degree of the polynomial. ie, d</p>
<p>Then, #L1 = #L2 = pᵈ</p>
<p>Then that means they are the same field. Splitting fields of
X<sup>q</sup>-X.</p>
<p>This is not the case in ℚ. ∵ there the polynomial matters. Eg: X²-1
and X³-1</p>
<p>But in our case (ie, finite fields), we can attach a root of g1(x)
and still get roots of g2(x) as the remaining roots. ∵ of
isomorphism.</p>
<p>X<sup>q</sup>-X factorizes over Fp. How do we know that (:DBT:)</p>
<p>How to arrive at a splitting field?</p>
<p>Lesson: Any degree d extension is the same.</p>
<p>For each field Fₚ, there is a unique field extension GF(pᵈ).</p>
<pre><code>L = GF(pⁿ)
     │
     │
K = GF(pᵈ)
     │
     │
M = GF(p)
</code></pre>
<p>n|d. Why?</p>
<p>Let, [L:K] = d1 and [K:M] = d2</p>
<p>(tower of extensions: L/K/M)</p>
<p>[L:M] = [L:K] * [K:M]</p>
<p>b1, b2,.. b<sub>d1</sub> such that j1, j2,.. j<sub>d2</sub> such
that</p>
<p>n Σ i=0</p>
<p>Claim: {biji} is an M-basis for L</p>
<p>:DBT: How to show that a set of vectors are linearly independent.</p>
<p>Roots of X<sup>pⁿ</sup> - X is precisely the elements of GF(pⁿ)</p>
<p>Consequence:</p>
<pre><code>             ┬─┬  ┬─┬ 
X^{pⁿ} - X = │ │  │ │ f(X)
             d|n  f∈H
</code></pre>
<p>where H is the set of all irreducible polynomials in Fₚ of degree
d</p>
<p>Not all UFDs are PIDs, but all PIDs are UFDs.</p>
<p>Show RHS=LHS and LHS=RHS both apprcaches</p>
<p>Next up: Equal degree factoring</p>
<p>How to find all linear factors of f(X)=Fₚ[X]?</p>
<p>Repeated roots (ie, multiplicity&gt;1) can be taken care of by taking
derivitative??</p>
<p>Find a g(x) for which gcd(f,g) is non-trivial. Find gcd (Euclid's
algo is fast). Keep repeating. That g(x) is X<sup>pᵈ</sup>-X where d is
the desired degree.</p>
<p>But degree p polynomail. and p is probhibityely large. Not a great
soln. we can take time logp.</p>
<p>Well, how about</p>
<p>gcd(Xᵖ-X remainder f(x), f(x))</p>
<p>but won't get individual roots. <em>Porquoi</em>? :DBT:</p>
<p>:DBT: Repeated squaring. Binary exponentiation??</p>
<p>Calcing Xᵖ rem f(x): p=a0+a1.2+a2.2²+….</p>
<p>Find X, X², X⁴ sepretaly mod f(x)</p>
<p>and somehow on prends cette:</p>
<p>k Π X² = Xᵖ i=0</p>
<p>Donc, how to find quadratic roots (we're builidng towards a way to
find roots of any degree):</p>
<p>One could write f(x) = f1(x) * f2(x) * …</p>
<p>where fi(x) are the product of degree i factors of f(x)</p>
<p>distinct degree factorization algorithm</p>
<p>Splitting field and Xᵖ-X is what helped us arrive at it.</p>
<p>These algo all require only polynomial time ∵ it involves just gcd
computation.</p>
<p>Formal derivative non-zero =&gt; no multiple roots.</p>
<p>h(x) = f/(all factors taken care of so far)</p>
<p>Product of polynomails will be the rsult. Consists of irreducible
factors of the same degree.</p>
<p>next class:</p>
<ul>
<li>Cantor-Zassenhaus algorihm</li>
<li>Equal degree factorization</li>
</ul>
<h1 id="tue-5"><span class="done DONE">DONE</span> [2023-03-07 Tue]</h1>
<h2 id="square-free-polynomial-ʷ">Square-free polynomial <a
href="https://en.wikipedia.org/wiki/Square-free_polynomial">ʷ</a></h2>
<p>A polynomial over a field that doesn't have the square of a
non-constant polynomial as a factor.</p>
<p>Every non-zero polynomial admits a square-free factorization, which
is unique upto multiplication and division of factors by a non-zero
constant.</p>
<p>Square-free polynomial is easier to calculate than complete
factorization of the polynomial.</p>
<p>Example:</p>
<p>x²+3x+2 is square free.</p>
<pre><code>x²+3x+2 = (x+1)(x+2)
</code></pre>
<p>but x³-x²+1 isn't:</p>
<pre><code>x³-x²+1 = (x-1)²(x+1)
</code></pre>
<p>Note that the square-free polynomials factors aren't evident from its
appearance. Factorization should to find the factors. We could tell (at
least in the case of univariate polynomials) that there are no repeating
roots if the polynomial is square-free.</p>
<p>Process of converting polynomial to square-free form: square-free
decomposition <a
href="https://people.eecs.berkeley.edu/~fateman/282/F%20Wright%20notes/week6.pdf">ⁿ</a>.</p>
<p>From <a
href="https://people.eecs.berkeley.edu/~fateman/282/F%20Wright%20notes/week6.pdf">here</a>:</p>
<table>
<thead>
<tr class="header">
<th>Polynomial</th>
<th>Square-free</th>
<th>Irreducible</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x²+3x+1</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td>x²+3x+2 = (x+1)(x+2)</td>
<td>✓</td>
<td>✗</td>
</tr>
<tr class="odd">
<td>x²+2x+1 = (x+1)(x+1)</td>
<td>✗</td>
<td>✗</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb83"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>sage: R.<span class="op">&lt;</span>x<span class="op">&gt;=</span>PolynomialRing(ZZ)</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>sage: factor(x<span class="op">^</span><span class="dv">2</span><span class="op">+</span><span class="dv">3</span><span class="op">*</span>x<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span><span class="op">*</span>x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>sage: factor(x<span class="op">^</span><span class="dv">2</span><span class="op">+</span><span class="dv">3</span><span class="op">*</span>x<span class="op">+</span><span class="dv">2</span>)</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>(x <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> (x <span class="op">+</span> <span class="dv">2</span>)</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>sage: factor(x<span class="op">^</span><span class="dv">2</span><span class="op">+</span><span class="dv">2</span><span class="op">*</span>x<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>(x <span class="op">+</span> <span class="dv">1</span>)<span class="op">^</span><span class="dv">2</span></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a>sage: factor(x<span class="op">^</span><span class="dv">2</span><span class="op">+</span><span class="dv">7</span><span class="op">*</span>x<span class="op">+</span><span class="dv">6</span>)</span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a>(x <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> (x <span class="op">+</span> <span class="dv">6</span>)</span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Square-free</span></span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true" tabindex="-1"></a>sage: factor(x<span class="op">^</span><span class="dv">5</span><span class="op">+</span><span class="dv">2</span><span class="op">*</span>x<span class="op">^</span><span class="dv">4</span><span class="op">-</span>x<span class="op">^</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb83-15"><a href="#cb83-15" aria-hidden="true" tabindex="-1"></a>x<span class="op">^</span><span class="dv">5</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>x<span class="op">^</span><span class="dv">4</span> <span class="op">-</span> x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb83-16"><a href="#cb83-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Irreducible..</span></span></code></pre></div>
<h2 id="cantor-zassenhaus-algorihm">Cantor-Zassenhaus algorihm</h2>
<p>Input: A square-free polynomial <code>f</code> whose irreducible
polynomial factors are all of the <em>same degree</em>.</p>
<p>Output: Either that f is irreducible or a non-trivial factor of it
(can be applied again and again to get all factors).</p>
<p>How can we know that they are all of same degree though? Got to do
<em>distinct degree factoring</em>.</p>
<p>f is defined over a finite field GF(p).</p>
<p>Input size: n.log|p|</p>
<p>To make f square-free, we define formal derivative of a polynomial.
Which is kinda like the 'usual' derivative.</p>
<p>Xⁿ ↦ nXⁿ⁻¹</p>
<p>For any ring, <code>n</code> is defined.</p>
<p>:DBT: Are there infinite rings?</p>
<p>Proof of product rule of formal derivative:</p>
<pre><code>(uv)&#39; = uv&#39; + u&#39;v&#39;

u     =  Σuᵢxⁱ
v     =  Σvᵢxⁱ
uv    =  Σuᵢvⱼxⁱ⁺ʲ
(uv)&#39; =  Σ(i+j)uᵢvⱼXⁱ⁺ʲ⁻¹
      =  ΣiuᵢvⱼXⁱ⁺ʲ⁻¹  +  ΣjuᵢvⱼXⁱ⁺ʲ⁻¹

QED
</code></pre>
<p>We make it square-free ∵ otherwise gcd() is readily an uninteresting
value.??? What if f' is 0????</p>
<p>f = Σaⁱxⁱᵖ = Σ(aᵢxᵢ)ᵖ</p>
<p>factrorize =&gt; find something else (without resoriting to
factorization) that has a non-trivial gcd with f. C'est le
stratégie.</p>
<p>—</p>
<p>Equal degree factorization</p>
<p>We made it square-free. Now let's make the factors? of same
degree.</p>
<p>Let's say f is:</p>
<p>f = f1 + f2 + … + fn</p>
<p>where all fᵢ are of degree i.</p>
<p>Repeated squaring. X<sup>pᵏ</sup> mod n find x, x², x⁴ mod n</p>
<p>— Is a polynomial is rreducible (like checking if a num is
prime):</p>
<p>gcd(f,f') non-trivial =&gt; irreducible</p>
<p>find all gcd. all 1 =&gt; irreducible.</p>
<p>— How to check whether it has a root? No need to find the root (it's
as difficult as factoring). Has a root =&gt; has a linear factor.</p>
<p>— :DBT: Square-free. Whevenever there is a square =&gt; problem. Why?
—</p>
<p>Now we got all factors to be of the same degree ???</p>
<p>f = Π gᵢ i=0</p>
<p>We know the degree of each irreducible factor. We know how many of
them are there??</p>
<p>What if splits completely? All irreducible are linear factors? x-a *
x-b * x-c …</p>
<p>Turns out that factoring is equaivalent to finding roots.</p>
<p>The algo we gonna see is not deterministic algo (like for fdining
irreduciblity), but a rnadomized algo.</p>
<p>—</p>
<p>f = g1 * g2 * …. * gn</p>
<p>(all the gi are irreducible)</p>
<p>CRT means,</p>
<p>GF(p)[X]/f =~ GF(p)[X]/g1 * GF(p)[X]/g2 * … * GF(p)[X]/gn</p>
<p>(Computatiion is in LHS, but analyais is in RHS)</p>
<p>At this point we don't know what gi are.</p>
<p>(a<sup>pᵈ-1</sup> is 1.)</p>
<p>Assume p is odd. p even case is an exercise.</p>
<p>—</p>
<p>non-invertible =&gt; do gcd and we got a factor???</p>
<p>Find 'non-trivial' square root of 1 in the LHS ring and we're done.
(How??)</p>
<p>gcd(α-x) ???</p>
<p>det algo if 𝑂(np) time randized algo if 𝑂(n.logp) time</p>
<h1 id="tue-6"><span class="done DONE">DONE</span> [2023-03-09 Tue]</h1>
<p>We made the polynomial:</p>
<ul>
<li>square free
<ul>
<li>gcd(f,f') is sth.., where f' is formal deriv of f</li>
</ul></li>
<li>distinct degree factored
<ul>
<li>f = Πfi, where fi is the product of all irreducible factors are of
degree i</li>
<li>ie, f=g1.g2..gl</li>
</ul></li>
</ul>
<p>We know that n=dl ∵ it's a polynomial. But we don't know the gi
Remember RHS for just analysis for our sake.</p>
<p>GF(p)[X]/f(x) -~ GF(p)[X]/f1(x) ⨯ GF(p)[X]/f2(x) ⨯ .. ⨯
GF(p)[X]/fl(x)</p>
<p>Corresponding relation should?? hold in the unit rings as well.</p>
<p>zero divisor =&gt; we got a factor ✓. Iteration over. Otherwise we
got to do ore work.</p>
<p>forall α ∈ GF(p)[X]/f(x). Randomly pick an α. (that's why
Cantor-Zassenhaus is a randomized algorithm)</p>
<p>We can tell that (how??): α<sup>pᵈ-1</sup> = 1</p>
<p>then for d=odd,</p>
<p>β = α<sup>(pᵈ-1)/2</sup> is a square root of unity. (calced by
repeated squaring =&gt; P time)</p>
<p>We know of 2 square roots of 1: 1 and -1</p>
<p>it's a ring can have more roots unlike felds.</p>
<p>trivial square root of 1: 1 and -1 We are interested in non-trivial
roots.</p>
<p>if β is neither 1 nor -1 in GF(p)[X]/f(x), β-1 is a zero divisor.</p>
<hr />
<p>Analysis: ∀k.</p>
<p>Let's say k = (pᵈ-1)/2</p>
<p>G = GF(p)[X]/f(x)* with multplication as operation.</p>
<p>φ: G → G φ(x) = xᵏ</p>
<p>φ is a homomorphism. ie, φ(x.</p>
<p>:DBT: Kernel of a map Ker(φ) = {x∈G | φ(x)=1}</p>
<p>Ker is a subgroup. Proof?</p>
<p>Our 'bad' events are when α ∈ {1,-1} Let's forget about -1 for now. α
picked outside the kernel with at least 1/2 probability =&gt; we're
cool.</p>
<p>Non-trivial kernel: means kernel is not the entire group.</p>
<pre><code>+------------+           +------------+
|            |           |            |
|  +------+  |           |            |
|  | Ker  |--------------------1      |
|  +------+  |           |            |
|            |           |            |
+------------+           +------------+
</code></pre>
<p>Sub-group's order divides the size of the group.</p>
<p>Let's now consider one compoenent.</p>
<p>GF(pᵈ)</p>
<p>elements of which which are roots?? of <code>X^{p^d} - 1</code> which
are pᵈth roots of unity.</p>
<p>Primitive nth orots of unity generator in ℂ. ζ=e<sup>2πi/n</sup>
???</p>
<p>n divisble p =&gt; not gonna work out too well but p<sup>d</sup>
stuff means that won't happen???</p>
<p>Lemma: GF(pᵈ)* is a cyclic group of order pᵈ-1. There exists a ζ such
that every element of GF(pᵈ)* are generated by ζ. ie, every element of
GF(pᵈ)* is a power of ζ.</p>
<p>at least with 0.5 probab we won't get all 1 ??? (whatever that
means??)</p>
<p>Bad event=&gt; fall inside the kernel of our chosen map.</p>
<p>—</p>
<p>Earlier we had ignored the -1 part. Now let's take care of that.</p>
<p>Kernel is half actually?? (Why??) Kernel is codomain 1. the rest is
codomain 1.</p>
<p>a function ψ:G→H get one elem such that ψ(xₕ) ∈ H =&gt; mult with
coset? ?????</p>
<p>Okay, kerenel is exact half (of the group??)</p>
<p>bad event =&gt; all 1 or all -1 got l components Choices 1/-1
Probability of bad events = 2 * 1/2<sup>l</sup> =&gt; Probability of
good events = 1 - 2 * 1/2<sup>l</sup> = 1 - (1/2<sup>(l-1)</sup>)</p>
<p>if l≥2, then probability 0.5</p>
<p>—</p>
<p>:HW: taking Trace polynomial of α ℂ beng a cyclic group clear from
the way they are constructed.</p>
<p>—</p>
<p>Next class:</p>
<ul>
<li>Berlekamp's factorization algo</li>
<li>No need of equal degree factorization</li>
</ul>
<h1 id="tue-7"><span class="done DONE">DONE</span> [2023-03-14 Tue]</h1>
<p>Cantor-Zassenhaus was like all factors same degree and we knew that
degree. q?? is 1 or -1 with equal probability. So we knew it would end
up as either 0 or -2=2.</p>
<h2 id="berlekamps-algorithm">Berlekamp's algorithm</h2>
<ul>
<li>No need of distinct degree factors.
<ul>
<li>Factors may be of different degrees.</li>
</ul></li>
<li>Polynomial still needs to be square-free?</li>
</ul>
<p>DBT: What makes non-squarefreeness a problem?</p>
<ul>
<li>Makes gcd(f,f') non-trivial. Now how's that a problem??</li>
</ul>
<p>Input:</p>
<ul>
<li>f(X) ∈ GF(p)[X], where f is square-free</li>
</ul>
<p>Output:</p>
<ul>
<li>Factors of f(X)</li>
</ul>
<p>f can be written as:</p>
<p>f = f1.f2…..fm</p>
<p>where each fi is a distinct irreducible factor of f.</p>
<p>Note that we don't know what the fi-s are. Unlike in the case of
Cantor-Zassenhaus.</p>
<p>Then from CRT, we can say that</p>
<p>GF(p)[X]/f = GF(p)[X]/f1 . GF(p)[X]/f2 ….. GF(p)[X]/fm</p>
<p>GF(p<sup>d1</sup>) . ….</p>
<p>Common sub-field is GF(p) ie, Fₚ.</p>
<p>Now see what is there in CRT that looks like Fₚ ⨯ Fₚ ⨯ .. ⨯ Fₚ</p>
<p>Let di be the degree of fi.</p>
<p>Let n be the degree of f.</p>
<p>n = d1.d2…dm</p>
<p>In a field, binomial theorem tells us that:</p>
<p>(X+Y)ᵖ = Xᵖ+Yᵖ</p>
<p>∵ all other terms are multiple of p which turns out to be 0 since
it's a ring till p.</p>
<p><strong>Berlekamp sub-algebra</strong> = B: is the subset of R that
maps to Fₚ ⨯ Fₚ ⨯ .. ⨯ Fₚ from CRT.</p>
<p>Find basis for B. :DBT: mais porqoui.</p>
<p>power it p</p>
<p>Assume p is odd prime Not interested in 1 and -1. in B??</p>
<p>gcd(α⁽ᵖ⁻¹⁾/2</p>
<p>Quite similar to Cantor-Zassenhaus except that α is randomly chosen
from the Berlekamp sub-algebra B.</p>
<p>If f completely splits in B, B is R itself. Completely split =&gt;
all factors are linear. But this is a special case.</p>
<p>We need a way to get hold of the Berlekamp subalgebra B. I want the
basis of B.</p>
<p>We got something like</p>
<p>GF(p)[X]/f(X) = GF(p<sup>d1</sup>) ⨯ GF(p<sup>d2</sup>) ⨯ … ⨯
GF(p<sup>dm</sup>)</p>
<p>But how would we represent a field extension? Field together with a
basis? Give an irreducible polynomial. But of what degree?? If GF(pᵈ) is
to be made from GF(p) we give a irreducible poly of degree d.</p>
<p><strong>Structure constants</strong> aother way to specify field
extension.</p>
<p>In the end what we care about are the filed operations: addn, multn,
etc</p>
<p>Given vector space's basis: βᵢ</p>
<p>∀i,j βᵢ.βⱼ = ΣCᵢⱼₖβₖ</p>
<p>where Cᵢⱼₖ ∈</p>
<p>Okay, how do we compute B?</p>
<p>:DBT: Subspace?? Means sub-vector space</p>
<p>Catoegry theory: forgetful structures???</p>
<p>:DBT: Ignore mult and ering is a vector space???</p>
<p>Is B a sub-space?</p>
<blockquote>
<p>We're interested in the bad guys. Bad people gve interesing sotriesn
bgood people give boring stories.</p>
</blockquote>
<p>Addn of B continues to be in B. What about multn?</p>
<p>:DBT: Is GF(p) ⊂ GF(p<sup>d</sup>) ?? They are isomorphic for sure
though.</p>
<p>B is a vectorspace.</p>
<p>Then to get hold of B, we need to find its basis.</p>
<p>What could be dimension of B? m because we just said it's like Fₚ ⨯
Fₚ ⨯ .. ⨯ Fₚ in the setting of CRT.</p>
<p>So we got find m values which are linearly independent to find basis
for B.</p>
<p>We just need random elements of Berlekamp sub-algebra in our quest to
factorize the original f.</p>
<p>Tip: Get familiar with the definitions of this course. Everything
else would flow naturally.</p>
<p>To take random elements in B, it's sufficient to have the basis of B.
:DBT: Why??</p>
<p>Dimension of R is d1 + d2 + .. + dm A basis for R?? : 1 + X + X² + …
Xⁿ⁻¹</p>
<p>Getting the basis can also produce a sampling procedure. I guess we
can make a sampling procedure if we know the basis.</p>
<p>Computing the basis of B is usually the costliest operatioin here??
:SIRWONDERING: Could there be another way?</p>
<p>:SIRWONDERING: Why should all commutative rings over GF(p) be
polynomials???</p>
<p>We need a way to characterize B in a way other than using CRT.
Because the CRT version is good only for analysis??.</p>
<p>—</p>
<p>Suppose we are given structure constnats (as a representation of
Fₚ).</p>
<p>roots of X<sup>p</sup>-X are the elements of Fₚ.</p>
<p>Finite fields =&gt; THere is only one map: Frobenius map Think of it
as acting on vector space coreresponding to field and then we can say
it's a linear map. σ(α) = σᵖ σ(α+β) = σᵖ + βᵖ</p>
<p>Info: Ker(Frobenius map) contains only 0.</p>
<p>Berlekamp subalgebra is the kernel of (σ-I) where σ is the Frobenius
map. No it's a linear alebra problem Make matrix. find null space??
Gaussian elim. Compute basis for kernel.</p>
<p>ie, computing B is a linear algebra problem.</p>
<p>Next class:</p>
<ul>
<li>We'll finish Berlekamp factoring algo</li>
</ul>
<h1 id="thu-6"><span class="done DONE">DONE</span> [2023-03-16 Thu]</h1>
<p>:DBT: B is a sub-algebra of R. R is a ring =&gt; B is a
sub-ring??</p>
<p>α ∈ᵣ Fₚ ⨯ Fₚ ⨯ .. ⨯ Fₚ</p>
<p>αᵖ⁻¹ = 1 ie, αᵖ = α ie, αᵖ - α = 0 Looks familiar, right? :) ie,
Fₚ</p>
<p>Now we got to find a basis for B.</p>
<p>B 'sits insdie' R.</p>
<p>Think of R as a vector space over B.</p>
<p>We can show that B is a subspace.</p>
<p>Frobenius map is a linear map (in some sense). It's Fₚ-linear. ie,
wehn we tjoml pf R as a vector space over __?</p>
<p>We can say that B is kernel of (σ-I) where I is identity.</p>
<p>If there is a map T between two vector spaces V and U, T:V→U that
means we know the bases of both V and U??</p>
<p>Trivial =&gt; things that are to be expected. 1 and -1 are trivial
square roots of 1.</p>
<p>V: basis of lenght n U: basis of lenght m m &lt; n =&gt; non-trival
kernel for sure Linear map T exists means there coeff tᵢⱼ such that</p>
<p>m T vᵢ = Σ tᵢⱼuⱼ j=1</p>
<p>⎡ _ _ .. _ ⎤ ⎡ X₁ ⎤ ⎡ 0 ⎤ ⎢ _ _ .. _ ⎥ ⎢ X₁ ⎥ = ⎢ 0 ⎥ ⎢ _ _ .. _ ⎥ ⎢
X₁ ⎥ ⎢ 0 ⎥ ⎣ _ _ .. _ ⎦ ⎣ X₁ ⎦ ⎣ 0 ⎦</p>
<p>⎡ _ _ .. _ ⎤ ⎡ X₁ ⎤ ⎡ 0 ⎤ ⎢ _ _ .. _ ⎥ ⎢ X₁ ⎥ = ⎢ 0 ⎥ ⎢ _ _ .. _ ⎥ ⎢
X₁ ⎥ ⎢ 0 ⎥ ⎣ _ _ .. _ ⎦ ⎣ X₁ ⎦ ⎣ 0 ⎦</p>
<p>to find the kernel.</p>
<p>:FINDOUT: Gauss-Jordan elimination ⎡ 1 0 a ⎤⎡ X₁ ⎤ ⎡0⎤ ⎢ 0 0 b ⎥⎢ X₂
⎥ = ⎢0⎥ ⎣ 0 0 0 ⎦⎣ X₃ ⎦ ⎣0⎦</p>
<p>⎡ 1 0 a ⎤⎡ 0 ⎤ ⎡0⎤ ⎢ 0 0 b ⎥⎢ 1 ⎥ = ⎢0⎥ ⎣ 0 0 0 ⎦⎣ 0 ⎦ ⎣0⎦</p>
<p>So [0 1 0]ᵀ is in kernel of this linear map.</p>
<p>Nullity determinaton Rank=2 =&gt; dimension=1 ?? Rank+nullity = total
dimension nullity = total dim - rank</p>
<p>Point is, it reduces to linear equation solution problem.</p>
<p>Computing kernel =&gt; find k many linear indep non-trivial
solutions.</p>
<p>Convert linear map to its matrix equiv. Then we can use linear
algebra.</p>
<p>V = R = Fₚ[X]/f(X) = U</p>
<p>So the map σ is from R to R.</p>
<p>Basis: 1 + X + X² + … Xⁿ⁻¹</p>
<p>n=deg(f)</p>
<p>Got to find the matrix transofrmation of σ.</p>
<p>We got to find the tᵢⱼ such that</p>
<p>σ(1) = 1ᵖ = 1</p>
<p>So t₁ⱼ = 0 unless j=1 where it's 1.</p>
<p>xmodp as a polynomial: coeff are tᵢⱼ Xᵖmod f where Xᵖ is found by
repeated squaring.</p>
<p>n-1 Xᵖmod f = Σ aᵣXʳ r=0</p>
<p>these aᵣ are t₂ⱼ</p>
<p>For t₃ⱼ likiwise do</p>
<p>n-1 (X²)ᵖmod f = Σ aᵣXʳ r=0</p>
<p>We eventually find the basis for B. So that we can now find random
elements of B as value of α. Picked uniformly at random.</p>
<p>b₁,b₂,..,bₘ = basis of B</p>
<p>a₁,a₂,..,aₘ ∈ᵣ Fₚ</p>
<p>α = aᵢbᵢ</p>
<hr />
<p>Non-trivial zero divisors always mean factors.</p>
<p>All non-zero =&gt; all invertible =&gt; invertible overall. Some
zero, some non-zero = interesting case</p>
<p>nth root of unity. And the ζ.</p>
<p>:FINDOUT: Cyclotomic polynomial.</p>
<p>π(x-ζ) ∈ ℂ[X]</p>
<p>can be shown sth in ℤ[X] take modp polynomial =&gt; finite field Fₚ
polynomial??</p>
<p>ζ corresponds to 2π/n other primitive? roots of unity are 2πk/n where
k and n are coprimes.</p>
<p>(This is a special <code>e^(2πik/n)</code> case of with i=1)</p>
<p>Cicle anology.</p>
<p>commo=&gt; primitive n/dth sth..</p>
<p>ζ primitive nth orot of unit ζⁿ = 1 ζᵈ = 1 means d divides n.</p>
<p>algebra is a ring that's also a vector space.</p>
<p>:HW: Write a prog to print nth cyclotomic polynomial</p>
<h1 id="tue-8"><span class="done DONE">DONE</span> [2023-03-21 Tue]</h1>
<p>We now come to direct applications of things that we have been
discussing.</p>
<p>Let's start with cyclic codes.</p>
<pre><code>                                   Decoded                        No
          +---------+  +---------+   msg   +---------------+  err
Sender -&gt;-| Encoder |  | Decoder |----&gt;----| Err detection |---&gt;--- Receiver
          +---------+  +---------+         +---------------+          |
               |            |                     |                   |
       Encoded |            |                     V Error             Λ
       message |            Λ                     |                   |
               V            |              +----------------+         |
               |       +----------+        | Err correction |----&gt;----+
               +--&gt;----| Channel  |        +----------------+    
                       +----------+               |
                            Λ                     V
                            |                  Discard
                            |
                          Noise
</code></pre>
<p>Noise can creep and data can get corrupt.</p>
<p>We need two things:</p>
<ul>
<li>Detect errors if any error crept into the message</li>
<li>Correct errors if possible.</li>
</ul>
<p>One way to achieve these two goals is to add redundancy.</p>
<p>For example, instead of 0 and 1, we may send 000 and 111. Receiver
examines the data and chooses the majority value.</p>
<p>This is a <a
href="https://en.wikipedia.org/wiki/Repetition_code">repetition
code</a>.</p>
<ul>
<li>The message is merely repeated a few times.</li>
</ul>
<p>Advantage:</p>
<ul>
<li>Easy to implement</li>
<li>Code rate can be adjusted to varying channel capacity. <a
href="https://en.wikipedia.org/wiki/Repetition_code">ʷ</a> (but
how??)</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li>Low code rate</li>
<li>Limited error correction</li>
</ul>
<p>:DBT: Authenticity of message doesn't matter? What if corrupt message
end up being a codeword? Eg: John becomes Joan?</p>
<ul>
<li>'Shannon-way': Probability based</li>
<li>'Hamming-way'</li>
</ul>
<p>Let's look at the 'Hamming way' of doing things.</p>
<p>Alphabet: Σ</p>
<ul>
<li>Smallest possible data being sent/received</li>
<li>Typically we choose F₂. ∵ then we deal with only 0 and 1.</li>
</ul>
<p>Relevant paramaters of a code:</p>
<ul>
<li>block length n</li>
<li>distance</li>
<li>dimension</li>
</ul>
<p>A code word ∈ Σⁿ</p>
<p>Block codes.</p>
<p>Block length: n</p>
<p>Words of length n:</p>
<p>Code: of size n ⊆ Σⁿ</p>
<p>Each message being sent is an element of C</p>
<p>In the repetition code above:</p>
<ul>
<li>n = 3</li>
<li>C = {000, 111}
<ul>
<li>#C = 2</li>
</ul></li>
<li>Σ = {0,1}</li>
</ul>
<p>Sender will only send one of the values in C. No random code words.
That's agreed between sender and receiver.</p>
<p>lg =&gt; log₂</p>
<p>Here, lg(#C) is 1.</p>
<p>With this code, I can communicate one bit of info at a time. ie, by
sending one of the code-words.</p>
<table>
<thead>
<tr class="header">
<th>Info</th>
<th>Communicated size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>000</td>
<td>0 bits</td>
</tr>
<tr class="even">
<td>number ends with 1</td>
<td>2 bits</td>
</tr>
<tr class="odd">
<td>100 is gonna win</td>
<td>3 bits</td>
</tr>
</tbody>
</table>
<p>So, lg(#C) is the 'size' of info that was actually communicated.</p>
<p>Rate = info communicated by sending n bits = lg(#C)</p>
<p>Actually sending n bits, but its effect is only lg(#C). We get only
that much info. This is the η of the code.</p>
<p>C is just one word =&gt; rate = 0. We are no more wiser by receiving
that code. No clarity improvement. It's as good as we didn't get that
message. Doesn't clear anything up.</p>
<p>BCH code:</p>
<ul>
<li>not so optimal, but works</li>
</ul>
<hr />
<p>Hamming distance = d d(C) = Minimum distance between two words x and
y in the code</p>
<p>d(x,y) = number of locations in which x and y differ</p>
<p>d(x,x) = 0 d(x,y) ≤ n</p>
<p>Now we gonna look at how many bits got corrupt in a transmission.</p>
<p>Suppose channel can corrupt atmost t bits.</p>
<p>d(x,y) ≤ t</p>
<p>When is it possible to detect error?</p>
<p>We are faced with two possibilites:</p>
<ul>
<li>only check for error and ask retransmission if needed</li>
<li>detect and correct errors.</li>
</ul>
<p>Detect errors: d-1 errors Correct errors: (2t+1) ≤ d</p>
<p>d-1 errors easily provable. ∵ distance = d what the receiver gets
won't be a code word.</p>
<p>Now to the 2t+1≤d case:</p>
<ul>
<li>if it's</li>
</ul>
<p>Remember that d(x,y) is a metric. ie,</p>
<ul>
<li>d(x,x) = 0</li>
<li>d(x,y) = d(y,x)</li>
<li>d(x,y) + d(y,z) ≥ d(x,z) (ie, triangular inequality)</li>
</ul>
<p>Hamming sphere. With code blocks in it.</p>
<p>B(x,t) B(y,t)</p>
<p>/\ ≤t / \ ≤t / \</p>
<p><del>——</del> 2t</p>
<p>Take the received code word and find the nearest neighbour. That is
the error correction. Nearest neighbourhood decoding.</p>
<p>The sphere = possible words that are to be mapped to the code word at
the centre of the sphere. 2t+1 ≤ d mean no intersection. This follows
from the fact that d is a metric space.</p>
<p>This is inefficient. Polynomial length of code instead of the info
being sent. ie, linear to size of code (instead of size of info being
sent). It should've scaled to lg(#C)</p>
<p>(Figuring out suitable codewords given a d is a challenge.)</p>
<p>We need to find more structured sets (not sure what that
means..).</p>
<p>Σ = Fₚ (usually F₂) Inseado of arbitrary subs-set ,, we;re gonna take
sub-spaces (meaning vector spaces??) of GF(pⁿ)</p>
<p>sub=space is V dim(V) = k k ≤ n dimension is k =&gt; cardinality
pᵏ</p>
<p>Rate of code lg pᵏ = k (if p=2)</p>
<p>rate = k/n</p>
<p>Hamming weight = w(x) = d(x,0) = {i | i≠0}</p>
<p>d(x,y) = w(x-y) xᵢ and yᵢ same =&gt; x-y = 0 otherwise non-zero.</p>
<p>x,y∈V =&gt; x-y∈V</p>
<p>All elements in V are code words</p>
<p>0 is also a cod word.</p>
<p>Linear code.</p>
<p>d(V) = min{(d(x,y) | x,y∈V and x≠y}</p>
<p>= min{w(x) | x≠0, x∈V}</p>
<hr />
<p>Very fast algorithm to detect errors.</p>
<p>Can define V with n-k different vector equations?? Instead of giving
the basis.</p>
<pre><code>       n
h₁(x) = Σ h₁ᵢxᵢ
      i=0

       n
h₂(x) = Σ h₂ᵢxᵢ
      i=0

...
...

          n
hₙ₋ₖ(x) = Σ hₙ₋ₖᵢxᵢ
         i=0
</code></pre>
<p>where hᵢ-s are linearly independent??</p>
<p>Such that all these n-k equations are zero when x∈V.</p>
<p>Could think of this as a matrix (n-k ⨯ n matrix??).</p>
<p>This is the <strong>parity check matrix</strong>.</p>
<p>If all these are zero for an x, then it's a code word.</p>
<p>So error detection is as simple as applying the parity check
matrix.</p>
<p>Unlike in ℝₙ where orthognal means only 0, finite fields there are
other ways.</p>
<p>Eg: two 1 elements in a vector =&gt; inner product 0 =&gt; vector is
orthogonal to itself.</p>
<p>Parity check matrix is the basis for the orthognal fields of
sth????</p>
<p>Correction is difficult (unachievalbe) even for linear codes… Next
class we'll look further.</p>
<h1 id="thu-7"><span class="done DONE">DONE</span> [2023-03-23 Thu]</h1>
<p>Recap..</p>
<p>Linear code</p>
<ul>
<li>Just a sub-space of GF(pⁿ)</li>
<li>Can construct parity check matrix H by picking a basis for the
code</li>
</ul>
<p>Code is t-correctable. ie, can correct errors of at-most t-bits.
Original message = xᵢ (where i∈[1,k]) Basis of the linear code C = bᵢ
Encoded message is y=Σxᵢbᵢ which will be a code word in C Receiver gets
y and checks if H⋅y is 0</p>
<ul>
<li>If H⋅y=0, message has not been corrupted.</li>
<li>else we got to see if we can correct the error.</li>
</ul>
<p>Error vector = e = y - x weight of e = w(e) ≤ t (as we assume that
there is at most t errors) Sent x, but got x+e</p>
<p>H⋅(x+e) = H⋅x + H⋅e</p>
<p>∵ scalar multiplication of a matrix is distributive over addition. <a
href="https://www.khanacademy.org/math/precalculus/x9e81a4f98389efdf:matrices/x9e81a4f98389efdf:properties-of-matrix-addition-and-scalar-multiplication/a/properties-of-matrix-scalar-multiplication">¹¹</a>
ie, M(a+b) = M⋅a + M⋅b</p>
<p>Now we know that H⋅x=0 since x is definitely a code word of C.
So,</p>
<p>H⋅(x+e) = 0 + H⋅e H⋅(x+e) = H⋅e</p>
<p>This H⋅e is known as the <strong>syndrome</strong>.</p>
<p>But to find e, we need to know x. That's not generally easy. But
easier with BCH, I guess. We'll see.</p>
<h2 id="cyclic-code">Cyclic code</h2>
<p>A linear code such that if (w0, w1, …, wn-1) are code words, then so
is (wn-1, w0, w1, …, wn-2).</p>
<p>'the space of code words is invariant under cyclic shifts'. <a
href="https://www.cmi.ac.in/~ramprasad/lecturenotes/comp_numb_theory/alllectures.pdf">¹²</a></p>
<p>From <em>Fundamentals of error-correcting codes</em>:</p>
<blockquote>
<p>A linear code C of lenght n over Fₚ is cyclic provided that for each
vector c=c0…cn-2.cn-1 ∈ C, the vector cn01.c0..cn-2 obtained from c by
the cyclic shift of coordiantes i↦i+1(mod n) is also in C.</p>
</blockquote>
<p>Codewords in cyclic codes are usually represented as polynomials.</p>
<p>As in c = c0.c1….cn-2.cn-1 becoming c(x) = c0 + c0x + c1x² + … +
cn-2xⁿ⁻¹.</p>
<p>Cyclic code invariant under such shifts means that: if c(x) ∈ C, then
x.c(x) ∈ C provided we multiply by <code>mod (xⁿ-1)</code>.</p>
<p>That is, the residue class ring <code>Rₙ = Fₚ[X] / (Xⁿ-1)</code>
becomes relevant.</p>
<p>The <code>c∈C → xc∈C</code> property suggests that cyclic codes are
ideals of the ring <code>Rₙ = Fₚ[X] / (Xⁿ-1)</code>.</p>
<p>∴ for getting at cyclic codes of GF(p)ⁿ, we can examine the ideals of
Rₙ.</p>
<p>For this we need to have a way for factoring <code>Xⁿ-1</code>.<br />
:DBT: Why?</p>
<p>ie, find all irreducible factors of <code>Xⁿ-1</code> over
<code>Fₚ</code>.</p>
<p>Note: <code>Xⁿ-1</code> has no repeated factors over <code>Fₚ</code>
if p and n are co-prime to each other.</p>
<p>Facts:</p>
<ul>
<li>Every ideal is a cyclic code.</li>
<li>Every word in a cyclic code is a multiple of generator.</li>
</ul>
<h2 id="bch-code">BCH code</h2>
<ul>
<li>A cyclic error-correcting code.
<ul>
<li>And cyclic codes are a kind of linear codes.</li>
</ul></li>
<li>Named after its discoverers:
<ul>
<li>Bose-Chaudhuri-Hocquenghem</li>
</ul></li>
<li>Constructed using polynomials over a finite field.</li>
</ul>
<p>Advantage:</p>
<ul>
<li>Easily decoded. Using <em>syndrome decoding</em></li>
</ul>
<h2 id="class">Class</h2>
<p>Can detect upto d(C)-1 errors, where d(C) is the distance of the code
C. If 2t-1≤d(C) then we can correct upto t errors.</p>
<p>:DBT: Prove why first algo linear in #C??</p>
<h3 id="linear-code">Linear code</h3>
<p>Σ = Fₚ Linear code of length n is a sub-space of GF(pⁿ)</p>
<p>Can be defined in two ways: One of which is</p>
<ul>
<li>basis: ∵ just subspace.
<ul>
<li>k components</li>
</ul></li>
<li></li>
</ul>
<p>d(x,y) = w(x-y)</p>
<p>Looking at linear code ∵ detecting algo is polynomial in cardinality
of code???</p>
<p>#C = pᵏ k = logₚ(#C)</p>
<p>Rate = k/n</p>
<pre><code>         encode           decode
k comps -------&gt; n comps --------&gt; k comps
</code></pre>
<p>Forms a vector space.</p>
<p>:DBT: Linear forms (V*) of a vector space</p>
<ul>
<li>Linear maps from V to base field Fₚ where V = GF(pⁿ)</li>
</ul>
<p>Dim(C) = k Dim(C⊥) = n-k</p>
<p>C⊥ is the set of all vectors that vanishes at C.</p>
<p>n-k⨯n matrix.</p>
<pre><code>⎡h11    h12  ...  h1n   ⎤
⎢h21    h22  ...  h2n   ⎥
⎢        ....           ⎥
⎢        ....           ⎥
⎣hn-k1  hm2  ...  hn-kn ⎦
</code></pre>
<p>Syndrome ∵ it's like a symptom telling</p>
<p>Polynomial in time.</p>
<p>:LOOKUP: Inner product :FINDOUT: bilinear map. Linear on two
components. :FINDOUT: Linear forms of a vector space :FINDOUT: Full rank
matrix?? V** isomorphic to V</p>
<p>Linear code correction is NP-hard. :DBT: Why?</p>
<p>BCH code: Gives more structure to the code.</p>
<h3 id="cyclic-code-1">Cyclic code</h3>
<p>Cyclic shift of a code word is still a code word for all code words
in C.</p>
<p>n and p are coprime.</p>
<p>zero space: code space with just 0. Entire GF(pⁿ) space is a cyclic
code.</p>
<p>More structure.</p>
<p>Treat code words as polynomials (instead of as strings or
vectors).</p>
<p>c(X) = c0 + c1X + c2X² + …. + Cn-1Xⁿ⁻¹ X.c(X) = Xc0 + c1X² + c2X³ +
…. + Cn-1Xⁿ</p>
<p>Cyclic shift is equiv to mult by X. when mod (Xⁿ-1)</p>
<p>Cyclotomic ring. n and p are coprime =&gt; square free</p>
<p>n-lenght words =&gt; Fₚ[X]/Xⁿ-1</p>
<p>f(x) = Xⁿ-1 f'(x) = nXⁿ⁻¹ gcd(f,f') = 1</p>
<p>—</p>
<p>Code words are elements of the ring Rₙ = Fₚ[X]/Xⁿ-1</p>
<p>a ∈ C =&gt; x.a ∈ C</p>
<p>Cyclic codes are precisely the ideals of the R (message ring).</p>
<p>But how to find the ideals of R?</p>
<p>CRT to the rescue:</p>
<p>GF(p)[X]/Xⁿ-1 =~ GF(p)[X]/g1 * GF(p)[X]/g2 * … * GF(p)[X]/gn</p>
<p>:DBT: One of them is x-1. Why?</p>
<p>Because x-1 always divides xⁿ-1:</p>
<div class="sourceCode" id="cb90"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>sage: f<span class="op">=</span>x<span class="op">^</span><span class="dv">6</span><span class="op">-</span><span class="dv">1</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>sage: g<span class="op">=</span>x<span class="op">-</span><span class="dv">1</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>sage: f.maxima_methods().divide(g)</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>[x<span class="op">^</span><span class="dv">5</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">4</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">3</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> x <span class="op">+</span> <span class="dv">1</span>, <span class="dv">0</span>]</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>sage: f<span class="op">=</span>x<span class="op">^</span><span class="dv">17</span><span class="op">-</span><span class="dv">1</span></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>sage: f.maxima_methods().divide(g)</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>[x<span class="op">^</span><span class="dv">16</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">15</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">14</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">13</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">12</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">11</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">10</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">9</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">8</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">7</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">6</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">5</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">4</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">3</span> <span class="op">+</span> x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> x <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a> <span class="dv">0</span>]</span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>Fields as well on RHS. Field =&gt; ideals are either entire field or
just zero.</p>
<p>zero stuff =&gt; factors</p>
<p>There are polynomials gᵢ(X) dividing Xⁿ-1 such that.</p>
<p>:FINDOUT: Fourier transform is like CRT</p>
<p>Ideals are multiples of roots??</p>
<p>Cyclic codes are the (principal) ideals of Rₙ.</p>
<p>g(x) = Generator polynomial = product of all gᵢ(x) which gave 0 under
CRT.</p>
<p>Distance inversely prop to dimension.</p>
<p>:FINDOUT: BCH special case: Reed-Solomon code</p>
<h2 id="reed-soloman-codes">Reed-Soloman codes</h2>
<ul>
<li>Special case of BCH codes</li>
<li>Good at burst error correction.</li>
</ul>
<p>Error-correcting code: Data is represented with some redundancy so
that message can be retried even when a degree of error creeps in.</p>
<p>From <a
href="https://cse.buffalo.edu/faculty/atri/courses/coding-theory/book/web-coding-book.pdf">here</a>:</p>
<blockquote>
<p>From a theoretical point of view, the checksum is a terrible code</p>
</blockquote>
<p>:DBT: Why is CRC checksum bad?</p>
<p>Error-correcting codes needed when re-transmission is not a viable
option.</p>
<p>Applications of error-correcting codes:</p>
<ul>
<li>CD,DVD work even when having scratches because of error-correcting
codes.</li>
<li>QR codes, bar codes</li>
<li>Mobile telephony</li>
<li>Data sent from space by rovers on Mars.</li>
</ul>
<pre><code> Message
(k-bits) 
    |
    V
Encoded msg
 (n-bits) 
</code></pre>
<p>Encoding adds some redundancy, decoding removes errors.</p>
<p>Minimizing redundacy and maximising error correction are orthogonal
goals. Error correction needs redundancy.</p>
<p>:FINDOUT: Wedderbern Structure Theorems</p>
<hr />
<p>Cyclic code: keywords are multiples of a polynomial called the
generator polynomial.</p>
<p>Idempotent in a ring: An element e of the ring such that e²=e.
Weddernburn Structures Theorems =&gt; each cyclic code contain a unique
idempotent (due to n and p being coprime for Rₙ).</p>
<h2 id="tue-9">[2023-03-28 Tue]</h2>
<p>BCH code:</p>
<ul>
<li>instead of identifying the cyclic code by its generating polynomial
(ie, by its coefficients), identify it by the roots of that
polynomial.</li>
</ul>
<p>—</p>
<p>We're looking at cyclic codes where:</p>
<ul>
<li>Σ = Fₚ</li>
<li>Keywords are in GF(p)ⁿ
<ul>
<li>ie, vector space of dimension n over Fₚ</li>
</ul></li>
</ul>
<p>One way of looking at elements of GF(p)ⁿ is to think of them as
polynomials of the form</p>
<p>a(X) = a0 + a1X + a2X² + …. + an-1Xⁿ⁻¹</p>
<p>C is a cyclic code over Rₙ iff C is an ideal of Rₙ.</p>
<p>Code word ∈ Rₙ = Fₚ[X]/(Xⁿ-1)</p>
<p>For every cyclic code C in Rₙ, there is a polynomial g(x) such that:
C = g(x).Rₙ</p>
<p>Field =&gt; only possible ideas = Field itself or zero.</p>
<p>CRT projections on to components.</p>
<p>Non-zero components =&gt; coprime to g(x)</p>
<p>=&gt; Generator polynomial is product of components where ideal is
zero.</p>
<p>GF(p)[X]/Xⁿ-1 =~ GF(p)[X]/g1 * GF(p)[X]/g2 * … * GF(p)[X]/gn</p>
<p>CRT project components. Ideal of LHS =</p>
<p>—</p>
<p>Our task is to design a code of distance d.</p>
<p>Of course, d≤n because dimension is only n.</p>
<p>Primitive nth root of unity:</p>
<ul>
<li>it's a root of Xⁿ-1</li>
<li>but not a root of any polynomial Xʳ-1 where r&lt;n</li>
<li>A root of a cyclotomic polynomial??</li>
</ul>
<p>Pick small factor of Xⁿ-1 over Fₚ[X] which has b, b², b³,…bᵈ as
roots. Resulting cyclic code will have distance at least d (not
exactly).</p>
<p>smallest ∵ we wanna increase something. :DBT: mais quoi?</p>
<p>Let g(x) be a factor of Xⁿ-1 such that g(b)=g(b²)=…=g(bᵈ)=0.</p>
<p>Every code word is a multiple of g(x).</p>
<p>d(C) = weight(C)</p>
<pre><code>⎡ 1  β   (β) ...    (β)ⁿ ⎤ ⎡ a0   ⎤   ⎡ a(β)  ⎤
⎢ 1  β²  (β²) ...   (β²)ⁿ⎥ ⎢ a1   ⎥   ⎢ a(β²) ⎥
⎢       ....  ...        ⎥ ⎢ ..   ⎥ = ⎢ ...   ⎥ = 0
⎢       ....  ...        ⎥ ⎢ ..   ⎥   ⎢ ...   ⎥
⎣ 1  βᵈ  (βᵈ)  ...  (βᵈ)ⁿ⎦ ⎣ an-1 ⎦   ⎣ a(βᵈ) ⎦
</code></pre>
<p>dxn matrix.</p>
<p>ai-s is the codeword.</p>
<p>Suppose weight(a) is less than d. Après quoi?</p>
<p>Look at ai where ai=0. Drop corrsponding column in the dxn matrix as
well.</p>
<p>First matrix can become Vandermonde matrix, whic is a non-singular
matrix.</p>
<p>(Rank of any sub-matrix is d.)</p>
<p>Non-singular matrix * vector = 0 =&gt; every element of the vector =
0.</p>
<p>⎡ ……. ⎤ ⎡ .. ⎤ ⎢ ……. ⎥ ⎢ .. ⎥ ⎢ ……. ⎥ ⎢ .. ⎥ = 0 ⎢ ……. ⎥ ⎢ .. ⎥ ⎣ …….
⎦ ⎣ .. ⎦</p>
<p>This can happen only if distance ≥ d.</p>
<p>The largest degree of polynomial, smaller the n. So we prefer
smallest factor.</p>
<p>Finding the distnace of a linear code is an np-hard problem.
Why??</p>
<p>Yet this is a way to get code which is designed to have distance at
lest d. This is the <strong>designed distance</strong>. Code may be of
larger distance though.</p>
<p>Can correct upto t errors. where d = 2t+1 ??</p>
<p>—</p>
<p>Now let's see how can decode codewords in such codes. Decoding
algorithms.</p>
<pre><code>c(x) -&gt;---------&gt;-- r(x) = c(x) + e(x)
</code></pre>
<p>Sent codeword = C(x) Received codeword is R(x) = C(x) + e(x)</p>
<ul>
<li>where e is the error.</li>
</ul>
<p>We know only R(x).</p>
<p>C(β) = 0 ∀i≤d, C(βⁱ) = 0</p>
<p>e(β) = c(β) + e(β) ∵ c(β) is zero</p>
<p>ie,</p>
<p>e(βⁱ) = c(βⁱ) + e(βⁱ) = Y(βⁱ)</p>
<p>Two auxiliary polynomials.</p>
<p>Error locator polynomial: U(Y)</p>
<ul>
<li>Locations where error ≠ 0</li>
<li>Doesn't correct it. Only detects.</li>
</ul>
<p>M = { i | eᵢ ≠ 0} #M ≤ t</p>
<p>U(Y) = Π (1-βⁱY) j∈M</p>
<p>U(0) = 1</p>
<p>Error corrector polynomial: V(Y)</p>
<p>V(Y) = Σ eᵢβⁱY ( Π (1-βⁱY) i∈M (j∈M</p>
<p>Y(0) = 0</p>
<p>Both U(Y) and V(Y) have degree #M.</p>
<p>V(Y) eᵢβⁱY —— = Σ ——— U(Y) i∈M (1-βⁱY)</p>
<p>Gonna do a power series expansion.</p>
<p>V(Y) —— = Σ eᵢβⁱY Σ (βⁱY)ᵏ U(Y) i∈M k≥0</p>
<p>= Σ eᵢ Σ (βⁱY)ᵏ i∈M k≥1</p>
<p>= Σ Σ eᵢ(βᵏ)ⁱ Yᵏ k≥1 i∈M</p>
<p>= e(β)Y + e(β²)Y² + ….. + e(βᵈ)Yᵈ + O(Yᵈ⁺)</p>
<p>(Could be a sort of approximation? ∵ we ignore terms of degree??
greater than d.)</p>
<p>(V₁Y + V₂Y² + … VₘYᵐ) = (1 + U₁Y + U₂Y² + … UₘYᵐ) * (e(β)Y + e(β²)Y²
+ … e(βᵈ)Yᵈ)</p>
<p>Now compare coefficients:</p>
<p>V1 = e(β) V2 = e(β²) + u1.e(β) V3 = e(β³) + u1.e(β²) + u2.e(β) V4 =
.. .. Vm = ..</p>
<p>Don't stop at m. We stop only at d.</p>
<p>d equations. 2m variables. 2m+1&lt;d</p>
<p>Solve this system. And we get both U and V.</p>
<p>U'(Y) is:</p>
<p>Σ -βⁱ Π (1-βʲY) i∈M j∈M j≠i</p>
<p>Find error locations by factorizing M over the field. ie, finding
roots. Okay, but which field? Not Fₚ. But on the extension field??</p>
<p>V(β⁻ⁱ) =</p>
<p>= Σ eᵢβⁱβ⁻ⁱ Π (1-βʲ⁻ⁱ) i∈M j∈M</p>
<p>= Σ eᵢ Π (1-βʲ⁻ⁱ) i∈M j∈M</p>
<p>U(β⁻ⁱ) =</p>
<p>-βⁱ.</p>
<p>Σ -βⁱ Π (1-βʲ⁻ⁱ) i∈M j∈M j≠i</p>
<p>V(β⁻ⁱ) ——- = eᵢ U(β⁻ⁱ)</p>
<p>F₂ =&gt; ei no need to compute?? It's 1??</p>
<p>For a cyclic polynomail there is a generator polynomial. CRT can show
that.</p>
<h1 id="tue-10"><span class="done DONE">DONE</span> [2023-04-11
Tue]</h1>
<h2 id="polynomial-multiplication">Polynomial multiplication</h2>
<p>Input: 2 polynomials a(x) and b(x) over some ring R of degree n each
Output: a(x).b(x)</p>
<p>We can do some arithmetic over R to arrive at the output. We are told
how to multiplication and addition over <code>R</code>.</p>
<p>a(x) = a0 + a1x + a2x<sup>2</sup> + …. + anx<sup>n</sup> b(x) = b0 +
b1x + b2x<sup>2</sup> + …. + bnx<sup>n</sup> a.b =</p>
<p>Σ (ai.bi) Xᵏ i+j=k</p>
<p>a.b has degree 2n. =&gt; 2n+1 coefficients.</p>
<p>cₖ = Σ (ai.bi) Xᵏ i+j=k</p>
<p>What's the cost? 𝑂(n²). Basic operations were addn and multn.</p>
<p>This was the naïve algorithm.</p>
<p>Can we do better?</p>
<p>—</p>
<p>What about integer multiplication?</p>
<p>n-bit numbers.</p>
<p>a = a0 + a1.2 + a2.2<sup>2</sup> + …. + an2<sup>n</sup> b = b0 + b1.2
+ b2.2<sup>2</sup> + …. + bn2<sup>n</sup></p>
<p>We want a.b</p>
<p>Basic operations are the bit operations. =&gt; Cost / complexity.</p>
<p>(basic ops = ring arithmetic??)</p>
<p>—</p>
<p>Karastuba's algorithm.</p>
<p>These two problems are similar in some ways. I guess we'll find out
how soon…</p>
<p>Let N = 2ⁿ⁺¹ for some n be the degree of the polynomials.</p>
<p>Divided the polynomial into upper and lower halves.</p>
<p>a = A0 + X<sup>2n</sup>.A1 b = B0 + X<sup>2n</sup>.B1 a.b = A0.B0 +
X<sup>2</sup>(A1B0+A0B1) + A1.B1.X<sup>((2<sup>n</sup>)+1)</sup></p>
<p>linear term │ │ T(n) = 4.T(n/2) + n</p>
<p>= 4[4.T(n/4) + n/2] + n = 4[4.T(n/4) + n/2] + n = 4².T(n/4) + 2n + n
= 4².T(n/4) + (n + 2n) = 4²[4.T(n/8) + n/4] + (n+2n) = 4³.T(n/8) +
(n+2n+4n)</p>
<p>k-1 = 4ᵏ.T(n/2ᵏ) + n. Σ 2ⁱ i=0</p>
<p>if k = log₂N,</p>
<p>2<sup>(2.logN)</sup> . T(n/2<sup>logN</sup>) + 2<sup>logN</sup> N
2<sup>(2.logN)</sup> . T(1) + 2<sup>logN</sup> N N² + N²</p>
<p>Subtrn (ie, addn) could be made instead of mutliplication =&gt; saved
cost =&gt; better complexity</p>
<p>T(N) = 3.T(N/2) + N</p>
<p>A0B1 + A1B0 = T1 - T0 - T2 T0 = A0B0 T1 = (A0+A1)(B0+B1) T2 =
A1B1</p>
<p>Let's expand the recurrence relation:</p>
<p>T(N) = 3.T(N/2) + N = 3.[3T(N/6) + N/2] + N = 3².[T(N/6) + 3N/2] + N
= 3².T(N/6) + N(1 + 3/2)</p>
<p>k = logN means</p>
<p>3<sup>logN</sup> . (3/2)logN . N</p>
<p>3<sup>logN</sup> ~~ 2<sup>(logN)</sup>log3</p>
<p>𝑂(n<sup>log₂3</sup>)</p>
<p>log₂3 = 1.5849625007211563</p>
<h2 id="karatsubas-algorithm-for-integer-multiplication">Karatsuba's
algorithm for integer multiplication</h2>
<p>a = a0 + a1.2 + a2.2<sup>2</sup> + …. + an2<sup>n</sup></p>
<p>Careful! integer addn/multn?? carry over</p>
<p>— Something even better on the way!</p>
<p>express a in base 2ᵏ. by chunking up into pieces. Chunks of size k
each.</p>
<p>Number is represented in a base which is a power of 2.</p>
<p>a = a0 + a12</p>
<p>The resultant polynomial evaluated at 2ᵏ, you get the number
back.</p>
<p>Compute c(x)=a(x).b(x) Then evalute c(x) at 2ᵏ to get the product
number. Evaluating at c(x) is O(N) time. Shift-and-add that's it.</p>
<p>But this complexity is on ring operations. Not bit ops. So we got to
make the ring operations efficient.</p>
<p>Polynomial mult done by doing integer multn on smaller bits ??</p>
<p>Base ring of unity must have roots of unity. WHY? Fourier transform.
convoluton. point-wise multipliaton.</p>
<p>ℂ means some approximation needed?? You cannot multiply complex
numbers??? finite fields</p>
<p>Schonhage-Strassen 1970/1971 Fürer 2007 uses ℂ sbody 2008 uses finite
fields ℤ/pᵏℤ =&gt; less complex error analysis N.logN 2019 again on ℂ
=&gt; error analysis needed</p>
<p>Next up: Fourier transform</p>
<p>N.logN. loglogN. logloglogN. algorithm will be seen at a later
class.</p>
<p>Open research problem??: Multiplying compelxity of multiplying poly
in finite fields.</p>
<h1 id="thu-8"><span class="done DONE">DONE</span> [2023-04-13 Thu]</h1>
<p>Assumptions:</p>
<ul>
<li>Two polynomials: a(x) and b(x) on ring R[x]</li>
<li>Degrees of both a and b is max M
<ul>
<li>ie, degree of ab is max 2M</li>
</ul></li>
<li>R has (good) roots of unity (Why is this a requirement??)
<ul>
<li>Think of R as ℂ. All its roots of unity are 'good' (what does that
mean ??) Primitive roots of unity ??</li>
</ul></li>
</ul>
<p>Roots are in R[x]/xᴺ-1</p>
<p>For our polys, N got to be N≥2M+1</p>
<p>Reminder of a(x) when a(x) is divided by (x-</p>
<p>—</p>
<p>We evaluate at the primitive roots of unity.</p>
<p>Primitive N-th root of unity. ζ = exp(2πi/N)</p>
<p>—</p>
<p>Discrete Fourier Transfrom (DFT) is just the discrete form of Chinese
remaindering.</p>
<p>C[X]/(X<sup>N</sup>)-1 =~ C[X]/X-1 * C[X]/X-ζ * … *
C[X]/X-ζ<sup>(N-1)</sup></p>
<p>Inverse DFT is also a DFT, but we use 1/ζ as the starting primitive
root of unity ζ̅.</p>
<p>DFT: Coeff repr to CRT form (ē: time to ν domain) IDFT: CRT form to
coeffs</p>
<p>1 a^<sub>i</sub> = a(ζⁱ) = —- aⱼ(ζ<sup>ij</sup>) √N</p>
<p>Double summation =&gt; order can be swapped if discrete. cont domain
=&gt; not as easy</p>
<p>Σ(Σ aₖ.ζ<sup>(jk)</sup>)ζ<sup>(-ij)</sup> j k</p>
<p>Σ aₖ.(Σ ζ<sup>(j(k-i))</sup>) k j</p>
<p>—</p>
<p>We need a fast way to do FT =&gt; FFT (Fast FT) Fast n.logn.</p>
<h3 id="fft">FFT</h3>
<p>Given a(x), b(x).</p>
<ol>
<li>Find a^, b^ (cost: n.logn and n.logn)</li>
<li>Find (ab)^ by pointwise multn of a^, b^ (cost: n)</li>
<li>Invert (ab)^ to get ab (cost: n.logn)</li>
</ol>
<p>Steps 1 and 3 use FFT.</p>
<p>Total cost: 3n.logn + n =&gt; O(n.logn)</p>
<p>—</p>
<p>a^<sub>i</sub> = Σ 0≤j≤N</p>
<p>N = 2M N FT =&gt; odd even parts =&gt; Two M FTs</p>
<p>Recurrence relation for FFT:</p>
<p>T(n) = 2.T(n/2) + O(n) =&gt; O(n.logn)</p>
<h1 id="tue-11"><span class="done DONE">DONE</span> [2023-04-18
Tue]</h1>
<p>Polynomial multiplication using FFT.</p>
<p>Complexity:</p>
<pre><code>nlogn. log²n. log³n. .... 
</code></pre>
<p>Or more concisely</p>
<pre><code>nlog*n
</code></pre>
<p>where log*n is a notation meaning keep doing log till value becomes
1.</p>
<p>Liven deep number thoery Dirichlet Fourier probably stumbled on the
Z/pZ method but found that he couldn't improve complexity of sieving and
went</p>
<p>Multivariable polynomial multiplication! Hensel lifting</p>
<h3 id="polynomial-multiplication-1">Polynomial multiplication</h3>
<p>a(x) = a0 + a1x + a2x<sup>2</sup> + …. + anx<sup>n</sup> b(x) = b0 +
b1x + b2x<sup>2</sup> + …. + bnx<sup>n</sup></p>
<ul>
<li>ℂ =&gt; error analysis needed</li>
<li>Finite field =&gt; ℤ/pℤ
<ul>
<li>Appropriate prime selection needs a sieving =&gt; expensive</li>
<li>Primitive root of unity got to be in the ring <em>and</em> ring has
to be big enough.</li>
</ul></li>
</ul>
<h1 id="thu-9"><span class="done DONE">DONE</span> [2023-04-20 Thu]</h1>
<p>Given polynomials f(x) and g(x) ∈ F[x], find quotient and
remainder.</p>
<p>f(x) = q(x).g(x) + r(x)</p>
<p>We are told that:</p>
<ul>
<li>g(x) is monic.
<ul>
<li>Then we don't even need F to be a field?? It being a ring is fine.
Why?? :DBT:</li>
</ul></li>
<li>f(x) &gt; g(x)
<ul>
<li>deg(f) = n</li>
<li>deg(g) = m</li>
<li>deg(q) = n-m</li>
<li>deg(r) &lt; m</li>
</ul></li>
</ul>
<pre><code>+-------------------------------------
|
| f(x) = fnXn + fn-1Xn-1 + .... + f0
|
</code></pre>
<p>Normally this is a O(n²) algorithm. Can we do better?</p>
<p>We'll show that div is as difficult as poly multn. O(n.logn)</p>
<p>This is starting of Hensel lifting…</p>
<p>Find f(1/x). No computing, just symbolic subst.</p>
<p>Multiply x<sup>n</sup> to this. ie,</p>
<p>x<sup>n</sup>.f(1/x) x<sup>n</sup>[f0 + f1/x + …. fn/x<sup>n</sup>]
f0.x<sup>n</sup> + fx<sup>n</sup>-1 + …. fn</p>
<p>which is f(x) in 'reverse order'</p>
<p>ie, revₙ(f)</p>
<p>Let F(x) be the Laurent polynomials in X. They start with some -ve
power of x. F(x) = a₋ₙx<sup>-n</sup> + ….</p>
<p>X<sup>n</sup>.f(1/x) = [x<sup>(n-m)</sup>.q(1/x).
x<sup>m</sup>.g(1/x)] + x<sup>(n-m+1)</sup>.x<sup>(m-1)</sup>.r(1/x)
revₙ(f) = revₙ₋ₘ(q).revₘ(g) + x<sup>(n-m+1)</sup>revₘ₋₁(r)</p>
<p>Find q first. Then finding r is straightforward.</p>
<p>q degree is n-m. If we can get q modulo n-m+1, we got q
precisely.</p>
<p>g is monic. So revₘ(g) has constant term coeff 1.</p>
<p>Find inverse of revₘ(g) modulo x<sup>(n-m+1)</sup></p>
<p>h.revₘ(g) = 1 x<sup>(n-m+1)</sup></p>
<p>Multiplying with h on what we had been doing,</p>
<p>revₙ(f) = revₙ₋ₘ(q).revₘ(g) + x<sup>(n-m+1)</sup>revₘ₋₁(r) h.revₙ(f)
= revₙ₋ₘ(q) mod x<sup>(n-m+1)</sup></p>
<p>—</p>
<p>if constant term coeff is 1, we can compute inverse modulo
x<sup>n</sup> for any n. ???</p>
<p>—</p>
<p>For a if constant term coeff is 1, we can compute b(x) such that
a(x).b(x) = 1 mod x<sup>(2<sup>i</sup>)</sup></p>
<p>ab=1</p>
<p>Let's say (without proof),</p>
<p>a - 1/b = 0</p>
<p>Let φ = a - 1/b</p>
<p>Solve for φ(b)=0 mod x<sup>2ⁱ</sup></p>
<p>Suppose α is the soln.</p>
<p>suppose that αₙ is an approximate soln for φ(b)=0 (ie, without the
mod)</p>
<p>Taylor series expansion.</p>
<p>Suppose αₙ is a very close to α. Then we can ignore quadratic terms
as they are too small.</p>
<p>δ = φ(αₙ) / φ'(αₙ)</p>
<p>Approximation. mod x<sup>(2ⁱ)</sup>. Higher the i, more closer is the
approximation to actual value.</p>
<p>αₙ₊₁ = αₙ - [φ(αₙ) / φ'(αₙ)]</p>
<p>Our starting solution (ie, at mod X) is 1. We imporve accuracy as we
go to higher powers of X. ∵ mod x<sup>n</sup> means the first n coeffs
would be the same.</p>
<p>α₀ = b₀ = 1</p>
<p>bₗ - [a - 1/bₗ]/(1/bₗ²) ~~ bₗ - [bₗ²a - bₗ] =</p>
<p>Blindly following à la newton Rhapson. It will somehow turn out to be
okay. Proof by induction.</p>
<p>—</p>
<p>Lemma: Let a(x) be a polynomial such that a(0)=1 and let bₗ be a
polynomial such that a.bₗ=1 mod X<sup>(2ˡ)</sup>. Then, bₗ₊₁ = 2.bₗ -
bₗ²a is such that</p>
<ul>
<li>a.bₗ₊₁ = 1 mod X<sup>(2ˡ⁺¹)</sup></li>
<li>bₗ₊₁ = bₗ mod X<sup>(2ˡ)</sup></li>
</ul>
<p>—</p>
<pre><code>bₗ₊₁ = 2bₗ - bₗ.bₗ.a
     = 2bₗ - bₗ.1          (∵ assumption)
     = bₗ
</code></pre>
<p>Inverse does exists but it is a power series not a polynomial.</p>
<p>Lifting..</p>
<p>Division at the complexity of mult.</p>
<p>We arrived at this formula by taking a 'leap of faith' and going
along with newton-Rhapson approximation.</p>
<p>—-</p>
<p>a(0) = 1 then a = 1 - a₀(x).x</p>
<p>1/a = 1/1-xa0</p>
<p>Here we need l steps. Newton-Rhapson needed only logl???</p>
<h1 id="tue-12"><span class="done DONE">DONE</span> [2023-04-25
Tue]</h1>
<p>Hensel lifting recap</p>
<p>Efficient in the sense that we can do division at the complexity of
mult.</p>
<p>Given a monic polynomial g(x), find its inverse h(x) such that</p>
<p>h(x).g(x) = 1 mod X<sup>(2ˡ)</sup></p>
<p>monic poly mod X =&gt; only constant term remains: which is 1. ie, h0
= 1</p>
<p>φ(h) = g - (1/h)</p>
<p>h<sub>(l+1)</sub> = h<sub>l</sub> mod X<sup>(2<sup>l</sup>)</sup></p>
<p>ie, initial terms of both h here would be same. h<sub>(l+1)</sub> is
more precise.</p>
<p>—</p>
<p>f(x) ∈ ℤ[x], f(x) modp ∈</p>
<p>f(α0+h) = f(α0) + h.f'(α0) + h²</p>
<p>h = -f(α0) / f'(α0)</p>
<p>Finding root of a polynomial from its root mod p</p>
<p>Next up factorization.. Fun fact: Root finding is a special case of
factorization.</p>
<p>—</p>
<p>formal derivative =&gt; no need of function being continous ??</p>
<p>1 + 2 + 2<sup>2</sup> + 2<sup>3</sup> + … is -1 ??</p>
<p>1/(1-2<sup>i</sup>) ???</p>
<p>p-adics</p>
<p>—</p>
<p>In ℤ[√-5], 21 can be written as both (1+2√-5)(1-2√-5) and seven*3</p>
<p>Factorization makes sense only in UFD. Like ℤ. — UFD, PID, ED Ideal,
principal ideal —</p>
<p>Factoring bivariate polynomials.</p>
<ul>
<li>Given a polynomial</li>
</ul>
<p>f = gh . mod Y sg + th = 1 mod Y (g and h aare comprime)</p>
<h1 id="thu-10"><span class="done DONE">DONE</span> [2023-04-27
Thu]</h1>
<p>Factoring bivariate polynomials Base field: K</p>
<p>f(x,y) ∈ K[X,Y]</p>
<p>Could think of them as univariant polynomials with coefficient
themselves being functions: K(X)[Y]</p>
<p>The ring K[X,Y] is a UFD. ∵ there's a lemma showing that if R is UFD,
then so is R[x]</p>
<p>Root finding is a special case of factorization.</p>
<p>For root-finding we could use Hensel lifting.</p>
<p>We could adapt that for factorization.</p>
<p>Start with an 'approximate' factorization of f.</p>
<p>Find one factor, then rinse and repeat to get the other factors.</p>
<p>What does it even mean for a multivariant polynomial to divide
another? We had a clear definition in the case of univariant
polynomial.</p>
<p>One way to give meaning is linear algebra..</p>
<p>Polynomials: f and g if g|f (divides).</p>
<p>If degX of any of f and g become 0, it's simply univariant stuff??
So, we say:</p>
<p>degX g &gt; 0 and degX f &gt; 0</p>
<p>—</p>
<p>f(x,y) mod y</p>
<h1 id="tue-13">[2023-05-02 Tue]</h1>
<p>Bivariate factoring.</p>
<p>a = Y<sup>(2<sup>k</sup>)</sup> (or did he mean m instead of a
here???)</p>
<ol>
<li>f = gh mod m</li>
<li>sg + th = 1 mod m</li>
</ol>
<p>This was the starting approximation.</p>
<p>From this find a better approximation. ie, compute</p>
<ol>
<li>f = g'h' mod m²</li>
<li>s'g' + t'h' = 1 mod m²</li>
</ol>
<p>g' = g mod m s' = s mod m</p>
<p>(∵ we are refining here)</p>
<p>Let</p>
<p>e = (f - gh) mod m²</p>
<p>Silvester matrix of polynomials f and g. ('shifting' involved.)</p>
<p>non-trivial gcd =&gt; gcd!=1</p>
<p>Determinaent of sylverton matrix = resultant(f,g)</p>
</div>
</body>
</html>
