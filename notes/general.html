<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Miscellaneous notes</title>
  <style>
    body {
      max-width: 38rem;
      padding: 2rem;
      margin: auto;
      background-color: #FAF0E6;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
  </style>

</head>
<body>


<div id="header">
<a href="https://ju-sh.github.io">Home</a>
 | 
<a href="https://ju-sh.github.io/blog/index.html">Blog</a>
 | 
<a href="https://ju-sh.github.io/wiki/index.html">Wiki</a>
 | 
<a href="https://ju-sh.github.io/about.html">About</a>
</div>

<header id="title-block-header">
<h1 class="title">Miscellaneous notes</h1>
</header>

<ul>
    </ul>




<hr/>

<div id="content-container">
<hr />
<h1 id="logic">Logic</h1>
<ul>
<li>∃ was introduced by Peano</li>
<li>∀ was introduced by Gentzen (after ∃)</li>
<li>natural deduction, rules come in pairs
(introduction,elimination)</li>
<li>Sentential logic: another name for Boolean logic <a
href="https://plato.stanford.edu/entries/logic-firstorder-emergence/">⁵</a></li>
<li>Subjunction: Something like 'implies' or 'if-then'</li>
</ul>
<ul>
<li>Contrapositive: a rule by which the antecedent and consequent of an
implication are inverted and switched.
<ul>
<li>Eg: (p → q) → (~q → ~p)</li>
</ul></li>
</ul>
<ul>
<li>Transposition: a rule by which we can switch the antecedent and
consequent of an implication.
<ul>
<li>Eg: (p → q) ↔︎ (~q → ~p)</li>
</ul></li>
</ul>
<h2 id="propositions-as-types">Propositions as types</h2>
<table>
<thead>
<tr class="header">
<th>Propositions</th>
<th>Types</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Proof</td>
<td>Value / program</td>
</tr>
<tr class="even">
<td>Implication</td>
<td>Function</td>
</tr>
<tr class="odd">
<td>Conjunction</td>
<td>Product</td>
</tr>
<tr class="even">
<td>Disjunction</td>
<td>Sum</td>
</tr>
<tr class="odd">
<td>Proof verification</td>
<td>Type checking</td>
</tr>
<tr class="even">
<td>Proof construction</td>
<td>Programming</td>
</tr>
<tr class="odd">
<td>Proof normalization</td>
<td>Program evaluation</td>
</tr>
</tbody>
</table>
<p>From one of Philip Wadler's talks:</p>
<table>
<thead>
<tr class="header">
<th>Logic</th>
<th>Types</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Natural deduction</td>
<td>STLC</td>
</tr>
<tr class="even">
<td>(Gentzen 1935)</td>
<td>(Alonzo Church 1940)</td>
</tr>
<tr class="odd">
<td>Type schemes</td>
<td>ML type system</td>
</tr>
<tr class="even">
<td>(Hindley 1969)</td>
<td>(Robin Milner 1975)</td>
</tr>
<tr class="odd">
<td>System F</td>
<td>Polymorphic LC</td>
</tr>
<tr class="even">
<td>(Girard 1972)</td>
<td>(Reynolds 1974)</td>
</tr>
<tr class="odd">
<td>Modal logic</td>
<td>Monads</td>
</tr>
<tr class="even">
<td>(Lewis 1910)</td>
<td>(Kleisli 1965, Moggi 1987)</td>
</tr>
<tr class="odd">
<td>Classical-Intuitionistic embedding</td>
<td>CPS</td>
</tr>
<tr class="even">
<td>(Gödel 1933)</td>
<td>(Reynolds 1972)</td>
</tr>
<tr class="odd">
<td>Linear logic</td>
<td>Session types</td>
</tr>
<tr class="even">
<td>(Girard 1987)</td>
<td>(Honda 1993)</td>
</tr>
</tbody>
</table>
<h2 id="stlc-curry-style-and-church-style">STLC: Curry style and Church
style</h2>
<p>UTLC functions have no fixed domain and range.</p>
<p>Both Curry and Church came up with typed versions of their lambda
calculus systems:</p>
<ul>
<li>Curry style</li>
<li>Church style</li>
</ul>
<table>
<thead>
<tr class="header">
<th>Curry</th>
<th>Church</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Implicit types</td>
<td>Explicit types</td>
</tr>
<tr class="even">
<td>'Extrinsic typing'</td>
<td>'Intrinsic typing'</td>
</tr>
<tr class="odd">
<td>Types assigned later</td>
<td>Type assignment 'built-in'</td>
</tr>
<tr class="even">
<td>λx.x</td>
<td>λx:ℕ. x:ℕ</td>
</tr>
<tr class="odd">
<td>Came first</td>
<td>Came later</td>
</tr>
</tbody>
</table>
<p><a
href="https://ncatlab.org/nlab/show/intrinsic+and+extrinsic+views+of+typing">https://ncatlab.org/nlab/show/intrinsic+and+extrinsic+views+of+typing</a></p>
<p>CoC (and hence CIC) is in Church style.</p>
<pre><code>type := Type
      | type → type
</code></pre>
<p>(<code>→</code> associates to the right.)</p>
<p>Values of <code>Type</code> are type variables.</p>
<p>where all τᵢ are of values of type <code>type</code>.</p>
<h2 id="heyting-algebra">Heyting algebra</h2>
<ul>
<li><p>∪, ∩ are commutative and associative</p></li>
<li><p>∪ distributes over ∩, ∩ distributes over ∪</p></li>
<li><p>a ∪ 0 = a, a ∩ 1 = a</p></li>
<li><p>0 is like False / fallacy.</p></li>
<li><p>1 is like True / tautology.</p></li>
</ul>
<h2 id="bhk-classical-interpretation">BHK: Classical interpretation</h2>
<ul>
<li>Brouwer-Heyting-Kolmogorov interpration: assign a set of proofs to
the formula
<ul>
<li>formula is true iff it has a proof</li>
</ul></li>
<li>Tarski-an interpretation: interpretation of a formula is either
'true' or 'false'.</li>
<li>Classical vs intuitionistic logic:
<ul>
<li>Classical: Existence is proof</li>
<li>Construction: Construction is proof??</li>
</ul></li>
<li>Constructive programming: Programming is replaced by proving.</li>
</ul>
<p>Ref: Classical Brouwer-Heyting-Kolmogorov interpretation - Sata,
Masahiko: <a
href="https://repository.kulib.kyoto-u.ac.jp/dspace/bitstream/2433/61685/1/1021-3.pdf">https://repository.kulib.kyoto-u.ac.jp/dspace/bitstream/2433/61685/1/1021-3.pdf</a></p>
<h2 id="peirces-law"><a
href="https://en.wikipedia.org/wiki/Peirce%27s_law">Peirce's
law</a></h2>
<p>Named after the logician Charles Peirce.</p>
<pre><code>((p -&gt; q) -&gt; p) -&gt; p
</code></pre>
<p>Truth table:</p>
<pre><code>| p | q | p -&gt; q | (p-&gt;q) -&gt; p | ((p -&gt; q) -&gt; p) -&gt; p |
|---+---+--------+-------------+----------------------|
| 0 | 0 |      1 |           0 |                    1 |
| 0 | 1 |      1 |           0 |                    1 |
| 1 | 0 |      0 |           1 |                    1 |
| 1 | 1 |      1 |           1 |                    1 |
</code></pre>
<p>Peirce's law is equivalent to law of excluded middle when
<code>q</code> is made <code>¬p</code>:</p>
<pre><code>| ((p -&gt; ¬p) -&gt; p) -&gt; p      |                          |
| ((¬p ∨ p) -&gt; p) -&gt; p       | (p-&gt;q) ≡ (¬p ∨ q)        |
| (¬(¬p ∨ p) ∨ p) -&gt; p       | (p-&gt;q) ≡ (¬p ∨ q)        |
| ((p ∧ ¬p) ∨ p) -&gt; p        | ∨ distr, double negation |
| ¬((p ∧ ¬p) ∨ p) ∨ p        | (p-&gt;q) ≡ (¬p ∨ q)        |
| (¬(p ∧ ¬p) ∧ ¬p) ∨ p       | double negation          |
| ((¬p ∨ p) ∧ ¬p) ∨ p        | double negation          |
| ((¬p ∧ ¬p) ∨ (p ∧ ¬p)) ∨ p | ∧ distr                  |
| ¬p ∨ p                     | double negation          |
| p ∨ ¬p                     | ∨ comm                   |

Assumes double negation rule (ie, ¬¬p ≡ p). But it&#39;s classical logic anyway, since we are deriving law of excluded middle.
</code></pre>
<h2 id="minimal-logic">Minimal logic</h2>
<p><a
href="https://en.wikipedia.org/wiki/Minimal_logic">https://en.wikipedia.org/wiki/Minimal_logic</a></p>
<p>Doesn't have:</p>
<ul>
<li>law of excluded middle (<code>p ∨ ¬p</code>)</li>
<li>principle of explosion (∀x, ⊥ → x)
<ul>
<li>Anything can be proven from a contradiction.</li>
</ul></li>
</ul>
<h2 id="systems">'Systems'</h2>
<ul>
<li>System LK (Gentzen)</li>
<li>System LJ (A modification of LK)</li>
<li>System F (Polymorphism)</li>
<li>System T (Gödel?)</li>
</ul>
<h2 id="order-of-quantifier-matters">Order of quantifier matters</h2>
<ul>
<li>In <code>∀x, ∃y</code>, means x is fixed first, and y is chosen
later.</li>
<li>In <code>∃y, ∀x</code>, means y is fixed first, and x is chosen
later.</li>
</ul>
<p>For example,</p>
<pre><code>∀x:country, ∃y:city,
  y = capital(x)
</code></pre>
<p>means 'every country has a city as its capital'</p>
<pre><code>∃y:city, ∀x:country,
  y = capital(x)
</code></pre>
<p>means 'there is some city which is the capital of all countries'.</p>
<h2 id="sequent-calculus">Sequent calculus</h2>
<p>A style of formal logical argumentation in which every line of proof
is a conditional tautology (known as <em>sequent</em>).</p>
<ul>
<li>More suited for theoretical analysis.
<ul>
<li>Natural deduction more suited for practical theorem proving.</li>
</ul></li>
<li>Sequent calculus is a <em>Gentzen style</em> system, like natural
deduction.
<ul>
<li>But unlike natural deduction, which can have only one conclusion per
line, sequent calculus can have one or more conclusions per line.</li>
</ul></li>
</ul>
<h3 id="inference-rules">Inference rules</h3>
<pre><code>Left ∧ rule (L ∧):

Γ,A∧B ⊢ Δ
=========
Γ,A,B ⊢ Δ


Left ∨ rule (L ∨):

    Γ,A∨B ⊢ Δ
=================  
Γ,A ⊢ Δ   Γ,B ⊢ Δ


Left → rule: (DOUBT: How does this one come about??)

Γ,A→B ⊢ Δ
=========


Left ¬ rule: (DOUBT: How does this one come about??)

Γ,¬A ⊢ Δ
========
Γ ⊢ Δ,A
</code></pre>
<h3 id="cut-rule-in-sequent-calculus">Cut rule in sequent calculus</h3>
<ul>
<li>An inference rule in sequent calculus.</li>
<li>Something like a broader/generalized form of modus ponens rule.</li>
</ul>
<p>If a formula <code>A</code> appears as a conclusion of one proof and
appears as a hypothesis of another proof, a third proof can be deduced
in which the formula <code>A</code> does not even appear (ie,
<code>A</code> is eliminated).</p>
<pre><code>  Γ ⊢ A,Δ   Γ&#39;,A ⊢ Δ&#39;
======================
     Γ,Γ&#39; ⊢ Δ,Δ&#39;
</code></pre>
<h2 id="hilbert-style-proof-systems">Hilbert style proof systems</h2>
<ul>
<li>Every line of the proof is an unconditional tautology (ie, a
theorem).</li>
<li>Has small number of inference rules, more number of axioms.
<ul>
<li>Unlike Gentzen style systems, which have few axioms and more
inference rules.</li>
</ul></li>
</ul>
<h2 id="continuation-passing-style-cps">Continuation Passing Style
(CPS)</h2>
<ul>
<li>Used by smlnj internally.</li>
</ul>
<p>Reference: <em>Compiling with continuations</em> - Andrew Appel</p>
<h2 id="proposition">Proposition</h2>
<p>Informally speaking,</p>
<blockquote>
<p>A proposition is a 'sentence' for which 'it makes sense' to ask if it
is true or false.</p>
</blockquote>
<p>Reference: <em>Applied abstract algebra</em> (2e) - Rudolf Lidl,
Günter Pilz</p>
<h2 id="skolemization">Skolemization</h2>
<ul>
<li>A process of removing existential quantifiers from a first order
formula.
<ul>
<li>By introducing new function symbols if needed.</li>
</ul></li>
<li>The result would be in <a
href="https://en.wikipedia.org/wiki/Skolem_normal_form">Skolem normal
form</a>.</li>
<li>Needn't be equivalent to the original formula, but result is SAT
only if the original formula is SAT.
<ul>
<li>ie, result of skolemization is equisatisfiable with the original
formula.</li>
</ul></li>
<li>Dual of skolemization is <a
href="https://en.wikipedia.org/wiki/Herbrandization">Herbrandization</a>.</li>
</ul>
<p>An example <a
href="https://www.cs.toronto.edu/~sheila/384/w14/Lectures/Resolution-plus-tutorial-6pp.pdf">¹⁶</a>:</p>
<pre><code>Formula: Every philosopher has written at least one book.
ie, for each philosopher, there exists a book that is written by that philosopher.

∀p, Philo(p) -&gt; (∃b [book(b) ∧ write(p, b)])

Rewriting the implication,

∀p, ¬ Philo(p) ∨ (∃b [book(b) ∧ write(p, b)])

There exists a b for a given p means we can have a function g that maps any given p to its b. 
This part is the skolemization.

∀p, ¬ Philo(p) ∨ [book(g(p)) ∧ write(p, g(p))]
</code></pre>
<p>Another example <a
href="https://www.cs.toronto.edu/~sheila/384/w14/Lectures/Resolution-plus-tutorial-6pp.pdf">¹⁶</a>:</p>
<pre><code>∀p ∀s, philo(p) ∧ studentOf(p, s) -&gt; ∃b, book(b) ∧ write(p, b) ∧ read(s, b)

Rewriting the implication,

∀p ∀s, ¬ [philo(p) ∧ studentOf(p, s)] ∨ [∃b, book(b) ∧ write(p, b) ∧ read(s, b)]

From de-Morgan&#39;s law,

∀p ∀s, [¬philo(p) ∨ ¬studentOf(p, s)] ∨ [∃b, book(b) ∧ write(p, b) ∧ read(s, b)]

There exists a book for a given philosopher p that one of his students s read. We can have a function g mapping a given p and s to a b.
Skolemizing,

∀p ∀s, [¬philo(p) ∨ ¬studentOf(p, s)] ∨ [book(g(p,s)) ∧ write(p, g(p,s)) ∧ read(s, g(p,s))]
</code></pre>
<h2 id="linear-logic">Linear logic</h2>
<p>Proposed by Jean-Yves Girard.</p>
<table>
<tbody>
<tr class="odd">
<td>⊸</td>
<td>linear implication</td>
<td>aka lollipop</td>
</tr>
<tr class="even">
<td>⊗</td>
<td>multiplicative conjuction (tensor)</td>
<td>⨂</td>
</tr>
<tr class="odd">
<td>⅋</td>
<td>multiplicative disjunction</td>
<td></td>
</tr>
<tr class="even">
<td>⊕</td>
<td>additive disjunction</td>
<td>⨁</td>
</tr>
</tbody>
</table>
<pre><code>tm := p        | ¬p
    | p ⊕ p    | p ⊗ p
    | p &amp; p    | p ⅋ p
    | 0        | 1
    | ⊤        | ⊥
    | !p       | ?p
</code></pre>
<p>Nature of connectives:</p>
<ul>
<li>Exponentials: !, ?</li>
<li>Multiplicative: ⨂, ⅋, 1</li>
<li>Additive: ⨁, &amp;, 0</li>
</ul>
<p>Names:</p>
<ul>
<li>&amp;: with</li>
<li>⅋: par</li>
<li>!: bang</li>
<li>?: quest</li>
</ul>
<p>Lollipop is a derived connective: <code>p ⊸ q ≡ ¬p ⅋ q</code></p>
<h2 id="affine-logic">Affine logic</h2>
<ul>
<li>Like a 'weakened' linear logic.</li>
<li>Each resource can be used <em>atmost</em> once.
<ul>
<li>Ie, can also be left unused.</li>
<li>Or to put it in other words, resource can be discarded instead of
being used.</li>
</ul></li>
<li>Unlike linear logic, where each resource has to be used
<em>exactly</em> once <a
href="https://en.wikipedia.org/wiki/Substructural_type_system">ʷ</a></li>
</ul>
<h2 id="leibnizs-equality">Leibniz's equality</h2>
<p>x = y iff P(x) = P(y) for all predicates. <a
href="https://en.wikipedia.org/wiki/Equality_(mathematics)">ʷ</a></p>
<h1 id="type-theory">Type theory</h1>
<ul>
<li>Types are 'specs' for values. <a
href="https://bitbucket.org/piyush-kurur/hott-notes/src/master/course-tifr/lectures/introduction.lhs.md">¹</a></li>
<li>Compilers ensure that these specs are adhered to.</li>
<li>Π-calculus: a popular core language for defining semnatics of
message-based concurrent languages.</li>
<li>type reconstruction: another name for 'type inference'.
<ul>
<li>Compiler fills in type information that has been left out by the
programmer.</li>
</ul></li>
</ul>
<h2 id="type-variable-example">Type variable example</h2>
<p>From 22.2 of TAPL book (page 319):</p>
<pre><code>λf:X→X.
  λa:X.
    f (f a)
</code></pre>
<p>where <code>X</code> is a type variable.</p>
<p>Two abstractions. So, two arguments:</p>
<ol>
<li><code>f : X → X</code></li>
<li><code>a : X</code></li>
</ol>
<p>Final value type: <code>X</code></p>
<p>As in</p>
<pre><code>f (f a)
|  |  |
|  +--+
|    |
|    X
|    |
+----+
   |
   X
</code></pre>
<p>So the type of the initial term is:</p>
<pre><code>(X → X) → X -&gt; X
|     |   |    |
+-----+   |    |
   |      |    |
   f      a  return value
</code></pre>
<p>Holding type variable abstract like this allows for <em>parametric
polymorphism</em>.</p>
<h2 id="most-general-instance">Most general instance</h2>
<p>Makes smallest commitment about the values of type variables that
yields a well-typed term.</p>
<h3 id="example">Example</h3>
<p>Consider a term:</p>
<pre><code>λf:Y.
λa:X.
f (f a)
</code></pre>
<p>This by itself can't be said to be well typed. Because <code>f</code>
is of type <code>Y</code> when it has got to accept <code>a : X</code>
as argument.</p>
<p>But if we change <code>Y</code> to be <code>X → X</code>, to make
it</p>
<pre><code>λf:X → X.
λa:X.
f (f a)
</code></pre>
<p>we could say that the term is well-typed, but without yet giving a
concrete value for the type variable <code>X</code>. Its type is:
<code>(X → X) → X → X</code>.</p>
<p>So, the latter is the 'most general instance' of the former. Smallest
commitment regarding values of type variables that yields a well-typed
term.</p>
<p>We could say that <strong>type inference</strong> (aka <strong>type
reconstruction</strong>) is the search for a valid instantiation of type
variables.</p>
<pre><code>λf:Y .
λa:X .
f (f a)
</code></pre>
<h2 id="fixed-point-of-functions">Fixed point of functions</h2>
<p>x is a fixed point of a function f if:</p>
<pre><code>f(x) = x
</code></pre>
<p>Example:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Fixed points</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>f(x) = x²</td>
<td>0, 1</td>
</tr>
<tr class="even">
<td>f(x) = x³</td>
<td>-1, 0, 1</td>
</tr>
<tr class="odd">
<td>f(x) = x</td>
<td>∀x</td>
</tr>
</tbody>
</table>
<p>Any function definable in lambda calculus has a fixed point, which
itself is definable in labmda calculus. <a
href="https://cs.pomona.edu/~kim/CSC066S06/Lectures/Lecture13/Lecture13_1.html">⁸</a></p>
<h1 id="computer-science">Computer Science</h1>
<h2 id="fuzzing">Fuzzing</h2>
<p>Testing a functionality by feeding it randomly generated input to see
if it breaks on any of them</p>
<ul>
<li>An automated software testing technique</li>
<li><a
href="https://oherrala.medium.com/quickcheck-or-fuzzing-which-one-to-use-98d200e9609b">https://oherrala.medium.com/quickcheck-or-fuzzing-which-one-to-use-98d200e9609b</a></li>
<li>'Fuzzing: Breaking Things with Random Inputs'
<ul>
<li><a
href="https://www.fuzzingbook.org/html/Fuzzer.html">https://www.fuzzingbook.org/html/Fuzzer.html</a></li>
</ul></li>
<li>Aim is to produce unexpected input and see if they are handled
properly</li>
<li>Most useful when input is structured</li>
<li>A test oracle is used ??</li>
<li>Repeatedly run with random input to try and crash the software. If a
crash occurs, examine to figure out what went wrong.</li>
</ul>
<ul>
<li>Black box fuzzing
<ul>
<li>Classic fuzzing</li>
</ul></li>
<li>Dbt: Difference from
<ul>
<li>Property-based testing</li>
<li>Mutation testing</li>
<li><a
href="https://news.ycombinator.com/item?id=29763115">https://news.ycombinator.com/item?id=29763115</a></li>
</ul></li>
</ul>
<h2 id="church-turing-thesis">Church-Turing thesis</h2>
<ul>
<li>Entscheidungsproblem is undecidable.
<ul>
<li>German for 'decision problem'</li>
</ul></li>
<li>Church's lambda calculus and Turing machines are equivalent.
<ul>
<li>Both formalize the meaning of computation.</li>
</ul></li>
<li>Some decision problems are undecidable.
<ul>
<li>There's no <em>general</em> algorithm that works every time.</li>
<li><a
href="https://en.wikipedia.org/wiki/Turing%27s_proof">https://en.wikipedia.org/wiki/Turing%27s_proof</a></li>
</ul></li>
<li>Alan Turing worked on Turing machines.</li>
<li>Alonzo Church worked on lambda calculus.</li>
</ul>
<p>Informally speaking, Church-Turing thesis says:that both Turing
machines and lambda calculus represent computations.</p>
<p>Reference: <a
href="https://www.cs.cornell.edu/courses/cs3110/2021sp/textbook/adv/curry-howard.html">https://www.cs.cornell.edu/courses/cs3110/2021sp/textbook/adv/curry-howard.html</a></p>
<h3 id="entscheidungsproblem">Entscheidungsproblem</h3>
<ul>
<li>Accept a statement as input and find an algorithm that check if the
statement holds in the given axiom system.
<ul>
<li>ie, whether the statement is valid in every structure satisfying the
axioms.</li>
<li>An algorithm that can give a yes/no answer.</li>
</ul></li>
</ul>
<h2 id="church-rosser-theorem">Church-Rosser theorem</h2>
<p>Related to lambda calculus.</p>
<p>If two different β-reductions upon a term terminate, then they
terminate in the same term.</p>
<pre><code>   e1
 ↗   ↘
e     e&#39;
 ↘   ↗
   e2 
</code></pre>
<p>References:</p>
<ul>
<li><a
href="https://www.cse.iitk.ac.in/users/karkare/Talks/FPIntro.pdf">https://www.cse.iitk.ac.in/users/karkare/Talks/FPIntro.pdf</a></li>
<li><a
href="https://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem">https://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem</a></li>
</ul>
<h2 id="logic-1">Logic</h2>
<h2 id="red-black-trees">Red-black trees</h2>
<ul>
<li>A balanced binary search tree (that means elements are sorted).</li>
<li>Better performance than AVL trees.</li>
</ul>
<p>From <a
href="https://www.cis.upenn.edu/~sweirich/talks/icfp14.pdf">here</a>:</p>
<ul>
<li>Root is black</li>
<li>Leaves are black</li>
<li>Children of a red node are black</li>
<li>Path from any node to a leaf has same number of black nodes</li>
</ul>
<pre><code>             B        
             |
     +-------+------+
     |              |
     R              B
     |              |
+----+----+         +-----+
|         |               |
B         B               R
</code></pre>
<h2 id="compilers">Compilers</h2>
<table>
<tbody>
<tr class="odd">
<td>Lexical analysis</td>
<td>Finite state machine</td>
</tr>
<tr class="even">
<td>Syntax analysis</td>
<td>Push down automata</td>
</tr>
<tr class="odd">
<td>Code selection</td>
<td>Tree automata</td>
</tr>
</tbody>
</table>
<h2 id="kripke-structures">Kripke structures</h2>
<p>Basically the state diagrams used in model checking books.</p>
<p>Pronounced <code>/ˈkrɪpki/</code>.</p>
<h2 id="finite-automata-vs-finite-state-machine">Finite automata vs
Finite state machine</h2>
<p>Apparently the same?? Not sure…</p>
<p><a
href="https://stackoverflow.com/questions/22354706/can-anyone-please-explain-difference-between-finite-state-machine-and-finite-aut">https://stackoverflow.com/questions/22354706/can-anyone-please-explain-difference-between-finite-state-machine-and-finite-aut</a></p>
<h2 id="primitive-recursive-functions">Primitive recursive
functions</h2>
<p>Functions which are known to terminate.</p>
<p>As in a loop whose maximum possible number of iterations is known
before entering the loop.</p>
<p>(Gödel called this just 'recursive functions'. Kleene kind of renamed
it.)</p>
<h2 id="petrinet">Petrinet</h2>
<ul>
<li><p>Can model distributed systems.</p>
<ul>
<li>Advantage: Can be given a formal semantics of system execution.</li>
<li>Can have multiple concurrent activities, unlike a finite automaton
where at a time there is only one 'activity'. <a
href="https://people.cs.vt.edu/kafura/ComputationalThinking/Class-Notes/Petri-Net-Notes-Expanded.pdf">ʳ</a></li>
</ul></li>
<li><p>Named after German computer scientist Carl Adam Petri. <a
href="https://en.wikipedia.org/wiki/Petri_net">ʷ</a></p></li>
<li><p>A directed bipartite graph</p></li>
<li><p>Two kinds of nodes</p>
<ul>
<li>Places (white circle)</li>
<li>Transitions (rectangles)</li>
</ul></li>
<li><p>Arcs connect places and transitions.</p>
<ul>
<li>There can be no arcs between nodes of the same type (ie, between two
places or two transitions).</li>
</ul></li>
<li><p>A place can contain tokens (black small circles within
place).</p></li>
<li><p>A transition is enable if all places connected as input to it has
at least one token each.</p></li>
<li><p>Non-deterministic behaviour.</p>
<ul>
<li>If multiple transitions are enabled, the order in which they fire is
not predetermined.</li>
</ul></li>
<li><p>See some example petrinets <a
href="http://petrinet.org/#ProducerConsumer">here</a>.</p></li>
</ul>
<p>Definition:</p>
<p>(P, T, F)</p>
<p>where:</p>
<ul>
<li>P: set of places</li>
<li>T: set of transitions</li>
<li>F: set of arcs
<ul>
<li>F = (P⨯T) ∪ (T⨯P)</li>
</ul></li>
</ul>
<p>Variants of Petrinet:</p>
<ul>
<li>Timed/untimed</li>
<li>Coloured</li>
</ul>
<h1 id="electronics">Electronics</h1>
<h2 id="register-retiming">Register retiming</h2>
<p>Move registers to decrease the time for the critical path so that
frequency may be increased.</p>
<p>Retiming is possible only when there is sufficient slack.</p>
<pre><code>+--+   /-----\   /-----\   +--+   +--+
|R1|---| OP1 |-&gt;-| OP2 |-&gt;-|R2|-&gt;-|R3|
+--+   \-----/   \-----/   +--+   +--+
         10ns      20ns               
</code></pre>
<p>where the 'R's are registers.</p>
<p>In the above case, R1-R2 takes 10ns + 20ns = 30ns whereas R2-R3 takes
0ns (ie, we have a positive slack of 20ns in R2-R3??).</p>
<p>So one clock should be of at least 30ns.</p>
<p>That means ν = 1/(30 * 10⁻⁹) = 33.33MHz</p>
<p>Yet, if OP2 were moved to R2-R3,</p>
<pre><code>+--+   /-----\   +--+   /-----\   +--+
|R1|---| OP1 |-&gt;-|R2|-&gt;-| OP2 |-&gt;-|R3|
+--+   \-----/   +--+   \-----/   +--+
         10ns             20ns        
</code></pre>
<p>one clock need be only at least 20ns.</p>
<p>∴ ν = 1/(20 * 10⁻⁹) = 50MHz.</p>
<p>ie, we can get higher frequency of operation.</p>
<h2 id="distances">Distances</h2>
<h3 id="euclidean-distance">Euclidean distance</h3>
<ul>
<li>aka <em>Pythagorean distance</em></li>
</ul>
<pre><code>  |   |   |   |   |   |   |
5-|---|---|---|---|---|---|
  |   |   |   |   |   |   |
4-|---|---|---|---|---|---|
  |   |   |   |   |   |   |
3-|---|---|---|---▄---|---|
  |   |   |   | ▄▀|   |   |
2-|---|---|---▄▀--|---|---|
  |   |   | ▄▀|   |   |   |
1-|---|---▄▀--|---|---|---|
  |   | ▄▀|   |   |   |   |
0-|---|▀--|---|---|---|---|
  0   1   2   3   4   5   6

(1,0) to  (4,3)
</code></pre>
<h3 id="manhattan-distance">Manhattan distance</h3>
<ul>
<li>aka Taxicab distance</li>
<li>Often used in intergrated circuits where the wires can run only
parallel to the X and Y axes (ie, rectilinear).
<ul>
<li><a
href="https://xlinux.nist.gov/dads/HTML/manhattanDistance.html">https://xlinux.nist.gov/dads/HTML/manhattanDistance.html</a></li>
<li><a
href="https://xlinux.nist.gov/dads/HTML/rectilinear.html">https://xlinux.nist.gov/dads/HTML/rectilinear.html</a></li>
</ul></li>
</ul>
<pre><code>  |   |   |   |   |   |   |             |   |   |   |   |   |   |
5-|---|---|---|---|---|---|           5-|---|---|---|---|---|---|
  |   |   |   |   |   |   |             |   |   |   |   |   |   |
4-|---|---|---|---|---|---|           4-|---|---|---|---|---|---|
  |   |   |   |   |   |   |             |   |   |   |   |   |   |
3-|---┏━━━━━━━━━━━━---|---|           3-|---|---|---┏━━━━---|---|
  |   ┃   |   |   |   |   |             |   |   |   ┃   |   |   |
2-|---┃---|---|---|---|---|           2-|---|---┏━━━┛---|---|---|
  |   ┃   |   |   |   |   |             |   |   ┃   |   |   |   |
1-|---┃---|---|---|---|---|           1-|---┏━━━┛---|---|---|---|
  |   ┃   |   |   |   |   |             |   ┃   |   |   |   |   |
0-|---┃---|---|---|---|---|           0-|---┃---|---|---|---|---|
  0   1   2   3   4   5   6             0   1   2   3   4   5   6



  |   |   |   |   |   |   |             |   |   |   |   |   |   |
5-|---|---|---|---|---|---|           5-|---|---|---|---|---|---|
  |   |   |   |   |   |   |             |   |   |   |   |   |   |
4-|---|---|---|---|---|---|           4-|---|---|---|---|---|---|
  |   |   |   |   |   |   |             |   |   |   |   |   |   |
3-|---|---|---┏━━━━---|---|           3-|---|---|---|---┃---|---|
  |   |   |   ┃   |   |   |             |   |   |   |   ┃   |   |
2-|---|---|---┃---|---|---|           2-|---|---|---|---┃---|---|
  |   |   |   ┃   |   |   |             |   |   |   |   ┃   |   |
1-|---┏━━━━━━━┛---|---|---|           1-|---|---|---|---┃---|---|
  |   ┃   |   |   |   |   |             |   |   |   |   ┃   |   |
0-|---┃---|---|---|---|---|           0-|---━━━━━━━━━━━━┛---|---|
  0   1   2   3   4   5   6             0   1   2   3   4   5   6

(1,0) to  (4,3)
</code></pre>
<p>The name comes from Manhattan, New York where the buildings were
arranged in a grid layout and the shortest path a taxicab could take
between two locations was precisely the 'Manhattan distance'. [¹][1]</p>
<p>It's like all the squares are buildings and the lines of the grid are
roads.</p>
<p>To navigate between the different road junctions, a taxi would have
to go around the 'buildings'.</p>
<p>Hence the nick name 'taxicab distance', I guess.</p>
<h3 id="chebyshev-distance">Chebyshev distance</h3>
<ul>
<li>aka <em>Chessboard distance</em>.</li>
<li>Named after the Russian mathematician Pafnuty Chebyshev.</li>
</ul>
<pre><code>+---+---+---+---+---+---+---+---+
| 3 | 3 | 3 | 3 | 3 | 3 | 3 | 4 |
|---+---+---+---+---+---+---+---+
| 3 | 2 | 2 | 2 | 2 | 2 | 3 | 4 |
|---+---+---+---+---+---+---+---+
| 3 | 2 | 1 | 1 | 1 | 2 | 3 | 4 |
|---+---+---+---+---+---+---+---+
| 3 | 2 | 1 | 𝐾 | 1 | 2 | 3 | 4 |
|---+---+---+---+---+---+---+---+
| 3 | 2 | 1 | 1 | 1 | 2 | 3 | 4 |
|---+---+---+---+---+---+---+---+
| 3 | 2 | 2 | 2 | 2 | 2 | 3 | 4 |
|---+---+---+---+---+---+---+---+
| 3 | 3 | 3 | 3 | 3 | 3 | 3 | 4 |
|---+---+---+---+---+---+---+---+
| 4 | 4 | 4 | 4 | 4 | 4 | 4 | 4 |
+---+---+---+---+---+---+---+---+
</code></pre>
<p>See:</p>
<ul>
<li><a
href="https://en.wikipedia.org/wiki/Chebyshev_distance">https://en.wikipedia.org/wiki/Chebyshev_distance</a></li>
<li><a
href="https://en.wikipedia.org/wiki/Pafnuty_Chebyshev">https://en.wikipedia.org/wiki/Pafnuty_Chebyshev</a></li>
</ul>
<h3 id="minkowski">Minkowski</h3>
<ul>
<li>aka Lₘ distance.</li>
</ul>
<p><a
href="https://xlinux.nist.gov/dads/HTML/lmdistance.html">https://xlinux.nist.gov/dads/HTML/lmdistance.html</a></p>
<h1 id="sat-smt">SAT-SMT</h1>
<p><a
href="https://cacm.acm.org/research/the-silent-revolution-of-sat/">https://cacm.acm.org/research/the-silent-revolution-of-sat/</a></p>
<p>–</p>
<p>From <em>Handbook of Satisfiability</em> by Armin Biere, Marijn
Heule, Hans van Maaren, Toby Walsh:</p>
<blockquote>
<p>In its broadest sense, a pseudo-Boolean function is a function that
maps n Boolean values to a real number. … … Pseudo-Boolean constraints
offer a more expressive and natural way to express constraints than
clauses and yet, this formalism remains close enough to the SAT problem
to benefit from the recent advances in SAT solving.</p>
</blockquote>
<ul>
<li>Cook-Levine theorem: Boolean satisfiability problem is
NP-complete.</li>
</ul>
<h2 id="linear-pb-constaints">Linear PB constaints</h2>
<pre><code>Σ aⱼlⱼ   operator   b
j

where
 - aⱼ,b ∈ ℤ
 - lⱼ are literals
 - operator ∈ {=, ≥, ≤, &lt;, &gt;}
</code></pre>
<p>RHS of the constraint (ie, <code>b</code> here) is known as the
<strong>degree</strong> of the constraint.</p>
<h2 id="notations-abbreviations-and-some-terms">Notations, abbreviations
and some terms</h2>
<ul>
<li><p>PB: Pseudo-boolean</p></li>
<li><p>QBF: Quantified boolean formula</p></li>
<li><p>LPB: Linear pseudo-boolean</p></li>
<li><p>Literal</p>
<ul>
<li>Eg: x, x̅</li>
</ul></li>
<li><p>Clause</p>
<ul>
<li>Eg: x ∨ y</li>
</ul></li>
</ul>
<h2 id="resolution">Resolution</h2>
<ul>
<li>A refutation system
<ul>
<li>ie, can say if a list of clauses is unsat.</li>
</ul></li>
</ul>
<pre><code> a ∨ x         b ∨ x̅
─────────────────────
        a ∨ b
</code></pre>
<p>where <code>a ∨ b</code> is the <em>resolvent</em> over
<code>x</code> of <code>a ∨ x</code> and <code>b ∨ x̅</code>.</p>
<p>Because we need both <code>a ∨ x</code> and <code>b ∨ x̅</code> to be
true.</p>
<p>3 variables =&gt; 8 possibilities:</p>
<table>
<tbody>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>p = (a∨x)</td>
<td>q =</td>
<td></td>
</tr>
<tr class="even">
<td>a</td>
<td>x</td>
<td>b</td>
<td>x̅</td>
<td>a ∨ x</td>
<td>b ∨ x̅</td>
<td>∧ (b∨x̅)</td>
<td>a ∨ b</td>
<td>p → q</td>
</tr>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb28"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>sage: <span class="im">import</span> sage.logic.propcalc <span class="im">as</span> propcalc</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>sage: f <span class="op">=</span> propcalc.formula(<span class="st">&quot;((a|x) &amp; (b|(~x))) -&gt; (a|b)&quot;</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>sage: f.truthtable()</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>a      x      b      value</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="va">False</span>  <span class="va">False</span>  <span class="va">False</span>  <span class="va">True</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="va">False</span>  <span class="va">False</span>  <span class="va">True</span>   <span class="va">True</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="va">False</span>  <span class="va">True</span>   <span class="va">False</span>  <span class="va">True</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="va">False</span>  <span class="va">True</span>   <span class="va">True</span>   <span class="va">True</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="va">True</span>   <span class="va">False</span>  <span class="va">False</span>  <span class="va">True</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="va">True</span>   <span class="va">False</span>  <span class="va">True</span>   <span class="va">True</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="va">True</span>   <span class="va">True</span>   <span class="va">False</span>  <span class="va">True</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="va">True</span>   <span class="va">True</span>   <span class="va">True</span>   <span class="va">True</span></span></code></pre></div>
<p>—</p>
<p>Consider a CNF from <em>Handbook of satisfiability</em> (2e, Chapter
7):</p>
<pre><code>(x ∨ y) ∧ (x ∨ y̅ ∨ z) ∧ (x̅ ∨ z) ∧ (y ∨ z̅) ∧ (y̅ ∨ z̅)
</code></pre>
<p>Each clause is something that must necessarily hold (ie, like an
axiom).</p>
<table>
<tbody>
<tr class="odd">
<td>1</td>
<td>(x ∨ y)</td>
<td>Axiom</td>
</tr>
<tr class="even">
<td>2</td>
<td>(x ∨ y̅ ∨ z)</td>
<td>Axiom</td>
</tr>
<tr class="odd">
<td>3</td>
<td>(x̅ ∨ z)</td>
<td>Axiom</td>
</tr>
<tr class="even">
<td>4</td>
<td>(y ∨ z̅)</td>
<td>Axiom</td>
</tr>
<tr class="odd">
<td>5</td>
<td>(y̅ ∨ z̅)</td>
<td>Axiom</td>
</tr>
<tr class="even">
<td>6</td>
<td>(y ∨ z)</td>
<td>Res(1,3)</td>
</tr>
<tr class="odd">
<td>7</td>
<td>(y̅ ∨ z)</td>
<td>Res(2,3)</td>
</tr>
<tr class="even">
<td>8</td>
<td>z</td>
<td>Res(6,7)</td>
</tr>
<tr class="odd">
<td>9</td>
<td>z̅</td>
<td>Res(4,5)</td>
</tr>
<tr class="even">
<td>10</td>
<td>⊥</td>
<td>Res(8,9)</td>
</tr>
</tbody>
</table>
<p>Since ⊥ is derivable, this CNF is unsat.</p>
<h2 id="more">More</h2>
<ul>
<li>Davis-Putnam + LL</li>
<li>Conflict-Driven Clause Learning</li>
</ul>
<h1 id="tech">Tech</h1>
<h2 id="utf-8">UTF-8</h2>
<p>(From computerphile video on UTF-8)</p>
<p>ASCII</p>
<ul>
<li>7 bits</li>
<li>First 32 points are control codes.</li>
<li>Made this possible: A: 0b1000001 (65)</li>
<li>Look at the last number to get nth letter.</li>
<li>Lowercase letters start 32 bits later, which makes this possible:
<ul>
<li>a: 0b1100001 (97)</li>
</ul></li>
</ul>
<p>8-bit codes</p>
<ul>
<li>more codepoints but still had disadvantages.</li>
<li>not standardized.</li>
<li>Extended ASCII is one of these.</li>
<li>not compatible with each other.</li>
<li>lot of extra work.</li>
<li>still not enough code points for all the languages in the world</li>
<li>Japan had multiple codes
<ul>
<li>mojibake: garbled nonsensical text when one code is interpreted as
another</li>
<li><a
href="https://en.wikipedia.org/wiki/Mojibake">https://en.wikipedia.org/wiki/Mojibake</a></li>
</ul></li>
</ul>
<p>Unicode:</p>
<ul>
<li>to have a common standard</li>
<li>UTF-8: one of unicode formats?
<ul>
<li>What's the difference between UTF-16 and UTF-32?</li>
</ul></li>
</ul>
<p>UTF-8:</p>
<ul>
<li>Latin letters is still like 7-bit ASCII
<ul>
<li>Put a leading zero to ASCII</li>
</ul></li>
<li>Avoids wastage when compared to naïve implementation</li>
<li>NULL is 8 zeros in a row in legacy computers</li>
<li>Encoding
<ul>
<li>110: start of a new character which is 2 bytes long</li>
<li>10: is a continuation of previous block</li>
<li>1110: start of a new character which is 3 bytes long</li>
<li>Has upto 6 bytes long code points</li>
</ul></li>
</ul>
<h2 id="ipv4-vs-ipv6">IPv4 vs IPv6</h2>
<ul>
<li><code>0.0.0.0</code>: local network
<ul>
<li>If a device has this address, it often means that it is not
connected</li>
</ul>
to a TCP/IP network</li>
<li><code>127.0.0.1</code>: common loopback address
<ul>
<li>Looks like the whole <code>127.0.0.0</code> to
<code>127.0.0.255</code> range is available for loopback addresses</li>
<li>ipv6: <code>::1/128</code></li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th>v4</th>
<th>v6</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>32 bits</td>
<td>128 bits</td>
</tr>
<tr class="even">
<td>4 numbers</td>
<td>8 numbers</td>
</tr>
<tr class="odd">
<td>decimal numbers</td>
<td>hexadecimal numbers</td>
</tr>
<tr class="even">
<td>0-255 numbers</td>
<td>0x0-0xffff numbers</td>
</tr>
<tr class="odd">
<td>127.0.0.1</td>
<td>::1</td>
</tr>
<tr class="even">
<td>CIDR mask</td>
<td>Prefix length</td>
</tr>
<tr class="odd">
<td>Mask: 0-32</td>
<td>Prefix: 0-128</td>
</tr>
</tbody>
</table>
<h2 id="json-vs-yaml">JSON vs YAML</h2>
<ul>
<li>YAML: allows comments</li>
<li>YAML can be thought of as a superset of JSON</li>
<li>Prefer JSON for relatively simpler structures</li>
<li>'Yaml bomb' possible in YAML due to recursive definition</li>
<li>Tab character not allowed in YAML ??
<ul>
<li><a
href="https://yaml.org/faq.html">https://yaml.org/faq.html</a></li>
</ul></li>
</ul>
<p><a
href="https://stackoverflow.com/questions/1726802/what-is-the-difference-between-yaml-and-json">https://stackoverflow.com/questions/1726802/what-is-the-difference-between-yaml-and-json</a></p>
<h1 id="stuff-that-i-would-like-to-know-more-about">Stuff that I would
like to know more about</h1>
<ul>
<li>Monadic second order logic</li>
<li>How did something as rational as logic evolve out of
philosophy?</li>
<li>What's the use of considering NFAs instead of DFAs?
<ul>
<li>Less number of states?</li>
<li>We can't have a physical implementation of NFA, although such
concepts probably came in before computers were invented.</li>
</ul></li>
<li>Monad in category theory
<ul>
<li>Haskell, fine. Got it. But what about in math?</li>
</ul></li>
<li>Spectroscopy</li>
</ul>
</div>
</body>
</html>
