<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Coalgebraic Semantics</title>
  <style>
    body {
      max-width: 38rem;
      padding: 2rem;
      margin: auto;
      background-color: #FAF0E6;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
  </style>

</head>
<body>


<div id="header">
<a href="https://ju-sh.github.io">Home</a>
 | 
<a href="https://ju-sh.github.io/blog/index.html">Blog</a>
 | 
<a href="https://ju-sh.github.io/wiki/index.html">Wiki</a>
 | 
<a href="https://ju-sh.github.io/about.html">About</a>
</div>

<header id="title-block-header">
<h1 class="title">Coalgebraic Semantics</h1>
</header>

<ul>
    </ul>




<hr/>

<div id="content-container">
<p>Based on vidoes of <a href="https://www.cs.uoregon.edu/research/summerschool/summer19/topics.php#Silva">lectures</a> by Alexandra Silva at OPLSS-2019.</p>
<p>Mistakes my own.</p>
<h1 id="l1">L1</h1>
<p>Coinduction: Same thing but infinite number of times.</p>
<ul>
<li>Inductive: constructors</li>
<li>Coinductive: destructors
<ul>
<li>Destructors are a way of observing the infinite sequence.</li>
</ul></li>
</ul>
<p>Set of infinite sequences over a set A:</p>
<pre><code>A^Ï‰ = {Ïƒ | Ïƒ: â„• â†’ A}
</code></pre>
<pre><code>Ïƒ = (Ïƒ0, Ïƒ1, Ïƒ2, ...)
head(Ïƒ) = Ïƒ0
tail(Ïƒ) = (Ïƒ1, Ïƒ2, ...)

tail(Ïƒ)(n) = (Ïƒn+1, Ïƒn+2, ...) = âˆ€n,Ïƒ(n+1)
</code></pre>
<p>Using these destructors, let's try defining a few functions:</p>
<pre><code>even: A^Ï‰ â†’ A^Ï‰
even(Ïƒ)(n) = âˆ€n,Ïƒ(2n)

odd: A^Ï‰ â†’ A^Ï‰
odd(Ïƒ)(n) = âˆ€n,Ïƒ(2n+1)
</code></pre>
<p>Let's try a merge. As in</p>
<pre><code>merge: A^Ï‰ * A^Ï‰ â†’ A^Ï‰
(Ïƒ0, Ïƒ1, ..) * (Ï„0, Ï„1, ..) â†¦ (Ïƒ0, Ï„0, Ïƒ1, Ï„1, ..)
</code></pre>
<p>Got to be like:</p>
<pre><code>merge: A^Ï‰ * A^Ï‰ â†’ A^Ï‰
merge(Ïƒ,Ï„)(n) = Ïƒ(n/2) if n is even
               | Ï„((n-1)/2) if n is odd
</code></pre>
<p>Or to be define more mathematically (inductively??), in terms of <code>hd</code> and <code>tl</code>,</p>
<pre><code>hd(merge(Ïƒ,Ï„)) = hd(Ïƒ)
tl(merge(Ïƒ,Ï„)) = merge(Ï„, tl(Ïƒ))
</code></pre>
<p>Wow.. we can define functions operating with infinite streams just by having destructors which can be used to observe the stream at various points.</p>
<p>Some more stuff:</p>
<pre><code>hd(even(Ïƒ)) = hd(Ïƒ)
tl(even(Ïƒ)) = odd(tl(Ïƒ))
            = even(tl(tl(Ïƒ)))


hd(odd(Ïƒ)) = hd(tl(Ïƒ))
tl(odd(Ïƒ)) = even(tl(tl(tl(Ïƒ))))
             tl(even(tl(Ïƒ)))
</code></pre>
<p>The following should be true:</p>
<pre><code>merge(even(Ïƒ), odd(Ïƒ)) = Ïƒ
even(merge(Ïƒ,Ï„)) = Ïƒ
odd(merge(Ïƒ,Ï„)) = Ï„
</code></pre>
<p>so we need to prove that</p>
<pre><code>âˆ€nâˆˆâ„•, lhs(n) = rhs(n)
</code></pre>
<p>Starting with <code>merge(even(Ïƒ), odd(Ïƒ)) = Ïƒ</code>,</p>
<pre><code>âˆ€nâˆˆâ„•, Ï(n) = Ïƒ(n)

where

Ï = merge(even(Ïƒ), odd(Ïƒ))

Induction.

Ï(0) = hd(Ï)
     = hd(merge(even(Ïƒ), odd(Ïƒ)))
     = hd(even(Ïƒ))
     = hd(Ïƒ)
     = Ïƒ(0)

We got induction hypothesis as:

Ï(n) = merge(even(Ïƒ), odd(Ïƒ))(n)

Now for the induction step,

Ï(n+1) = tl(Ï)(n)
       = tl(merge(even(Ïƒ), odd(Ïƒ))(n)
       = merge(odd(Ïƒ), tl(even(Ïƒ)))(n)
       = merge(odd(Ïƒ), tl(odd(tl(Ïƒ))))(n)
       = merge(even(tl(Ïƒ)), tl(odd(tl(Ïƒ))))(n)
       ...
       = tl(Ï)(n)
       = Ï(n+1)
</code></pre>
<p>ie, we need to come back where we started. But how to close the gap? Non-trivially.</p>
<p>â€”</p>
<p>Let's try proving</p>
<pre><code>even(merge(Ïƒ,Ï„)) = Ïƒ

Let Ï = even(merge(Ïƒ,Ï„))

Ï(0) = hd(Ï)
     = hd(even(merge(Ïƒ,Ï„)))
     = hd(merge(Ïƒ,Ï„))
     = hd(Ïƒ)
     = Ïƒ(0)

IH is: Ï(n) = Ïƒ(n)

Induction step:

Ï(n+1) = even(merge(Ïƒ,Ï„))(n+1)
       = merge(Ïƒ,Ï„)(2(n+1))

       = tl(even(merge(Ïƒ,Ï„)))(n)
       = odd(tl(even(merge(Ïƒ,Ï„))))(n)
       = ...
       = Ïƒ(n+1)
</code></pre>
<p>What we had been trying was <strong>bisimulation</strong>.</p>
<p>A relation R âŠ† A<sup>Ï‰</sup> x A<sup>Ï‰</sup> is a bisimulation if âˆ€ (Ïƒ,Ï„) âˆˆ R:</p>
<ul>
<li>Ïƒ(0) = Ï„(0)</li>
<li>(tl(Ïƒ), tl(Ï„)) âˆˆ R</li>
</ul>
<p>(we can't say equality for the tail parts. so we say that in terms of R itself.)</p>
<p><strong>Coinduction</strong>:</p>
<pre><code>Ïƒ ~ Ï„  =&gt; Ïƒ = Ï„
</code></pre>
<p>where <code>Ïƒ ~ Ï„</code> means that there is a bisumulation relation <code>R</code> such that <code>(Ïƒ,Ï„) âˆˆ R</code>.</p>
<p>Dexter Kozen quote:</p>
<blockquote>
<p>A proof is valid by induction if you have a good reason for the proof to be valid.</p>
<p>A proof is valid by coinduction if you don't have any good reason for the proof not to be valid.</p>
</blockquote>
<p>This is so because in a proof by coinduction, we are trying to see if there are counter-examples.</p>
<p>In coinduction, we try to show that there is no good reason to say that the statement is invalid.</p>
<h1 id="l2">L2</h1>
<p>A DFA is a pair <code>S, &lt;o,t&gt;)</code> where:</p>
<ul>
<li><code>S</code>: set of state</li>
<li><code>o: S â†’ 2</code>: output function
<ul>
<li>Tells if a state is a final state</li>
<li>The <code>2</code> is like <code>ğ”¹</code>. It's just <code>{0,1}</code>.</li>
<li>For <code>F âŠ† S</code>, <code>o_F</code> is the characteristic function of the set <code>F</code> of final states.</li>
</ul></li>
<li><code>t: S â†’ Sá´¬</code>: next state function
<ul>
<li>Tells what are the next state(s)</li>
<li>Transition function. When I get a value in <code>a:A</code> while at a state <code>sâˆˆS</code>, <code>s:Sá´¬</code> is the next state (since it's a DFA, only one next state).</li>
<li><code>A</code> is the alphabet. ie, a finite set of terminal symbols.</li>
</ul></li>
</ul>
<p>Note that we didn't say anything about the initial state.</p>
<p>â€”</p>
<ul>
<li><code>A*</code> can be defined as an inductive type.</li>
<li><code>2^(A*)</code> can be defined as a coinductive type. ??</li>
</ul>
<p>A word <code>w âˆˆ A*</code> is accepted at a state <code>s âˆˆ S</code> if:</p>
<ul>
<li><code>w=Îµ</code> and <code>o(s)=1</code></li>
<li><code>w=au</code> and <code>u</code> is accepted by the state <code>t(s)(a)</code></li>
</ul>
<p>Another way to define word acceptance:</p>
<p>If we have:</p>
<p>t:Sâ¨¯A â†’ S</p>
<p>we can inductively extend it to:</p>
<p>tÌ‚:Sâ¨¯(A*) â†’ S tÌ‚(s)(Îµ) = s (no change in state. DFA =&gt; no Îµ-transitions) tÌ‚(s)(au) = tÌ‚[t(s)(a)][u]</p>
<p>Then we can say that <code>w</code> is accepted by a state <code>s</code> if <code>o(tÌ‚(s)(w))</code> is 1.</p>
</div>
</body>
</html>
