<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Theory of computation</title>
  <style>
    body {
      max-width: 38rem;
      padding: 2rem;
      margin: auto;
      background-color: #FAF0E6;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
  </style>

</head>
<body>


<div id="header">
<a href="https://ju-sh.github.io">Home</a>
 | 
<a href="https://ju-sh.github.io/blog/index.html">Blog</a>
 | 
<a href="https://ju-sh.github.io/wiki/index.html">Wiki</a>
 | 
<a href="https://ju-sh.github.io/about.html">About</a>
</div>

<header id="title-block-header">
<h1 class="title">Theory of computation</h1>
</header>

<ul>
    </ul>




<hr/>

<div id="content-container">
<h2 id="general">General</h2>
<ul>
<li>Kleene's theorem: establishes equivalence between FA and regular
languages</li>
<li>Regular languages: aka rational languages</li>
</ul>
<ul>
<li>A 2-stack DPDA is as powerful as a deterministic TM. <a
href="https://stackoverflow.com/questions/62083942/can-a-pda-with-two-stacks-accept-re-language">¬≤</a></li>
<li><code>a‚Åøcb‚Åø</code> is a CFL but not regular.</li>
<li><code>a‚Åøb‚Åøc‚Åø</code> is neither a CFL nor a regular language.</li>
<li><a
href="https://en.wikipedia.org/wiki/Decider_(Turing_machine)">Total
Turing machine</a>: A TM that <em>always</em> halts.
<ul>
<li>ie, for any input.</li>
<li>Represents a total function that finishes.</li>
</ul></li>
<li>Medvedev machine:
<ul>
<li>An FSM where output is the current state</li>
<li>There is no separate output logic</li>
<li>Like a restricted form of Moore machine</li>
<li><a
href="https://www.vhdl-online.de/courses/system_design/synthesis/finite_state_machines_and_vhdl/medvedev">https://www.vhdl-online.de/courses/system_design/synthesis/finite_state_machines_and_vhdl/medvedev</a></li>
</ul></li>
</ul>
<h2 id="turing-machine">Turing machine</h2>
<p>One-tape turing machine is a 7-tuple:</p>
<p>M = (Q, Œì, b, Œ£, Œ¥, q‚ÇÄ, F)</p>
<ul>
<li>Q: set of states</li>
<li>Œì: Tape alphabet.
<ul>
<li>The set of symbols that can show up in the tape</li>
</ul></li>
<li>b: blank symbol.
<ul>
<li>b‚ààŒì</li>
</ul></li>
<li>Œ£: input alphabet
<ul>
<li>Œ£ ‚äÜ (Œì \ {b})</li>
</ul></li>
<li>Œ¥: transition function
<ul>
<li>Œ¥:</li>
</ul></li>
<li>q‚ÇÄ: initial state</li>
<li>F: set of final states</li>
</ul>
<h2 id="dpda-vs-npda">DPDA vs NPDA</h2>
<p>Unlike in the case of finite automata, DPDA are NPDA are not
equivalent.</p>
<p>For example, <code>ww·¥ø</code> can be accepted by a NPDA but no DPDA
can handle it.</p>
<p>‚àµ the time to switch from the 'w-mode' to the 'w·¥ø-mode' cannot be
figured out deterministically since there is no delimiter. The
possiblity always has to be explored.</p>
<p><code>wcw·¥ø</code> can be handled by DPDA if <code>c ‚àâ w</code>.</p>
<h2 id="halting-problem">Halting problem</h2>
<p>Problem: For a specific input, will the Turing machine halt (ie,
finish computing and give a result)?</p>
<p>For a given word and a Turing machine, there is no way to definitely
tell whether the Turing machine will aceept that word (ie, halt) or
not.</p>
<p>From Sipser:</p>
<blockquote>
<p>recognizers are more powerful than deciders</p>
</blockquote>
<h2 id="universal-turing-machine">Universal Turing machine</h2>
<p>A TM capable of simulating any TM.</p>
<h2 id="pumping-lemma-for-regular-languages">Pumping lemma for regular
languages</h2>
<ul>
<li>Can be used to show that a language is not regular.</li>
<li>Can't be used to show that a language is regular.</li>
</ul>
<p>The lemma:</p>
<ul>
<li><code>L</code>: the language</li>
<li><code>s</code>: a string of <code>L</code></li>
</ul>
<p>‚àÉn‚àà‚Ñï such that for any <code>s ‚àà L</code>:</p>
<ul>
<li>|s| ‚â• n</li>
<li>s = xyz
<ul>
<li>|y| &gt; 0</li>
<li>|xy| ‚â§ n</li>
</ul></li>
</ul>
<p>Then,</p>
<pre><code>‚àÄi‚â•0, xy‚Å±z ‚àà L
</code></pre>
<p>if <code>L</code> is regular.</p>
<p>Proof (informal):</p>
<p>Let</p>
<ul>
<li><code>M</code> be the DFA accepting string of <code>L</code></li>
<li><code>n</code> be the number of states of <code>M</code></li>
<li><code>s ‚àà L</code> such that <code>|s| ‚â• n</code></li>
</ul>
<p>From: <a
href="https://www2.lawrence.edu/fast/GREGGJ/CMSC515/chapt01/Pumping.html">https://www2.lawrence.edu/fast/GREGGJ/CMSC515/chapt01/Pumping.html</a></p>
<h2 id="context-free-languages">Context free languages</h2>
<p>An example CFL: <code>a‚Åøb‚Åø</code> where n‚â•0.</p>
<p>CFG:</p>
<pre><code>S -&gt; aSb | Œµ
</code></pre>
<p>if only n&gt;0 is allowed, the grammar could be like:</p>
<pre><code>S -&gt; aSb | ab
</code></pre>
<p>‚Äî</p>
<p>If <code>w ‚àà {a,b}</code>,</p>
<p><code>wcw·¥ø</code> is a CFL:</p>
<pre><code>S -&gt; aSa | bSb | c
</code></pre>
<p>but <code>wcw</code> is not a CFL.</p>
<p>‚àµ the stack can only be popped in last-in-first-out order.
<code>wcw</code> requires FIFO order.</p>
<p>‚Äî</p>
<p><code>a‚Åøb‚Åøc·µê</code> where n‚â•0, m‚â•0 is a D-CFL.</p>
<pre><code>S = IE
I = aIb | Œµ
E = cE | Œµ
</code></pre>
<h2 id="masters-theorem">Master's theorem</h2>
<p>Expressed as a recurrence relation.</p>
<p>A task of size <code>n</code> can be divided into <code>k</code>
sub-tasks each of size <code>n/b</code>.</p>
<p>The results of these sub-tasks are then combined in
<code>ùëÇ(n·µà)</code> time to get the final result.</p>
<pre><code>T(n) = k.T(n/b) + ùëÇ(n·µà)
</code></pre>
<h2 id="properties-of-languages">Properties of languages</h2>
<p>From <a
href="https://www.geeksforgeeks.org/closure-properties-table-in-toc/">here</a>:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>RL</th>
<th>DCFL</th>
<th>NCFL</th>
<th>CSL</th>
<th>RL</th>
<th>REL</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Union</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Complement</td>
<td>Y<a
href="https://www2.lawrence.edu/fast/GREGGJ/CMSC515/chapt01/Regular.html">‚Å∂</a></td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Intersection</td>
<td>Y</td>
<td>N ?</td>
<td>N ?</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Concatentation</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Kleene star</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="star-free-languages">Star free languages</h2>
<p>Reference: <a
href="https://www.irif.fr/~jep/PDF/MPRI/MPRI.pdf">https://www.irif.fr/~jep/PDF/MPRI/MPRI.pdf</a></p>
<p>Given:</p>
<ul>
<li>Œ£: finite alphabet</li>
</ul>
<p>then set L of star-free languges within Œ£* is the smallest set such
that:</p>
<table>
<tbody>
<tr class="odd">
<td>‚àÖ ‚àà L</td>
<td>Includes empty language</td>
</tr>
<tr class="even">
<td>{Œµ} ‚àà L</td>
<td>Includes language with only empty word</td>
</tr>
<tr class="odd">
<td>(a ‚àà Œ£) -&gt; {a} ‚àà L</td>
<td>ie, a uni-symbol word language</td>
</tr>
</tbody>
</table>
<p>and is closed under</p>
<ul>
<li>finite union</li>
<li>finite product/concatentation</li>
<li>complementation (this one is unlike normal regex)</li>
</ul>
<p>Examples:</p>
<ul>
<li>Œ£* is star free.
<ul>
<li>Œ£* = ‚àÖ·∂ú</li>
</ul></li>
</ul>
<p>Doubts:</p>
<ul>
<li>Star free languages over Œ£ ‚äÜ languages over Œ£</li>
</ul>
<p>I guess this type in coq can represent star-free languages over
Œ£:</p>
<pre class="coq"><code>Inductive t (Œ£: Type): Type :=
| Nul: t Œ£
| Nil: t Œ£
| Char: Œ£ -&gt; t Œ£
| Cat: t Œ£ -&gt; t Œ£ -&gt; t Œ£
| Alt: t Œ£ -&gt; t Œ£ -&gt; t Œ£
| Cmp: t Œ£ -&gt; t Œ£.
</code></pre>
<p>Kamp's theorem: LTL properties are equivalent to star-free
languages</p>
<table>
<thead>
<tr class="header">
<th>LTL</th>
<th>Star-free</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>¬¨p</td>
<td>p·∂ú</td>
</tr>
<tr class="even">
<td>p ‚à® q</td>
<td>p + q</td>
</tr>
<tr class="odd">
<td>X p</td>
<td>true; p</td>
</tr>
<tr class="even">
<td>p U q</td>
<td>p*;q</td>
</tr>
</tbody>
</table>
<p><code>a*</code> is star free for any finite alphabet. <code>a*</code>
being same as <code>(Œ£* \ a*)</code></p>
<p><a
href="https://cs.stackexchange.com/questions/10768/star-free-language-vs-regular-language">https://cs.stackexchange.com/questions/10768/star-free-language-vs-regular-language</a></p>
<pre><code>Œ£* = ‚àÖ·∂ú

a* = (Œ£* (Œ£ \ a) Œ£*)·∂ú
   = (‚àÖ·∂ú (Œ£ \ a) ‚àÖ·∂ú)·∂ú
</code></pre>
<p>‚Äî</p>
<p>LTL:</p>
<pre><code>p := prop
   | ¬¨p
   | p ‚à® p
   | X p
   | p U p


G p = p U ‚ä•
</code></pre>
<h2 id="linear-temporal-logic-ltl">Linear Temporal Logic (LTL)</h2>
<table>
<thead>
<tr class="header">
<th>Symbol</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>b</td>
<td>Boolean expression</td>
</tr>
<tr class="even">
<td>¬¨ p</td>
<td>Not</td>
</tr>
<tr class="odd">
<td>X p</td>
<td>Next</td>
</tr>
<tr class="even">
<td>p ‚à® q</td>
<td>Or</td>
</tr>
<tr class="odd">
<td>p U q</td>
<td>Until (strong)</td>
</tr>
</tbody>
</table>
<p>Derived operations:</p>
<table>
<thead>
<tr class="header">
<th>Symbol</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>G p</td>
<td>Global</td>
</tr>
<tr class="even">
<td>F p</td>
<td>Finally</td>
</tr>
<tr class="odd">
<td>p ‚àß q</td>
<td>Or</td>
</tr>
<tr class="even">
<td>p M q</td>
<td>Release (strong)</td>
</tr>
</tbody>
</table>
<h3 id="past-time-ltl-pltl">Past-time LTL (pLTL)</h3>
<p>Has:</p>
<table>
<thead>
<tr class="header">
<th>Symbol</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>p S q</code></td>
<td>since</td>
</tr>
<tr class="even">
<td><code>P p</code></td>
<td>previously</td>
</tr>
</tbody>
</table>
<p>PLTL is as expressive as LTL but properties can be much more
succinct.</p>
<p><code>p S q</code> is like <code>q+p.*</code> (or in PSL style,
<code>q+p[*]</code>).</p>
<ul>
<li><a
href="https://people.irisa.fr/Nicolas.Markey/PDF/MyPapers/eatcs-bull79">https://people.irisa.fr/Nicolas.Markey/PDF/MyPapers/eatcs-bull79</a>()-Mar.pdf</li>
</ul>
<h3 id="metric-tl-mtl">Metric TL (MTL)</h3>
<p>Has interval for U and F in LTL.</p>
</div>
</body>
</html>
