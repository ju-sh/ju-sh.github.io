<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Logic notes</title>
  <style>
    body {
      max-width: 38rem;
      padding: 2rem;
      margin: auto;
      background-color: #FAF0E6;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
  </style>

</head>
<body>


<div id="header">
<a href="https://rawtext.club/~famubu">Home</a>
 | 
<a href="https://rawtext.club/~famubu/blog/index.html">Blog</a>
 | 
<a href="https://rawtext.club/~famubu/wiki/index.html">Wiki</a>
 | 
<a href="https://rawtext.club/~famubu/about.html">About</a>
</div>

<header id="title-block-header">
<h1 class="title">Logic notes</h1>
</header>

<ul>
    </ul>




<div id="content-container">
<p>Based on a part of <a
href="https://gitlab.com/piyush-kurur/logic/-/raw/master/notes/transcripts.org">a
series of lectures</a> given by <a
href="https://www.imsc.res.in/r_ramanujam">Prof. R. Ramanujam</a> <a
href="https://www.imsc.res.in/">The Institute of Mathematical
Sciences</a>, Chennai.</p>
<p>From what I understood. May be terribly wrong.</p>
<p>Corrections appreciated!</p>
<hr />
<h1 id="languages-of-logic">Languages of logic</h1>
<h2 id="desirable-properties">Desirable properties</h2>
<p>We need to define the language precisely, unambiguously and with as
few logical resources as possible.</p>
<ul>
<li>must be able to describe math structures</li>
<li>must be minimal (only what's needed. With as few primitives as
possible.)</li>
</ul>
<p>Given multiplication, we can implement divides like</p>
<p>b divides a = (âˆƒk a = kb)</p>
<p><strong><strong>TODO</strong></strong>: Implement subtraction using
addition.</p>
<p>a - b = a + (a * (b-1))</p>
<p><strong><strong>TODO</strong></strong>: Implement addition using
subtraction.</p>
<p>a + b = a - (0 - b)</p>
<p><strong><strong>TODO</strong></strong>: Implement multiplication
using addition.</p>
<p>a * b = a + (a * (b-1))</p>
<p><strong><strong>TODO</strong></strong>: Implement exponentiation
using multiplication.</p>
<p>a ^ b = a * (a ^ (b-1))</p>
<p>A predicate prime() could be defined as</p>
<p>prime(p) :: (k divides p) â†’ ((k = 1) âˆ¨ (k = p)) = âˆ€k âˆˆ â„• (âˆƒn âˆˆ â„• (p =
nk) â†’ ((k = 1) âˆ¨ (k = p)))</p>
<p>(1 divides p) and (p divides p)</p>
<p>A predicate even() could be defined as</p>
<p>even(n) :: âˆ€n âˆ€a âˆƒb (n = ab) â†’ (a = 2)</p>
<p>or just using addition like</p>
<p>even(n) :: âˆ€n âˆƒm (n = m + m)</p>
<p>Similarly, a predicate odd() could be defined as</p>
<p>odd(n) :: Â¬(âˆ€n âˆƒm n = m + m)</p>
<p>m &lt; n could be defined like</p>
<p>&lt;(m,n) :: âˆ€m âˆˆ â„• âˆ€n âˆˆ â„• âˆƒk âˆˆ â„• (n = m + k)</p>
<p>Sir has done it as</p>
<p>âˆƒk (n = m + k) âˆ§ (k â‰  0)</p>
<p>m &gt; n could be defined like</p>
<p>âˆƒk (n+k = m) âˆ§ (k â‰  0)</p>
<p>or just define it in terms of &lt; as</p>
<p>&gt;(m,n) :: &lt;(n,m) Logicians don't like 'operator overloading'
kind of stuff. Because it creates lot of sources of confusion. We need a
precise meaning.</p>
<p>Predicate to check whether a number is zero:</p>
<p>zero(n) :: âˆ€k âˆˆ â„• (k + n = n)</p>
<p>Can we define plus(n,m) using &lt;(n,m) (ie, can addition be defined
using order)?</p>
<p><u>No</u>. Why?</p>
<p>Because addition returns a number, whereas order returns a truth
value.</p>
<ul>
<li><strong><strong>Descriptive complexity</strong></strong>.</li>
<li><strong><strong>Logic resources</strong></strong>.</li>
<li><strong><strong>Definability</strong></strong>: What things are
definable? We need to show proof as well.</li>
</ul>
<ul>
<li><p>Gottlobe Frege</p></li>
<li><p>Tarski</p></li>
<li><p>Dense linear order</p></li>
</ul>
<h1 id="first-order-logic">First order logic</h1>
<p>aka:</p>
<ul>
<li>predicate logic</li>
<li>first-order predicate logic</li>
<li>quantificational logic</li>
</ul>
<p>We wanna deal with statements that are true or false.</p>
<p><strong><strong>Note</strong></strong>: RDBMS can be described using
a first order language.</p>
<p>(Signature of a) Language of (Peano) arithmetic:</p>
<p>L = (R, F, C)</p>
<p>where</p>
<ul>
<li><code>C = {0}  // zero</code></li>
<li><code>F = {Succ, +, ^, x, ..}</code></li>
<li><code>R = {&lt;, =, ..}  // Predicate symbols</code></li>
</ul>
<p>The predicates give a (Boolean?) truth value. Whereas the functions
give another term.</p>
<p>Language of graphs:</p>
<ul>
<li><code>C = âˆ…</code></li>
<li><code>F = âˆ…</code></li>
<li><code>R = {EÂ²}  // E is set of edges</code></li>
</ul>
<p>The predicate <code>E(x,y)</code> could mean there is a directed edge
from vertex <code>x</code> to vertex <code>y</code>.</p>
<p>Then <code>âˆ€y E(x,y)</code> means that the vertex <code>x</code> is
connected to all other vertices in the graph.</p>
<p><code>Â¬( âˆƒy E(x,y) )</code> :: the statement 'for some vertex y,
there is an edge from vertex x to vertex y' is false.</p>
<p>That means <code>âˆ€y Â¬E(x,y)</code> ie, the outdegree of the vertex x
is zero.</p>
<p>Language of orders:</p>
<ul>
<li><code>C = âˆ…</code></li>
<li><code>F = âˆ…</code></li>
<li><code>R = {&lt;Â²}  // &lt; is the ordering</code></li>
</ul>
<p>Language of sets:</p>
<ul>
<li><code>C = âˆ…</code></li>
<li><code>F = âˆ…</code></li>
<li><code>R = {âˆˆÂ²}  // âˆˆ is the membership function</code></li>
</ul>
<p>Here we could define <code>x âŠ† t</code> as:</p>
<p>X âŠ† Y â‰¡ âˆ€Z ((Z âˆˆ X) â†’ (Z âˆˆ Y))</p>
<p>Language of groups:</p>
<ul>
<li><code>C = âˆ…</code></li>
<li><code>F = {dot}</code></li>
<li><code>R = âˆ…</code></li>
</ul>
<p>We don't even need an explicit identity element, we can define it in
terms of dot like</p>
<p>âˆƒx âˆ€y (xâ€¢y = y and yâ€¢x = y)</p>
<p>A first order language (FOL) is defined by its <u>parameters</u>.</p>
<h1 id="syntax">Syntax</h1>
<p>Specifies the formulas (ie, how formulas can be formed)</p>
<p>Using the syntax we can see if a formula is well-formed.</p>
<p>Can find parsing errors?</p>
<p>A structure. An <u>inductive</u> structure.</p>
<p>L = (R, F, C)</p>
<p>where</p>
<ul>
<li><code>R</code>: A (countable) set or predicate (or relation) symbols
each of which has an arity. (Examples: <code>&lt;</code> (binary),
<code>âˆˆ</code> (binary), <code>prime(x)</code> (unary)).</li>
<li><code>F</code>: A (countable) set of function symbols each of which
has an arity.</li>
<li><code>C</code>: A (countable) set of Constant symbols (not
constants. Symbols denoting constants. Could 'zero' which stands for
0)</li>
</ul>
<p>Then there are:</p>
<ul>
<li><code>Terms(L)</code>: Terms of the language <code>L</code></li>
<li><code>Vars(L)</code>: Set of variables</li>
</ul>
<p><strong><strong>Note</strong></strong>: <code>R = F = C = âˆ…</code> is
an empty language.</p>
<ul>
<li>Language of arithmetic =&gt; <code>R â‰  âˆ…</code>, <code>F â‰  âˆ…</code>,
<code>C â‰  âˆ…</code></li>
<li>Language of groups =&gt; <code>R â‰  âˆ…</code>,
<code>F = C = âˆ…</code></li>
<li>Language of orders =&gt; <code>F â‰  âˆ…</code>,
<code>R = C = âˆ…</code></li>
</ul>
<h2 id="statements">Statements</h2>
<h3 id="primitive-statements">Primitive statements</h3>
<p>Equations</p>
<p>x = y x = y + 5 (plus comes from F and 3 comes from C</p>
<p>x, y x, y+5</p>
<p>And regarding predicate/relational symbols,</p>
<p><code>âˆ€ráµ âˆˆ R</code> with arity <code>k</code> and
<code>tâ‚, tâ‚‚, .., tâ‚– âˆˆ Terms(L)</code>, then
<code>r(tâ‚, tâ‚‚, ..., tâ‚–)</code> is a primitive statement.</p>
<p>Like</p>
<p>(x + y) âˆˆ Terms(L) and f(g(y,x)) âˆˆ Terms(L), then (x + y) &lt;
f(g(y,x))</p>
<h3 id="compound-statements">Compound statements</h3>
<p>Combine primitive statements to build more (using connectives).</p>
<p>If <code>Î±</code>, <code>Î²</code> are statements then so are:</p>
<ul>
<li><p>Propositional logic (or Boolean logic??) connectives:</p>
<ul>
<li><code>Î± âˆ§ Î²</code> (conjunction): a binary connective</li>
<li><code>Î± âˆ¨ Î²</code> (disjunction): a binary connective</li>
<li><code>Î± â†’ Î²</code> (implies. aka <code>âŠƒ</code>): a binary
connective</li>
<li><code>Î± â†”ï¸ Î²</code> (iff. ie, equivalence. aka <code>â‰¡</code>): a
binary connective</li>
<li><code>Â¬Î±</code> (negation): a unary connective</li>
</ul></li>
<li><p>Quantifiers (the <code>x âˆˆ V</code> is substituted in place of
variables in <code>Î±</code>):</p>
<ul>
<li><code>âˆ€x Î±</code> (universal quantifier)</li>
<li><code>âˆƒx Î±</code> (existential quantifier)</li>
</ul></li>
</ul>
<p>For example, the following is a statement</p>
<p>âˆ€x âˆ€y (Î± âˆ§ Î²)</p>
<p>Because, <code>Î±</code> and <code>Î²</code> are statements.</p>
<p>That means <code>Î± âˆ§ Î²</code> is also a statement.</p>
<p>That in turn means <code>âˆ€y (Î± âˆ§ Î²)</code> is a statement,</p>
<p>which in turn means <code>âˆ€x âˆ€y (Î± âˆ§ Î²)</code> is a statement.</p>
<h2 id="variables">Variables</h2>
<p>A countable set of variables associated with the FOL language.</p>
<p><strong><strong>BNF</strong></strong>: Backus-Naur Form</p>
<h1 id="syntax-of-fol-using-bnf">Syntax of FOL using BNF</h1>
<p>L = (R, F, C) V = set of variables</p>
<p>t âˆˆ Terms(L) ::=</p>
<table>
<tbody>
<tr class="odd">
<td>c âˆˆ C</td>
</tr>
<tr class="even">
<td>v âˆˆ V</td>
</tr>
<tr class="odd">
<td>fáµ(tâ‚, tâ‚‚, .. , tâ‚–), fáµ âˆˆ F</td>
</tr>
</tbody>
</table>
<p>Î±, Î² âˆˆ Î¦(L) ::=</p>
<table>
<tbody>
<tr class="odd">
<td>tâ‚ = tâ‚‚ â« atomic formulas</td>
</tr>
<tr class="even">
<td>ráµ(tâ‚, tâ‚‚, .. , tâ‚–), ráµ âˆˆ R â­</td>
</tr>
<tr class="odd">
<td>Â¬Î±</td>
</tr>
<tr class="even">
<td>Î± âˆ§ Î²</td>
</tr>
<tr class="odd">
<td>Î± âˆ¨ Î²</td>
</tr>
<tr class="even">
<td>Î± â†’ Î²</td>
</tr>
<tr class="odd">
<td>Î± â‰¡ Î²</td>
</tr>
<tr class="even">
<td>âˆ€x Î±</td>
</tr>
<tr class="odd">
<td>âˆƒx Î±</td>
</tr>
</tbody>
</table>
<p>The '::=' denotes an inductive definition.</p>
<h3 id="examples-syntax-of-language-of-order">Examples: Syntax of
language of order</h3>
<h3
id="x-y-z-x-y-y-z-x-z"><code>âˆ€x âˆ€y âˆ€z (x &lt; y) âˆ§ (y &lt; z) â†’ (x &lt; z)</code></h3>
<p><code>âˆ€x âˆ€y âˆ€z (x &lt; y) âˆ§ (y &lt; z) â†’ (x &lt; z)</code> is a
formula.</p>
<p>This can be broken down like</p>
<pre><code>    âˆ€x âˆ€y âˆ€z (x &lt; y) âˆ§ (y &lt; z) â†’ (x &lt; z)  âœ“
       ---------------------------------

    âˆ€x âˆ€y âˆ€z (x &lt; y) âˆ§ (y &lt; z) â†’ (x &lt; z)  âœ“
          ------------------------------

    âˆ€x âˆ€y âˆ€z (x &lt; y) âˆ§ (y &lt; z) â†’ (x &lt; z)  âœ“
             ---------------------------

    âˆ€x âˆ€y âˆ€z (x &lt; y) âˆ§ (y &lt; z) â†’ (x &lt; z)  âœ“
             --                         

    âˆ€x âˆ€y âˆ€z (x &lt; y) âˆ§ (y &lt; z) â†’ (x &lt; z)  âœ“
                  --                    

    âˆ€x âˆ€y âˆ€z (x &lt; y) âˆ§ (y &lt; z) â†’ (x &lt; z)  âœ“
             -------                    

    âˆ€x âˆ€y âˆ€z (x &lt; y) âˆ§ (y &lt; z) â†’ (x &lt; z)  âœ“
                       --               

    âˆ€x âˆ€y âˆ€z (x &lt; y) âˆ§ (y &lt; z) â†’ (x &lt; z)  âœ“
                            --          

    âˆ€x âˆ€y âˆ€z (x &lt; y) âˆ§ (y &lt; z) â†’ (x &lt; z)  âœ“
                       -------          

    âˆ€x âˆ€y âˆ€z (x &lt; y) âˆ§ (y &lt; z) â†’ (x &lt; z)  âœ“
                                 --     

    âˆ€x âˆ€y âˆ€z (x &lt; y) âˆ§ (y &lt; z) â†’ (x &lt; z)  âœ“
                                      --

    âˆ€x âˆ€y âˆ€z (x &lt; y) âˆ§ (y &lt; z) â†’ (x &lt; z)  âœ“

ie,

                  âˆ€x  
                  â”ƒ           
                  âˆ€y          
                  â”ƒ           
                  âˆ€z
                  â”ƒ
                  â†’
                  â”ƒ
            â”â”â”â”â”â”â”»â”â”â”â”â”â”â”“ 
            â”ƒ            â”ƒ 
            âˆ§            â”ƒ        
            â”ƒ            â”ƒ    
       â”â”â”â”â”â”»â”â”â”â”“        â”ƒ        
       â”ƒ        â”ƒ        â”ƒ      
       &lt;        &lt;        &lt;     
       â”ƒ        â”ƒ        â”ƒ     
    â”â”â”â”»â”â”â”“  â”â”â”â”»â”â”â”“  â”â”â”â”»â”â”â”“  
    x     y  y     z  x     z    
</code></pre>
<h3 id="x-x-y"><code>âˆ€x x &lt; âˆƒy</code></h3>
<p><code>âˆ€x x &lt; âˆƒy</code> is not a formula.</p>
<p>This can be broken down like</p>
<pre><code>âˆ€x (x &lt; âˆƒy)  âœ“
   --------

âˆ€x (x) &lt; âˆƒy) âœ“
   ---

âˆ€x (x) &lt; âˆƒy) âœ—
</code></pre>
<p>ie,</p>
<pre><code>   âˆ€x
   â”ƒ
   &lt;
   â”ƒ
â”â”â”â”»â”â”â”“
x     âœ— ERROR
</code></pre>
<p>because <code>âˆƒy</code> by itself is not a member of
<code>Terms(L)</code>.</p>
<p>âˆ´ <code>(âˆ€x x &lt; âˆƒy)</code> is not a formula.</p>
<h2 id="algorithm-to-parse-the-syntax-tree">Algorithm to parse the
syntax tree</h2>
<ul>
<li>Natural data structure: Tree representation of <code>Î±</code></li>
<li>Length of input string: Number of nodes in the tree representation
of <code>Î±</code></li>
<li>Terms will be sub-trees.</li>
</ul>
<p>Running time: <code>O(n)</code> because we need to visit all nodes at
least once.</p>
<p><strong><strong>TODO</strong></strong>: Write a recurrence relation
for it.</p>
<p><strong><strong>TODO</strong></strong>: Write algorithm to check if a
string/formula is in FO formula.</p>
<h2 id="term">Term</h2>
<p>Terms(L) =</p>
<table>
<tbody>
<tr class="odd">
<td>fáµ(tâ‚, â€¦, tâ‚–) âˆˆ F // ie, a k-ary function</td>
</tr>
<tr class="even">
<td>v âˆˆ V</td>
</tr>
<tr class="odd">
<td>c âˆˆ C</td>
</tr>
</tbody>
</table>
<p>Can be represented as a tree whose:</p>
<ul>
<li>internal nodes are functional symbols</li>
<li>leaf nodes are constants or variables</li>
</ul>
<h2 id="formula-Ï†l">Formula Î¦(L)</h2>
<p>Formulas(L) = // given any two terms âˆˆ Terms(L), we can say they are
equal</p>
<table>
<tbody>
<tr class="odd">
<td>tâ‚ = tâ‚‚</td>
</tr>
</tbody>
</table>
<p>// if we already have k terms âˆˆ Terms(L) and there is a relation
symbol // (or predicate symbol??) r âˆˆ R of arity k</p>
<table>
<tbody>
<tr class="odd">
<td>ráµ(tâ‚, â€¦, tâ‚–) âˆˆ R</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td>âˆ€Î± Î² âˆˆ Formulas(L), Î± âˆ¨ Î²</td>
</tr>
<tr class="even">
<td>âˆ€Î± Î² âˆˆ Formulas(L), Î± âˆ§ Î²</td>
</tr>
<tr class="odd">
<td>âˆ€Î± Î² âˆˆ Formulas(L), Î± â†’ Î²</td>
</tr>
<tr class="even">
<td>âˆ€Î± Î² âˆˆ Formulas(L), Î± â‰¡ Î²</td>
</tr>
<tr class="odd">
<td>âˆ€x Formulas(L), Â¬ Î±</td>
</tr>
<tr class="even">
<td>âˆ€Î± Î² âˆˆ Formulas(L), âˆ€x Î±</td>
</tr>
<tr class="odd">
<td>âˆ€Î± Î² âˆˆ Formulas(L), âˆƒx Î±</td>
</tr>
</tbody>
</table>
<p>Can be represented as a tree whose:</p>
<ul>
<li>internal nodes are connectors or quantifiers</li>
<li>leaf nodes are atomic formulas (equality and relations??) which are
then applied to terms.</li>
</ul>
<p><code>|Î±|</code> = number of nodes in the tree representation of
<code>Î±</code>.</p>
<h1 id="semantics">Semantics</h1>
<p>Assign meaning to the structure that we defined using the syntax.</p>
<p>We decide this meaning. Like setting the context. :-)</p>
<p>So we know what is true and what is wrong.</p>
<p>For example,</p>
<p>âˆ€x âˆ€y, prime(x) â†’ odd(x)</p>
<p>is false for <code>x=2</code>.</p>
<p>'mostly true', but still not true.</p>
<p>But,</p>
<pre><code>âˆ€x âˆ€y, prime(x) â†’ green(x)
</code></pre>
<p>makes no sense (ie, sounds meaningless). How can a number be of a
certain colourâ€¦ :-)</p>
<p>But this could be meaningful depending on the semantics that we
define.</p>
<p>And what about</p>
<pre><code>large( pow(10, pow(10, pow(10))) )
</code></pre>
<p>Is it true?</p>
<p>It depends on our definition <code>large()</code>.</p>
<p>Try</p>
<pre><code>large(x) â†’ large(x - 1)
</code></pre>
<p>If we defined <code>large(x)</code> as</p>
<pre><code>large(x) = 
| x &gt;= 1000 =&gt; true
| otherwise =&gt; false
</code></pre>
<p>and <code>x</code> was <code>1000</code>, it would be false.</p>
<p>(Again,) the truth value depends on our definition of
<code>large()</code>.</p>
<p>But if had just said</p>
<pre><code>âˆ€x, large(x) â†’ large(x-1)
</code></pre>
<p><code>large(x)</code> is true for any value of <code>x</code>,
because it says <code>âˆ€x</code>.</p>
<p>So even <code>large(-1000)</code> would be true.</p>
<p><strong><strong>Vague predicate</strong></strong>: difficult to say
whether the statement is true or false.</p>
<p>Another example,</p>
<pre><code>âˆ€x âˆƒy, x = yÂ²
</code></pre>
<p>is false, if <code>x</code> and <code>y</code> are natural numbers
but true if they are real numbers.</p>
<p>ie, it is true in <em>some</em> structure.</p>
<blockquote>
<p>Truth depends on the underlying structure.</p>
</blockquote>
<p>Truth is a relation (between structures and sentences) here, not
something like a judgement.</p>
<h1 id="truth">Truth</h1>
<p>Not a judgement.</p>
<p>Simply a relation between structures and sentences (sentences aka
statements)</p>
<pre><code>structure âŠ¨ sentence   // or âŠ¨ (structure, sentence)
</code></pre>
<h1 id="structure">Structure</h1>
<pre><code>S = (D, I)
</code></pre>
<p>where:</p>
<ul>
<li>D: domain</li>
<li>I: interpretation function</li>
</ul>
<p>Examples:</p>
<table>
<thead>
<tr class="header">
<th>Language</th>
<th>Structure</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Arithmetic</td>
<td>Number line (ie, the set of all real numbers??)</td>
</tr>
<tr class="even">
<td>Groups</td>
<td>Set of all groups</td>
</tr>
<tr class="odd">
<td>Graphs</td>
<td>Set of all graphs</td>
</tr>
<tr class="even">
<td>Orders</td>
<td>Set on which the order is imposed</td>
</tr>
</tbody>
</table>
<p>Structure for a language L = an <strong><strong>L-
structure</strong></strong>.</p>
<h2 id="domain">Domain</h2>
<p>From where the elements come from.</p>
<h2 id="interpretation">Interpretation</h2>
<p>Interprets the symbols.</p>
<pre><code>I = (IR, IF, IC)
</code></pre>
<p>where:</p>
<ul>
<li>IC: Interpretation for constant symbols</li>
<li>IF: Interpretation for function symbols</li>
<li>IR: Interpretation for predicate/relational symbols</li>
</ul>
<h3 id="interpretation-of-constant-symbols-ic">Interpretation of
constant symbols (IC)</h3>
<p>Every constant symbol is also an element of the domain.</p>
<p>So,</p>
<pre><code>IC: C â†’ D
</code></pre>
<h3 id="interpretation-of-function-symbols">Interpretation of function
symbols</h3>
<p>Each function symbol is a k-ary function. ie, its arity is k.</p>
<pre><code>IF: fáµ â†¦ (Dáµ â†’ D)
</code></pre>
<p>ie, a function of arity k takes k elements of the domain and produces
a mapping to a single element of the domain.</p>
<p>For example, <code>fáµ</code> could be a plus function of arity 2
defined on <code>â„•</code>, in which it would be
<code>fÂ²: (â„•xâ„• â†’ â„•)</code></p>
<h3 id="interpretation-for-predicaterelational-symbols">Interpretation
for predicate/relational symbols</h3>
<p>where each predicate/relation symbol is of arity k.</p>
<pre><code>IR: ráµ â†¦ (Dáµ â†’ {0, 1})
</code></pre>
<p>0 means false and 1 means true here.</p>
<p>In</p>
<pre><code>âˆ€x âˆ€y, x = y
</code></pre>
<p>the domain consists of just one element (since there cannot be two
elements with same value) or it could be empty.</p>
<p>So here, the domain has at most 1 element.</p>
<h2 id="formulas">Formulas</h2>
<p>Simplest atomic formula is equality??</p>
<p>Like</p>
<pre><code>xÂ³ + yÂ³ = zÂ³
</code></pre>
<p>where <code>tâ‚ = xÂ³ + yÂ³</code> and <code>tâ‚‚ = zÂ³</code></p>
<p>(and <code>+</code> is addition, <code>xÂ³</code> is
<code>x * x * x</code>, etc)</p>
<p>After assigning values to variables and functions, we can evaluate
the terms!</p>
<p>Suppose <code>D</code> is <code>â„</code>, <code>áµ: â„áµ â†’ â„</code> and
<code>+: â„Â² â†’ â„</code>.</p>
<h1 id="model-m">Model (M)</h1>
<pre><code>M = (S, Ï€)
</code></pre>
<p>where</p>
<ul>
<li><code>S</code>: structure</li>
<li><code>Ï€: V â†’ D</code>: Assignment. ie, assigns variables to values
in the domain</li>
</ul>
<p><code>Ï€</code> is also known as an <strong><strong>environment /
valuation</strong></strong>.</p>
<p>We can extend (or 'lift') this <code>Ï€</code> to a <code>Ï€^</code>
like</p>
<pre><code>Ï€^: Terms(L) â†’ D
</code></pre>
<p>because once we get the assignment map for the variables, we can use
it to evaluate the terms as well since the terms use variables.</p>
<p>Each term <code>t âˆˆ Terms(L)</code> is evaluated to produce an
element in the domain <code>D</code>.</p>
<ul>
<li><code>âˆ€c âˆˆ C, Ï€^(c) = IC(c)</code></li>
<li><code>âˆ€v âˆˆ V, Ï€^(v) = IV(v)</code></li>
<li><code>âˆ€f âˆˆ F, Ï€^(f(tâ‚,.., tâ‚–)) = IF(f)(Ï€^(tâ‚), ..., Ï€^(tâ‚))</code></li>
</ul>
<p>About the last one, the terms given as argument of f are all
evaluated (by applying <code>Ï€^</code>) to produce values in
<code>D</code>. These resultant values are then given as the argument of
the function given as the interpretation of <code>f</code>.</p>
<p>If an <code>Î±</code> satisfies a model <code>M</code>, we say
<code>M âŠ¨ Î±</code>. ie, <code>M</code> makes <code>Î±</code> true.</p>
<p>A relation between models and formulas (ie,
<code>(M x Formulas) â†’ ğ”¹</code>).</p>
<p>Model for a language <code>L</code> is an
<strong><strong>L-model</strong></strong>.</p>
<p><code>M âŠ¨ Î±</code> is between the class of all <code>L</code>-models
and all formulas in <code>L</code>.</p>
<ul>
<li>Compositionality: Meaning of the formulas is built
compositionally.</li>
<li>Inductive definitions</li>
</ul>
<p>Programming languages are built compositionally.</p>
<p>Most formal languages are built compositionally.</p>
<p>Logic is closely related to linguisitcs.</p>
<p>But logic insists of compositional semantics: meanings given
compositionally.</p>
<p>And natural language is highly non-compositional.</p>
<h2 id="atomic-formulas">Atomic formulas</h2>
<blockquote>
<p><code>M âŠ¨ tâ‚ = tâ‚‚ iff Ï€^(tâ‚) = Ï€^(tâ‚‚)</code></p>
</blockquote>
<p>Here, <code>tâ‚ = tâ‚‚</code> is something that is something in
<code>L</code> where <code>Ï€^(tâ‚)</code> = <code>Ï€^(tâ‚‚)</code> is in the
domain <code>D</code>.</p>
<blockquote>
<p><code>M âŠ¨ ráµ(tâ‚, ..., tâ‚–) iff IP(r)(Ï€^(tâ‚), ..., Ï€^(tâ‚–))  // a map from Dáµ â†’ {0, 1}</code></p>
</blockquote>
<p>0 means it's in the relation and 1 means otherwise.</p>
<h3 id="section">.</h3>
<ol>
<li><p>.</p>
<p>Now <code>Î± = Â¬Î²</code>,</p>
<p>M âŠ¨ Â¬Î² iff M âŠ­ Î²</p></li>
<li><p>.</p>
<p>M âŠ¨ Î± âˆ§ Î² iff (M âŠ¨ Î±) and (M âŠ¨ Î²)</p>
<p>The 'and' here is in the meta-language.</p></li>
<li><p>.</p>
<p>M âŠ¨ Î± âˆ¨ Î² iff (M âŠ¨ Î±) or (M âŠ¨ Î²)</p>
<p>The 'or' here is the mathematical OR. (Why???)</p></li>
<li><p>Implication</p>
<p>M âŠ¨ Î± â†’ Î² iff whenever M âŠ¨ Î±, we also have (M âŠ¨ Î²)</p>
<p>ie, <code>(M âŠ¨ Î±) âˆ§ (M âŠ­ Î²)</code> is not possible.</p></li>
<li><p>Equivalence</p>
<p>M âŠ¨ Î± â‰¡ Î² iff M âŠ¨ Î± exactly when M âŠ¨ Î²</p>
<p>ie, following are impossible:</p>
<ul>
<li><code>(M âŠ¨ Î±) âˆ§ (M âŠ­ Î²)</code></li>
<li><code>(M âŠ­ Î±) âˆ§ (M âŠ¨ Î²)</code></li>
</ul></li>
<li><p>Universal quantifier</p>
<p>M âŠ¨ âˆ€x Î± iff for all d âˆˆ D.</p>
<p><code>âˆ€x</code> means <code>âˆ€d, d âˆˆ D</code>. Every possible value in
the domain.</p>
<p>Substitute all occurrences of <code>x</code> in <code>Î±</code> with
terms defined over <code>D</code>. We can't just substitute elements in
<code>D</code>.</p>
<p>The definition is like <code>C â†’ D</code> not <code>D â†’ C</code>.</p>
<p>So we can't say something like</p>
<p>M âŠ¨ Î±[x/d]</p></li>
<li><p>Existential quantifier</p>
<p>M âŠ¨ âˆƒx, Î± iff</p>
<p><strong><strong>TODO</strong></strong>: Given an M and a formula Î±,
is M âŠ¨ Î± true? (Algorithm: Truth definition)</p>
<hr />
<table>
<tbody>
<tr class="odd">
<td>Video 3</td>
</tr>
</tbody>
</table>
<hr />
<p>M âŠ¨ Î± iff M âŠ­ Î±</p>
<p>Only one of the two can (actually, must) be true, but not both (in an
'exclusive or' fashion).</p>
<ul>
<li><p><code>M âŠ¨ Â¬Î± iff M âŠ­ Î±</code></p></li>
<li><p><code>M âŠ¨ Î± âˆ¨ Î² iff M âŠ¨ Î± or M âŠ¨ Î²</code></p></li>
<li><p><code>M âŠ¨ Î± âˆ§ Î² iff M âŠ¨ Î± and M âŠ¨ Î²</code></p></li>
<li><p><code>M âŠ¨ Î± â†’ Î² iff whenever M âŠ¨ Î± then also M âŠ¨ Î²</code></p></li>
<li><p><code>M âŠ¨ Î±  â‰¡ Î² iff succeeds only when both Î± and Î² are equivalent</code>.
Either both are true or both are false.</p></li>
<li><p><code>M âŠ­ Î± âˆ¨ Î² iff M âŠ­ Î± and M âŠ­ Î²</code></p></li>
<li><p><code>M âŠ­ Î± âˆ§ Î² iff M âŠ­ Î± or M âŠ­ Î²</code></p></li>
<li><p><code>M âŠ­ Î± â†’ Î² iff M âŠ¨ Î± and M âŠ­ Î²</code> (ie, fails when 'the
premise holds but the conclusion doesn't' which is same as 'the
assumption holds, but the conclusion doesn't')</p></li>
</ul>
<p><strong><strong>vacuously true</strong></strong>: <code>Î± â†’ b</code>
when <code>Â¬Î±</code></p></li>
</ol>
<h1 id="consequence-relation">Consequence relation</h1>
<p>Let <code>Î“</code> be a set of formulas</p>
<p>and <code>Î±</code> is a formula.</p>
<p>Î“ âŠ¨ Î±</p>
<h1 id="henkin-construction">Henkin construction</h1>
<p>Named after Leon Henkin</p>
<h1 id="interesting-to-note">Interesting to note</h1>
<h2 id="possible-quantifiers-other-than-and">Possible quantifiers other
than <code>âˆ€</code> and <code>âˆƒ</code></h2>
<h3 id="uniqueness-x">Uniqueness (<code>âˆƒ!x</code>)</h3>
<p>There exists one and only one <code>x</code>.</p>
<p>This can actually be implement using <code>âˆ€</code> and
<code>âˆƒ</code> itself.</p>
<p>âˆƒ!x Î±(x) â‰¡ âˆƒx(Î±(x) and âˆ€y Î±(y) â†’ y=x)</p>
<p>So we don't really need a separate <code>âˆƒ!x</code>.</p>
<h3 id="non-existence">Non-existence</h3>
<pre><code>âˆ„x
</code></pre>
<p>An <code>x</code> doesn't exist.</p>
<p>Can be implemented using <code>âˆ€</code> and <code>âˆƒ</code> like</p>
<pre><code>âˆ„x Î±(x) â‰¡ âˆ€x Â¬Î±(x)
</code></pre>
<h3 id="some-quantifiers-that-we-cant-code-up-easily-if-at-all">Some
quantifiers that we can't code up easily (if at all)</h3>
<ul>
<li>For most <code>x</code>: <code>Î±(x)</code> is true for most
<code>x</code> but not all.</li>
<li>For any random <code>x</code></li>
<li>For infinitely many <code>x</code></li>
</ul>
<h2 id="some-terms">Some terms</h2>
<ul>
<li>Claim</li>
<li>Proposition</li>
<li>Lemma</li>
<li>Theorem</li>
<li>Counter-example</li>
</ul>
<h2 id="difference-between-theorem-and-lemma">Difference between theorem
and lemma</h2>
<p>Lemma is like a 'minor-theorem' that is used to prove a theorem.</p>
<p>ie, a minor result whose sole purpose is to help proving a
theorem.</p>
<p>Lemma is a helper to a theorem.</p>
<h2 id="difference-between-axiom-and-theorem">Difference between axiom
and theorem</h2>
<p>Axiom is what is known to be (or assumed to be) true and hence
doesn't need a proof.</p>
<p>Theorem is something that we prove using axioms.</p>
<h2 id="difference-between-corollary-and-theorem">Difference between
corollary and theorem</h2>
<p>Corollary is something that can be derived trivially from a
theorem.</p>
<p>"a quick consequence of a [sic] theorem that was proven" Ref: [1] and
<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>.</p>
<h2 id="another-form-of-p-q">Another form of <code>p â†’ q</code></h2>
<p>p â†’ q â‰¡ Â¬p âˆ¨ q</p>
<h2 id="difference-between-and">Difference between <code>â†’</code> and
<code>â†¦</code></h2>
<p><code>f: x â†¦ y</code> means that <code>f</code> is a function which
takes a value <code>x</code> and produces <code>y</code>.</p>
<p>Whereas <code>f: X â†’ Y</code> says that <code>f</code> is a function
taking the set <code>X</code> as its domain and results in a value in
<code>Y</code>.</p>
<p>So, I guess it means that <code>â†¦</code> works with <em>values</em>
themselves and <code>â†’</code> works with <em>sets</em>.</p>
<p>Reference: <a
href="https://math.stackexchange.com/a/1751201">https://math.stackexchange.com/a/1751201</a></p>
<h2 id="free-variable">Free variable</h2>
<p>If a variable is not quantified, it is a free variable?</p>
<p>For example, in</p>
<pre><code>âˆ€x, x âˆ§ y
</code></pre>
<p><code>y</code> is a free variable (and <code>x</code> is a bound
variable). The sentence is equivalent to saying</p>
<pre><code>âˆ€x âˆƒy, x âˆ§ y
</code></pre>
<p>We can say something about the truth value of the sentence only after
fixing <code>y</code>.</p>
<p>(Then we can pick an <code>x</code> value and see if it is
true??)</p>
<h2 id="difference-between-statementsentence-and-formula">Difference
between statement/sentence and formula</h2>
<p>There is a slight difference.</p>
<p><strong>Formulas</strong> can have variables floating around (free
variables) as in</p>
<pre><code>âˆ€x, x = y  // y is floating
</code></pre>
<p><strong>Statements / sentences</strong> have no free variables. All
variables are bound as in</p>
<pre><code>âˆ€x âˆ€y, x = y
</code></pre>
<h2 id="difference-between-and-1">Difference between <code>=</code> and
<code>â‰¡</code></h2>
<p><code>=</code> is a stricter form of <code>â‰¡</code>.</p>
<p><code>â‰¡</code> only says equivalent, not equal.</p>
<p>Whereas <code>=</code> says equal. One and the same.</p>
<p>For example in modular arithmetic (source: <a
href="https://www.quora.com/What-are-the-differences-between-%E2%89%A1-and-symbols-in-mathematics-and-logic">https://www.quora.com/What-are-the-differences-between-%E2%89%A1-and-symbols-in-mathematics-and-logic</a>),</p>
<pre><code>26 â‰¡ 2 mod 4  // 26 has remainder 2 when divided by 4
26 â‰¡ 2 mod 8  // 26 has remainder 2 when divided by 8
</code></pre>
<p>means that both 26 and 2 give the same remainder when divided by
4.</p>
<p>That doesn't mean 26=4 or 26=8.</p>
<h1 id="dbts">Dbts</h1>
<ul>
<li>Linear orders</li>
<li>Dense linear orders</li>
<li>Equivalence class</li>
<li>In <code>âˆ€x P(x, y)</code>, how do we know what kind of value
<code>y</code> is? Is it <code>âˆ€y</code> or <code>âˆƒy</code> or something
else?</li>
</ul>
<h2 id="cnf-and-dnf">CNF and DNF</h2>
<h3 id="conjunctive-normal-form">Conjunctive Normal Form</h3>
<p>Like</p>
<p>a âˆ¨ bc âˆ¨ abd</p>
<h3 id="disjunctive-normal-form">Disjunctive Normal Form</h3>
<p>Like</p>
<p>(a âˆ¨ b)(c âˆ¨ abd)</p>
<p><code>p â†’ q â‰¡ Â¬p âˆ¨ q</code></p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><pre class="example"><code>https://math.stackexchange.com/a/2935038
</code></pre>
<a href="#fnref1" class="footnote-back" role="doc-backlink">â†©ï¸</a></li>
</ol>
</section>
</div>
</body>
</html>
