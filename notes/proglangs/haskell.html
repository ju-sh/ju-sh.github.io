<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Haskell notes</title>
  <style>
    body {
      max-width: 38rem;
      padding: 2rem;
      margin: auto;
      background-color: #FAF0E6;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
  </style>

</head>
<body>


<div id="header">
<a href="https://ju-sh.github.io">Home</a>
 | 
<a href="https://ju-sh.github.io/blog/index.html">Blog</a>
 | 
<a href="https://ju-sh.github.io/wiki/index.html">Wiki</a>
 | 
<a href="https://ju-sh.github.io/about.html">About</a>
</div>

<header id="title-block-header">
<h1 class="title">Haskell notes</h1>
</header>

<ul>
    </ul>




<div id="content-container">
<ul>
<li>Date created: April-2021</li>
<li>Last updated: Nov-2021</li>
</ul>
<p>Based on:</p>
<ul>
<li>NPTEL course <a href="https://nptel.ac.in/courses/106/106/106106137/">Functional programming in Haskell</a> by <a href="https://www.cmi.ac.in/~madhavan/">Madhav Mukund</a> and <a href="https://www.cmi.ac.in/~spsuresh/">S. P. Suresh</a> from <a href="https://www.cmi.ac.in/">Chennai Mathematical Institute, Chennai</a> (<a href="https://www.youtube.com/playlist?list=PL3pGy4HtqwD2-bYXI3_4LWQyafXp4-olc">YouTube playlist</a>)</li>
<li>Functional programming course <a href="https://bitbucket.org/piyush-kurur/functional-programming/src/master/src/corona/transcript.org">⁹</a> <a href="https://bitbucket.org/piyush-kurur/functional-programming/src/master/notes/live.org">¹⁰</a> by <a href="https://iitpkd.ac.in/people/ppk">Piyush Kurur</a> from IIT Palakkad</li>
</ul>
<hr />
<h2 id="intro">Intro</h2>
<h3 id="functions">Functions</h3>
<p>Transforms inputs to outputs.</p>
<h3 id="program">Program</h3>
<p>Rules to produce output from input.</p>
<h3 id="computation">Computation</h3>
<p>Process of applying the rules specified by the program.</p>
<h3 id="building-up-programs">Building up programs</h3>
<p>We got to start from somewhere =&gt; built-in functions.</p>
<p>Use these built-in stuff to build more complex stuff.</p>
<p>Basic operation is function composition.</p>
<h3 id="function-composition">Function composition</h3>
<p>In these examples, assume that inputs are whole numbers.</p>
<ol>
<li><p>Example: Applying same function twice</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">succ</span> n <span class="ot">=</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>plusTwo n <span class="ot">=</span> <span class="fu">succ</span> (<span class="fu">succ</span> n)</span></code></pre></div></li>
<li><p>Example: Composing with two different functions</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>plusThree n <span class="ot">=</span> <span class="fu">succ</span> (plusTwo n)</span></code></pre></div></li>
</ol>
<h3 id="defining-plus">Defining plus</h3>
<p>An inductive/recursive function definition.</p>
<ul>
<li>A base case is specified.</li>
<li>Then we define the value for larger arguments in terms of the value for smaller arguments.</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>plus n <span class="dv">0</span> <span class="ot">=</span> n</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>plus n m <span class="ot">=</span> <span class="fu">succ</span> (plus n m<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<h3 id="defining-mult">Defining mult</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>mult n <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>mult n m <span class="ot">=</span> plus n (mult n m<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<h2 id="data-types">Data types</h2>
<p>Haskell is strongly typed.</p>
<p>A type is just a set of permissible values.</p>
<p>The real successor function mean the next whole number.</p>
<p>ie,</p>
<ul>
<li><code>succ 2.6</code> is <code>3</code></li>
<li><code>succ 2.3</code> is <code>3</code></li>
<li><code>succ 2</code> is <code>3</code></li>
</ul>
<p>Representation of integers and real numbers are different in computers. So we use different data types.</p>
<p>Any function that we define in Haskell must have a well defined type.</p>
<p>The constructor names of haskell algebraic data types must start with an upper case letter. Otherwise, you'll be an error saying: <code>Not a data constructor</code></p>
<h3 id="type-of-a-function">Type of a function</h3>
<p>A function that accepts input of type <code>A</code> and outputs a value of type <code>B</code> has type <code>A → B</code>.</p>
<p>f: S → T</p>
<ul>
<li>Domain: S</li>
<li>Codomain: T</li>
<li>Range ⊆ Codomain</li>
</ul>
<h3 id="collections">Collections</h3>
<ul>
<li>Collections of values of a given type.</li>
<li>Often convenient to deal with this subset of the collection's type.</li>
<li>All values of a collection are of the same type.</li>
<li>Examples:
<ul>
<li>a list of integers</li>
<li>a sequence of strings</li>
<li>pairs of numbers (coordinates of a point)</li>
</ul></li>
</ul>
<h2 id="id-identity-function"><code>id</code>: Identity function</h2>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">id</span> <span class="dv">3</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="dv">3</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">id</span> <span class="st">&quot;Hello&quot;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a><span class="st">&quot;Hello&quot;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a></span></code></pre></div>
<h2 id="haskell">Haskell</h2>
<p>Essentially a programming language for describing functions.</p>
<p>A function description consists of two parts:</p>
<ul>
<li>type of inputs and outputs</li>
<li>rules for computing outputs from inputs</li>
</ul>
<h3 id="example-haskell-function-description">Example Haskell function description</h3>
<p>The <code>::</code> indicates that it is a type definition.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">sqr ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>  <span class="co">-- Type definition</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>sqr n <span class="ot">=</span> n <span class="op">*</span> n      <span class="co">-- Computation rule</span></span></code></pre></div>
<h3 id="basic-types-in-haskell">Basic types in Haskell</h3>
<p><strong><strong>Convention</strong></strong>: All type names start with a capital letter.</p>
<ul>
<li>Integers (<code>Int</code>)
<ul>
<li>Operations:
<ul>
<li>+, -, \*, /</li>
<li>/ gives a float. Not int.</li>
<li>Eg: 5 / 3 =&gt; 1.66666</li>
</ul></li>
<li>Functions:
<ul>
<li>div, mod</li>
<li>div gives Int itself.</li>
<li>Eg: div 5 3 =&gt; 1</li>
</ul></li>
</ul></li>
<li>Float (<code>Float</code>): real numbers</li>
<li>Characters (<code>Char</code>)
<ul>
<li>Enclosed in single quotes</li>
</ul></li>
<li>Boolean (<code>Bool</code>): <code>True</code>, <code>False</code></li>
</ul>
<h3 id="operators">Operators</h3>
<ol>
<li><p>Boolean operators</p>
<ul>
<li>&amp;&amp;</li>
<li>|| (actually, the <em>inclusive or</em>. True if one <em>or more</em> input is true).</li>
<li><code>not</code>: a function that takes a single argument</li>
</ul></li>
<li><p>Relational operators</p>
<ul>
<li><code>==</code></li>
<li><code>/=</code> (not equal to)</li>
<li><code>&lt;</code></li>
<li><code>&lt;=</code></li>
<li><code>&gt;</code></li>
<li><code>&gt;=</code></li>
</ul></li>
</ol>
<h3 id="an-xor-function">An xor function</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">xor ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>xor a b <span class="ot">=</span> (a <span class="op">&amp;&amp;</span> (<span class="fu">not</span> b)) <span class="op">||</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>          ((<span class="fu">not</span> a) <span class="op">&amp;&amp;</span> b)     <span class="co">-- Only Boolean expressions are involved here.</span></span></code></pre></div>
<h3 id="inorder-function">'inorder' function</h3>
<p>Check if three integers are in ascending order.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">inorder ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>inorder x y z <span class="ot">=</span> (x <span class="op">&lt;=</span> y) <span class="op">&amp;&amp;</span> (y <span class="op">&lt;=</span> z)</span></code></pre></div>
<h3 id="pattern-matching">Pattern matching</h3>
<p>Let's rewrite our xor function example with pattern matching.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">xor ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>xor <span class="dt">True</span>  <span class="dt">False</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>xor <span class="dt">False</span> <span class="dt">True</span>  <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>xor a     b     <span class="ot">=</span>  <span class="dt">False</span></span></code></pre></div>
<p>The definition with the first matching pattern would be used. Top to bottom.</p>
<p>If argument in function definition is:</p>
<ul>
<li>a constant: the same constant must appear in the function call.</li>
<li>a variable: any value can appear in the function call.</li>
</ul>
<h3 id="an-or-function">An 'or' function</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="fu">or</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="fu">or</span> <span class="dt">True</span> x    <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="fu">or</span> x    <span class="dt">True</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="fu">or</span> x    y    <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<h3 id="a-different-definition-of-and-function">A 'different' definition of 'and' function</h3>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="fu">and</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="fu">and</span> <span class="dt">True</span>  b <span class="ot">=</span> b</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="fu">and</span> <span class="dt">False</span> b <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<h3 id="wild-cards">Wild cards</h3>
<p>We could also write the above 'and' function definition using <strong><strong>wild cards</strong></strong>.</p>
<p>A special notation.</p>
<p>Essentially don't cares.</p>
<p>The value is not captured.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="fu">and</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="fu">and</span> <span class="dt">True</span>  b <span class="ot">=</span> b</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="fu">and</span> <span class="dt">False</span> _ <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>Similarly for the 'or' function,</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="fu">or</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="fu">or</span> <span class="dt">True</span> _    <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="fu">or</span> _    <span class="dt">True</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a><span class="fu">or</span> _    _    <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<h3 id="recursive-definitions">Recursive definitions</h3>
<ul>
<li>Base case</li>
<li>Inductive step (value for larger values in terms of smaller values)</li>
</ul>
<ol>
<li><p>A function for factorial</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="ot">fact ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>fact <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>fact n <span class="ot">=</span> n <span class="op">*</span> (fact (n <span class="op">-</span> <span class="dv">1</span>))  <span class="co">-- Note the usage of parenthesis here.</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>                             <span class="co">-- Because fact n - 1 would have been read as</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>                             <span class="co">-- (fact n) - 1, resulting in infinite recursion.</span></span></code></pre></div>
<p>But here the computation will not terminate if argument is a negative integer.</p>
<p>We can fix this using conditional definitions.</p></li>
</ol>
<h3 id="conditional-definitions">Conditional definitions</h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="ot">fact ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span class="ot">fact ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>fact <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span>                      <span class="co">-- this is pattern match</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>fact n</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>  <span class="op">|</span> n <span class="op">&lt;</span>  <span class="dv">0</span> <span class="ot">=</span> fact (<span class="op">-</span>n)          <span class="co">-- just to make this more complete</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>  <span class="op">|</span> n <span class="op">&gt;=</span> <span class="dv">0</span> <span class="ot">=</span> n <span class="op">*</span> (fact (n <span class="op">-</span> <span class="dv">1</span>))</span></code></pre></div>
<p>(Here, there are 'two' definitions.</p>
<p>The vertical bar signifies <strong><strong>options</strong></strong> aka <em>guards</em>.</p>
<p>'Guarded' by a conditional expressions.</p>
<p>Guards are tested from top to bottom.</p>
<p>Indentation matters here.</p>
<ol>
<li><p>Guards can overlap</p>
<p>Since they are evaluated from top to bottom.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">fact ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>fact n</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>  <span class="op">|</span> n <span class="op">&lt;</span>  <span class="dv">0</span> <span class="ot">=</span> fact (<span class="op">-</span>n)          <span class="co">-- just to make this more complete</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>  <span class="op">|</span> n <span class="op">&gt;</span>  <span class="dv">1</span> <span class="ot">=</span> n <span class="op">*</span> (fact (n <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>  <span class="op">|</span> n <span class="op">&gt;=</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span></code></pre></div>
<p>But guards need not cover all cases. In such a case, we may get <em>pattern match failure</em> errors.</p></li>
<li><p><code>otherwise</code> to cover remaining cases</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="ot">fact ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>fact n</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  <span class="op">|</span> n <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>  <span class="op">|</span> n <span class="op">&gt;</span> <span class="dv">0</span> <span class="ot">=</span> n <span class="op">*</span> (fact (n<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> (fact (<span class="op">-</span>n))</span></code></pre></div>
<ul>
<li>Catches all conditions. As if always True.</li>
<li>Its use ensures, for a given argument value, at least one condition would match.</li>
<li>Helps us avoid pattern match failure errors.</li>
</ul></li>
</ol>
<h2 id="ghci">ghci</h2>
<p>Colon (<code>:</code>) commands like <code>:load</code> perform internal actions of ghci. Other commands are Haskell.</p>
<h2 id="arity-of-a-function">Arity of a function</h2>
<p>Number of arguments that the function accepts.</p>
<h2 id="currying">Currying</h2>
<ul>
<li>Named after <a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a>.</li>
<li>'All functions take just one argument'.</li>
<li>A sequence of functions get created instead of a single multiple argument function.</li>
<li>Each argument transforms the function by internalizing that argument inside the function. A new function is created. That argument is hard-wired in this new function.</li>
</ul>
<h2 id="some-examples">Some examples</h2>
<h3 id="euclids-gcd-algorithm">Euclid's gcd algorithm</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="fu">gcd</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="fu">gcd</span> a <span class="dv">0</span> <span class="ot">=</span> a</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="fu">gcd</span> a b</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>  <span class="op">|</span> a <span class="op">&gt;=</span> b    <span class="ot">=</span> <span class="fu">gcd</span> b (<span class="fu">mod</span> a b)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">gcd</span> b a         <span class="co">-- call it in the right order</span></span></code></pre></div>
<h3 id="largest-divisor-of-a-number">Largest divisor of a number</h3>
<p>Other than the number itself.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="ot">largestdiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>largestdiv n <span class="ot">=</span> divsearch n (n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a><span class="co">-- auxiliary function</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a><span class="ot">divsearch ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>divsearch m n</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>  <span class="op">|</span> (<span class="fu">mod</span> m i) <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> i</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> divsearch m (i<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<p>Here we used an auxiliary function.</p>
<h3 id="integer-logarithm">Integer logarithm</h3>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="co">-- IGNORE THIS BLOCK</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="fu">log</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Fractional</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="fu">log</span> k n <span class="ot">=</span> multsearch k n <span class="dv">0</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a><span class="ot">multsearch ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Fractional</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>multsearch k n i</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>  <span class="op">|</span> k <span class="op">**</span> i <span class="op">==</span> n <span class="ot">=</span> i</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span>   <span class="ot">=</span> multsearch k n (i<span class="op">+</span><span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="co">-- IGNORE THIS BLOCK</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="co">-- logk n = y mean k^y = n</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a><span class="fu">log</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Fractional</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="fu">log</span> k n <span class="ot">=</span> divsearch k n <span class="dv">0</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a><span class="ot">divsearch ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Fractional</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>divsearch k n</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>  <span class="op">|</span> n <span class="op">/</span> k <span class="op">==</span> <span class="dv">1</span> <span class="ot">=</span> k</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a>  <span class="op">|</span></span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="co">-- intlog</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="ot">intlog ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>intlog k <span class="dv">1</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>intlog k n</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>  <span class="op">|</span> n <span class="op">&gt;=</span> k <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> intlog k (<span class="fu">div</span> n k)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dv">0</span></span></code></pre></div>
<h3 id="reverse-digits-of-an-integer">Reverse digits of an integer</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="co">-- intlog</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="ot">intlog ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>intlog k <span class="dv">1</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>intlog k n</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>  <span class="op">|</span> n <span class="op">&gt;=</span> k <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> intlog k (<span class="fu">div</span> n k)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a><span class="co">-- myversion. Probably missed something.</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a><span class="ot">intreverse ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a>intreverse n</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>  <span class="op">|</span> n <span class="op">&gt;</span> <span class="dv">0</span>     <span class="ot">=</span> (<span class="fu">mod</span> n <span class="dv">10</span>) <span class="op">*</span> (<span class="dv">10</span> <span class="op">^</span> (intlog <span class="dv">10</span> n)) <span class="op">+</span> intreverse (<span class="fu">div</span> n <span class="dv">10</span>)</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dv">0</span></span></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="co">-- Madhav sir&#39;s version</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a><span class="ot">intlog ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>intlog k <span class="dv">1</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>intlog k n</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>  <span class="op">|</span> n <span class="op">&gt;=</span> k <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> intlog k (<span class="fu">div</span> n k)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a><span class="ot">power ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a>power n <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a>power n k <span class="ot">=</span> n <span class="op">*</span> (power n (k<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a><span class="ot">intreverse ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true"></a>intreverse n</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true"></a>  <span class="op">|</span> n <span class="op">&lt;</span> <span class="dv">10</span>    <span class="ot">=</span> n</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> (intreverse (<span class="fu">div</span> n <span class="dv">10</span>)) <span class="op">+</span> </span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true"></a>                (<span class="fu">mod</span> n <span class="dv">10</span>) <span class="op">*</span> (power <span class="dv">10</span> (intlog <span class="dv">10</span> n))</span></code></pre></div>
<h2 id="lists">Lists</h2>
<p>The main data structure that Haskell uses to 'store' or collect values. All elements of a list have the same type.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">11</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>]</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>[<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">True</span>]<span class="ot"> ::</span> [<span class="dt">Bool</span>]</span></code></pre></div>
<p>The type <code>[]</code> denotes empty list, no type name there.</p>
<p><code>:</code> is right associative.</p>
<h3 id="head-and-tail-of-a-list">Head and tail of a list</h3>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="fu">head</span> (x<span class="op">:</span>xs) <span class="co">-- x</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="fu">tail</span> (x<span class="op">:</span>xs) <span class="co">-- xs</span></span></code></pre></div>
<p>Types:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="fu">head</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a><span class="fu">tail</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</span></code></pre></div>
<p>Both <code>head</code> and <code>tail</code> are undefined when the argument is an empty list.</p>
<h3 id="functions-on-list">Functions on list</h3>
<p>Induction helps.</p>
<ol>
<li><p>Example: Find length of a list</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="ot">listLength ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>listLength [] <span class="ot">=</span> <span class="dv">0</span> </span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>listLength x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> listLength (<span class="fu">tail</span> x)</span></code></pre></div>
<p>Or with</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="ot">listLength ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>listLength [] <span class="ot">=</span> <span class="dv">0</span> </span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>listLength (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> listLength xs</span></code></pre></div>
<p>We need the parenthesis in <code>listLength (x:xs)</code> as function application (<code>:</code> here) has a higher precedence.</p></li>
<li><p>Example: Sum of values in a list</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="ot">mySum ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>mySum [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>mySum (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">+</span> mySum xs</span></code></pre></div></li>
</ol>
<h3 id="list-indexing">List indexing</h3>
<ul>
<li>Indexing starts from 0.</li>
<li>Can be indexed like list[j].</li>
<li>list[j] takes time proportional to the index j.</li>
<li>Needs to apply the <code>:</code> function j times.</li>
<li>Not really random access unlike in the case of arrays.</li>
<li>Lists are internally represented in a 'canonical way', using the <code>:</code> function to build them up.</li>
</ul>
<h3 id="list-notation">List notation</h3>
<ul>
<li>[m..n] gives [m, m+1, m+2, …, n-1, n]</li>
<li>Inclusive of both limits.</li>
<li>Empty list if n&lt;m.</li>
<li>Eg: [1..4] -&gt; [1,2,3,4]</li>
</ul>
<ol>
<li><p>With step value</p>
<p>'Lead by example'. :-)</p>
<p>Like,</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>[<span class="dv">1</span>,<span class="dv">3</span>,<span class="op">..</span><span class="dv">8</span>]      <span class="co">-- [1,3,5,7]</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>[<span class="fl">8.2</span>,<span class="fl">8.1</span><span class="op">..</span><span class="fl">7.8</span>] <span class="co">-- [8.2,8.1,8.0,7.9,7.800000000000001]</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a>[<span class="dv">5</span>,<span class="dv">3</span><span class="op">..</span>(<span class="op">-</span><span class="dv">1</span>)]    <span class="co">-- [5,3,1,-1]. Note the need for parenthesis here or haskell</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a>               <span class="co">--             will complain saying it doesn&#39;t know a variable</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a>               <span class="co">--             named &#39;..-&#39;.</span></span></code></pre></div></li>
<li><p>Example: Append an element to the right of a list</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="ot">appendr ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>appendr x [] <span class="ot">=</span> [x]</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>appendr x (y<span class="op">:</span>ys) <span class="ot">=</span> y <span class="op">:</span> (appendr x ys)</span></code></pre></div></li>
<li><p>Example: Merge two lists</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="ot">mrge ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>mrge [] l <span class="ot">=</span> l</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a>mrge (x<span class="op">:</span>xs) l <span class="ot">=</span> x<span class="op">:</span>(mrge xs l)</span></code></pre></div></li>
</ol>
<h3 id="appending-lists">Appending lists</h3>
<p>Via the <code>++</code> function.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a>[<span class="dv">1</span>,<span class="dv">2</span>] <span class="op">++</span> [<span class="dv">3</span>,<span class="dv">4</span>]  <span class="co">-- [1,2,3,4]</span></span></code></pre></div>
<p>I guess <code>++</code> would implemented as something like</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="ot">applists ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>applists [] y <span class="ot">=</span> y</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>applists (x<span class="op">:</span>xs) y <span class="ot">=</span> x <span class="op">:</span> (applists xs y)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a>f [] [<span class="dv">3</span>]</span></code></pre></div>
<ol>
<li><p>Example: Reverse a list</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="ot">revlist ::</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>revlist [] <span class="ot">=</span> []</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>revlist (x<span class="op">:</span>xs) <span class="ot">=</span> (revlist xs) <span class="op">++</span> [x]</span></code></pre></div></li>
<li><p>Example: Check if an integer list is sorted in ascending order</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span class="ot">ascending ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>ascending [] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a>ascending [x] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a>ascending (x<span class="op">:</span>y<span class="op">:</span>ys) <span class="ot">=</span> (x <span class="op">&lt;=</span> y) <span class="op">&amp;&amp;</span> ascending (y<span class="op">:</span>ys)</span></code></pre></div></li>
<li><p>Example: Check if an integer list is alternatively increase and decrease</p>
<p>My attempt (works only when the list starts uphill):</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a><span class="ot">alternating ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a>alternating x <span class="ot">=</span> helper x <span class="dt">True</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true"></a><span class="ot">helper ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true"></a>helper [] up <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true"></a>helper [x] up <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true"></a>helper (x<span class="op">:</span>y<span class="op">:</span>ys) up <span class="ot">=</span> ((up <span class="op">&amp;&amp;</span> x<span class="op">&lt;</span>y) <span class="op">||</span> (<span class="fu">not</span> up <span class="op">&amp;&amp;</span> x<span class="op">&gt;</span>y)) <span class="op">&amp;&amp;</span> (helper (y<span class="op">:</span>ys) (<span class="fu">not</span> up))</span></code></pre></div>
<p>As in lecture (a <em>mutually recursive</em> version):</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a><span class="ot">alternating ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a>alternating l <span class="ot">=</span> (downup l) <span class="op">||</span> (updown l)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true"></a><span class="ot">downup ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true"></a>downup []       <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true"></a>downup [x]      <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true"></a>downup (x<span class="op">:</span>y<span class="op">:</span>ys) <span class="ot">=</span> (x <span class="op">&lt;</span> y) <span class="op">&amp;&amp;</span> (updown (y<span class="op">:</span>ys))</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true"></a></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true"></a><span class="ot">updown ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true"></a>updown []       <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true"></a>updown [x]      <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true"></a>updown (x<span class="op">:</span>y<span class="op">:</span>ys) <span class="ot">=</span> (x <span class="op">&gt;</span> y) <span class="op">&amp;&amp;</span> (downup (y<span class="op">:</span>ys))</span></code></pre></div></li>
</ol>
<h3 id="some-built-in-list-functions">Some built-in list functions</h3>
<ol>
<li><p>init</p>
<p>Returns all except the last element.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a><span class="fu">last</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a><span class="fu">init</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]  <span class="co">-- [1,2]</span></span></code></pre></div></li>
<li><p>last</p>
<p>Returns the last element.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a><span class="fu">last</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a><span class="fu">last</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]  <span class="co">-- 1</span></span></code></pre></div></li>
<li><p>take</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a><span class="fu">take</span><span class="ot"> ::</span> <span class="dt">Int</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true"></a><span class="fu">take</span> <span class="dv">3</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]  <span class="co">-- [1,2,3]</span></span></code></pre></div>
<p>Splits the list at position (not index) n and takes the first part.</p></li>
<li><p>drop</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a><span class="fu">drop</span><span class="ot"> ::</span> <span class="dt">Int</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a><span class="fu">drop</span> <span class="dv">3</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]  <span class="co">-- [4,5]</span></span></code></pre></div>
<p>Splits the list at position (not index) n and drops the first part.</p>
<p>This means that for any list lst,</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true"></a>lst <span class="ot">=</span> (<span class="fu">take</span> n lst) <span class="op">++</span> (<span class="fu">drop</span> n lst)</span></code></pre></div></li>
<li><p>Other functions</p>
<ul>
<li><code>sum</code></li>
<li><code>length</code></li>
<li><code>reverse</code></li>
</ul></li>
<li><p>Example: a custom take function</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a><span class="ot">mytake ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true"></a>mytake _ [] <span class="ot">=</span> []</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true"></a>mytake n (x<span class="op">:</span>xs)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true"></a>  <span class="op">|</span> n <span class="op">==</span> <span class="dv">0</span>    <span class="ot">=</span> []</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true"></a>  <span class="op">|</span> n <span class="op">&gt;</span> <span class="dv">0</span>     <span class="ot">=</span> x <span class="op">:</span> (mytake (n<span class="op">-</span><span class="dv">1</span>) xs)</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> []</span></code></pre></div></li>
<li><p>Example: a custom drop function</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a><span class="ot">mydrop ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true"></a>mydrop _ [] <span class="ot">=</span> []</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true"></a>mydrop n (x<span class="op">:</span>xs)</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true"></a>  <span class="op">|</span> n <span class="op">&lt;=</span> <span class="dv">0</span>    <span class="ot">=</span> x<span class="op">:</span>xs</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> mydrop (n<span class="op">-</span><span class="dv">1</span>) xs</span></code></pre></div></li>
</ol>
<h2 id="characters-and-strings">Characters and strings</h2>
<p><code>ord</code> and <code>chr</code> from <code>Data.Char</code>.</p>
<h3 id="example-capitalize-a-letter">Example: Capitalize a letter</h3>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Char</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true"></a><span class="ot">capitalize ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true"></a>capitalize ch</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true"></a>  <span class="op">|</span> (<span class="ch">&#39;a&#39;</span> <span class="op">&lt;=</span> ch <span class="op">&amp;&amp;</span> ch <span class="op">&lt;=</span> <span class="ch">&#39;z&#39;</span>) <span class="ot">=</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true"></a>        <span class="fu">chr</span> (<span class="fu">ord</span> ch <span class="op">-</span> ((<span class="fu">ord</span> <span class="ch">&#39;a&#39;</span>) <span class="op">-</span> (<span class="fu">ord</span> <span class="ch">&#39;A&#39;</span>)))</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> ch</span></code></pre></div>
<h3 id="example-check-if-a-character-occurs-in-a-string">Example: Check if a character occurs in a string</h3>
<p>My attempt (seems to work):</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a><span class="ot">occurs ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true"></a>occurs _ <span class="st">&quot;&quot;</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true"></a>occurs ch (x<span class="op">:</span>xs) <span class="ot">=</span> (ch <span class="op">==</span> x) <span class="op">||</span> (occurs ch xs)</span></code></pre></div>
<p>Function in lecture:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a><span class="ot">occurs ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true"></a>occurs _ <span class="st">&quot;&quot;</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true"></a>occurs ch (x<span class="op">:</span>xs)</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true"></a>  <span class="op">|</span> ch <span class="op">==</span> x   <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> occurs ch xs</span></code></pre></div>
<h3 id="example-convert-a-function-to-uppercase">Example: Convert a function to uppercase</h3>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Char</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a><span class="ot">toupper ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true"></a>toupper <span class="st">&quot;&quot;</span> <span class="ot">=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true"></a>toupper (x<span class="op">:</span>xs) <span class="ot">=</span> (capitalize x) <span class="op">:</span> (toupper xs)</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true"></a></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true"></a><span class="ot">capitalize ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true"></a>capitalize ch</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true"></a>  <span class="op">|</span> (ch<span class="op">&gt;=</span><span class="ch">&#39;a&#39;</span> <span class="op">&amp;&amp;</span> ch<span class="op">&lt;=</span><span class="ch">&#39;z&#39;</span>) <span class="ot">=</span> <span class="fu">chr</span> ((<span class="fu">ord</span> ch) <span class="op">-</span> ((<span class="fu">ord</span> <span class="ch">&#39;a&#39;</span>) <span class="op">-</span> (<span class="fu">ord</span> <span class="ch">&#39;A&#39;</span>)))</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span>            <span class="ot">=</span> ch</span></code></pre></div>
<h3 id="example-find-first-index-of-a-char-in-a-string">Example: Find first index of a char in a string</h3>
<p>My attempt (seems to work):</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a><span class="co">-- Indexing starts from 0</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true"></a><span class="ot">find ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true"></a>find ch str <span class="ot">=</span> helper ch str <span class="dv">0</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true"></a><span class="ot">helper ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true"></a>helper _ <span class="st">&quot;&quot;</span> _ <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true"></a>helper ch (x<span class="op">:</span>xs) idx</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true"></a>  <span class="op">|</span> x <span class="op">==</span> ch <span class="ot">=</span> idx</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> helper ch xs (idx<span class="op">+</span><span class="dv">1</span>)</span></code></pre></div>
<p>Version in lecture:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a><span class="ot">find ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true"></a>find _ <span class="st">&quot;&quot;</span> <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true"></a>find ch (x<span class="op">:</span>xs)</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true"></a>  <span class="op">|</span> ch <span class="op">==</span> x   <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> (find ch xs)</span></code></pre></div>
<h3 id="example-count-number-of-words-in-string">Example: Count number of words in string</h3>
<p>My attempt (seems to work but considers only spaces):</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true"></a><span class="ot">countwords ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true"></a>countwords <span class="st">&quot;&quot;</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true"></a>countwords (x<span class="op">:</span>xs)</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true"></a>  <span class="op">|</span> xs <span class="op">==</span> []  <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true"></a>  <span class="op">|</span> x <span class="op">==</span> <span class="ch">&#39; &#39;</span>  <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> (countwords xs)</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> countwords xs</span></code></pre></div>
<p>Lecture version:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true"></a><span class="ot">countwords ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true"></a><span class="ot">whitespace ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true"></a>whitespace x</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true"></a>  <span class="op">|</span> x <span class="op">==</span> <span class="ch">&#39; &#39;</span>  <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true"></a>  <span class="op">|</span> x <span class="op">==</span> <span class="ch">&#39;\t&#39;</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true"></a>  <span class="op">|</span> x <span class="op">==</span> <span class="ch">&#39;\n&#39;</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<h2 id="tuples">Tuples</h2>
<p>Collection of values of different types.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true"></a>(<span class="dv">3</span>, <span class="op">-</span><span class="dv">12</span>)<span class="ot"> ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true"></a></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true"></a>(<span class="dv">13</span>, <span class="dt">True</span>, <span class="dv">42</span>)<span class="ot"> ::</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>, <span class="dt">Int</span>)</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true"></a></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true"></a>([<span class="dv">1</span>,<span class="dv">2</span>], <span class="dv">7</span>)<span class="ot"> ::</span> ([<span class="dt">Int</span>], <span class="dt">Int</span>)</span></code></pre></div>
<h2 id="case-expressions"><code>case</code> expressions</h2>
<p>Allows us to do pattern matching even when not inside a function.</p>
<p>Syntax:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true"></a><span class="kw">case</span> <span class="op">&lt;</span>scrutinee<span class="op">-</span>expr<span class="op">&gt;</span> <span class="kw">of</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true"></a>  choice1 <span class="ot">-&gt;</span> value1</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true"></a>  choice2 <span class="ot">-&gt;</span> value2</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true"></a>  <span class="op">...</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true"></a>  choicen <span class="ot">-&gt;</span> valuen</span></code></pre></div>
<h2 id="kind">Kind</h2>
<p>A <em>kind</em> is a type of types.</p>
<p>The 'basic' kind (ie, monotypes) is <em>star</em> written as <code>*</code>.</p>
<p>Eg:</p>
<ul>
<li><code>Bool</code>, <code>Integer</code>, etc have kind <code>*</code>.</li>
<li><--Type constructors like--> <code>Maybe</code> is of kind <code>* -&gt; *</code>.</li>
</ul>
<p>Fun fact: We can use <code>:k</code> or <code>:kind</code> in ghci to get the kind of a type.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="op">:</span>k <span class="dt">Maybe</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true"></a><span class="dt">Maybe</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="op">:</span>k <span class="dt">Monad</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true"></a><span class="dt">Monad</span><span class="ot"> ::</span> (<span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true"></a><span class="co">-- What is &#39;Constraint&#39;?</span></span></code></pre></div>
<p>Reference: <a href="https://wiki.haskell.org/Kind">link</a></p>
<h2 id="type-classes">Type classes</h2>
<p>Type classes are used when we find a common functionality that is repeated across multiple types.</p>
<p>Reference: <a href="https://www.seas.upenn.edu/~cis194/fall16/lectures/04-typeclasses.html">CIS194 course, UPENN</a></p>
<p>For example, in</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true"></a><span class="ot">(==) ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> </span></code></pre></div>
<p>the part to the left of the <code>=&gt;</code> are <strong>type constraints</strong> (the one to its right is, of course, the type).</p>
<p>Also checkout: <em>l8</em></p>
<h3 id="defining-a-type-class">Defining a type class</h3>
<p>A type class definition consists of a set of functions with just their types. ie, without a definition.</p>
<p>Example,</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true"></a><span class="ot">  (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true"></a><span class="ot">  (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>Then we can make an instance of this type class</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Integer</span></span></code></pre></div>
<h2 id="functor">Functor</h2>
<p>Reference: <a href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass">learnyouahaskell.com</a></p>
<ul>
<li>Things that can be mapped over.</li>
<li>Has <code>fmap</code> function.</li>
<li><code>&lt;$&gt; :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</code></li>
<li>Allows applying a pure function inside a parametric type like list.
<ul>
<li>List is a type accepting one parameter, the type of the list.</li>
</ul></li>
<li>Values are wrapped in a context.</li>
<li>Eg: <code>Maybe</code></li>
</ul>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<h3 id="function"><code>&lt;$&gt;</code> function</h3>
<ul>
<li><code>&lt;$&gt;</code> is just the infix version of <code>fmap</code>.</li>
<li>A shorthand for <code>fmap</code></li>
<li><code>f &lt;$&gt; x</code> ≡ <code>fmap f x</code>
<dl>
<dt>~&lt;$&gt;</dt>
<dd>(Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b~
</dd>
</dl></li>
</ul>
<h3 id="fmap-on-functions"><code>fmap</code> on functions</h3>
<p>Reference: <a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html</a></p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true"></a>  <span class="fu">fmap</span> f g <span class="ot">=</span> f <span class="op">.</span> g</span></code></pre></div>
<p>ie, <code>fmap</code> on functions is just function composition.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> foo <span class="ot">=</span> <span class="fu">fmap</span> (<span class="op">+</span><span class="dv">3</span>) (<span class="op">+</span><span class="dv">2</span>)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true"></a>λ<span class="op">&gt;</span> foo <span class="dv">3</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true"></a><span class="dv">8</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true"></a></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true"></a><span class="co">-- which is same as</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true"></a>λ<span class="op">&gt;</span> ((<span class="op">+</span><span class="dv">3</span>) <span class="op">&lt;$&gt;</span> (<span class="op">+</span><span class="dv">2</span>)) <span class="dv">3</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true"></a><span class="dv">8</span></span></code></pre></div>
<h3 id="laws-of-functors">'Laws' of functors</h3>
<p>Reference: <em>l3</em></p>
<ul>
<li><code>fmap id = id</code></li>
<li><code>fmap (f . g) = (fmap f) . (fmap g)</code></li>
</ul>
<h3 id="examples">Examples</h3>
<ol>
<li><p><code>Maybe</code></p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true"></a>  <span class="fu">fmap</span> f (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true"></a>  <span class="fu">fmap</span> _ <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div></li>
<li><p>Haskell lists</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true"></a>  <span class="fu">fmap</span> <span class="ot">=</span> <span class="fu">map</span></span></code></pre></div></li>
<li><p>Binary tree</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">EmptyTree</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true"></a>            <span class="op">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a) <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Read</span>, <span class="dt">Eq</span>)</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true"></a></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Tree</span> <span class="kw">where</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true"></a>  <span class="fu">fmap</span> f <span class="dt">EmptyTree</span> <span class="ot">=</span> <span class="dt">EmptyTree</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true"></a>  <span class="fu">fmap</span> f (<span class="dt">Node</span> x left right) <span class="ot">=</span> <span class="dt">Node</span> (f x) (<span class="fu">fmap</span> f left) (<span class="fu">fmap</span> f right)</span></code></pre></div></li>
<li><p>An 'either' type</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Either</span> a b <span class="ot">=</span> <span class="dt">Left</span> a</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true"></a>                <span class="op">|</span> <span class="dt">Right</span> b <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true"></a></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true"></a><span class="co">-- &#39;(Either a)&#39; is used after &#39;Functor&#39; as only one argument allowed here.</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Either</span> a) <span class="kw">where</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true"></a>  <span class="fu">fmap</span> f (<span class="dt">Right</span> x) <span class="ot">=</span> <span class="dt">Right</span> (f x)</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true"></a>  <span class="fu">fmap</span> f (<span class="dt">Left</span> x) <span class="ot">=</span> <span class="dt">Left</span> x  <span class="co">-- not applied here.</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true"></a></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true"></a><span class="co">-- Here, &#39;f&#39; is of type (b -&gt; c) as &#39;a&#39; is already used.</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true"></a><span class="co">-- So &#39;f&#39; can be used only with &#39;Right&#39; as &#39;b&#39; in &#39;Either a b&#39; corresponds to &#39;Right&#39;.</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true"></a><span class="co">-- And &#39;f&#39; cannot be applied on &#39;Left x&#39; as &#39;x&#39; is of type &#39;a&#39;.</span></span></code></pre></div>
<p>Notice that in the above example <code>f</code> would effectively be of the type <code>(b -&gt; c) -&gt; Either a b -&gt; Either a c</code> (which is same as <code>(b -&gt; c) -&gt; (Either a) b -&gt; (Either a) c</code>).</p>
<p><code>Functor</code> needs a type which can take just one type as parameter. But <code>Either</code> takes two (<code>a</code> and <code>b</code>). So we sort of keep <code>a</code> constant and make <code>b</code> the parameter type.</p>
<p>This means that <code>f</code> can act only on values associated with type <code>b</code>, which in turn means <code>Right b</code> and <em>not</em> <code>Left a</code>. Hence <code>f</code> is not applied on the <code>Left</code> value.</p></li>
</ol>
<h2 id="applicative-functors">Applicative functors</h2>
<ul>
<li>aka applicatives.</li>
<li>defined in <code>Control.Applicative</code></li>
<li>defines two functions:
<ul>
<li><code>pure</code>: takes something and wraps it up in applicative functor
<dl>
<dt>~pure</dt>
<dd>Applicative f =&gt; a -&gt; f a
</dd>
</dl>
<ul>
<li>Injects a pure value into what <code>f</code> represents.</li>
<li>Puts a value in a default context (ie, wraps the value in context)</li>
<li>Effectively same as <code>return</code>.</li>
</ul></li>
<li><code>&lt;*&gt;</code>: extracts a function (the 1st arg) out of the context and applies it on 2nd arg
<ul>
<li>Both parameters are functors.</li>
<li><code>&lt;*&gt; :: Applicative f :; f (a -&gt; b) -&gt; f a -&gt; f b</code></li>
</ul></li>
</ul></li>
<li>In addition to value, functions are also wrapped up in a context.</li>
<li><code>Control.Applicative</code></li>
</ul>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true"></a><span class="kw">class</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true"></a><span class="ot">  pure ::</span> a <span class="ot">-&gt;</span> f a </span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true"></a>  <span class="op">&lt;*&gt;</span><span class="ot"> ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>Some samples:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="dt">Just</span> (<span class="op">+</span><span class="dv">4</span>) <span class="op">&lt;*&gt;</span> <span class="dt">Just</span> <span class="dv">2</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true"></a><span class="dt">Just</span> <span class="dv">6</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true"></a></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true"></a>λ<span class="op">&gt;</span> (<span class="op">*</span>) <span class="op">&lt;$&gt;</span> <span class="dt">Just</span> <span class="dv">3</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true"></a><span class="dt">Just</span> (<span class="op">*</span><span class="dv">3</span>)</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="dt">Just</span> (<span class="op">*</span><span class="dv">3</span>) <span class="op">&lt;*&gt;</span> <span class="dt">Just</span> <span class="dv">4</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true"></a><span class="dt">Just</span> <span class="dv">12</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true"></a></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true"></a><span class="co">-- liftA2 function from Control.Applicative does the same thing</span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true"></a>λ<span class="op">&gt;</span> liftA2 (<span class="op">*</span>) (<span class="dt">Just</span> <span class="dv">3</span>) (<span class="dt">Just</span> <span class="dv">4</span>)</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true"></a><span class="dt">Just</span> <span class="dv">12</span></span></code></pre></div>
<h3 id="laws-of-applicatives">'Laws' of applicatives</h3>
<p>Reference: <em>l2</em></p>
<p><-- - ~pure f <*> x~ ≡ ~fmap f x~--></p>
<dl>
<dt>Identity</dt>
<dd><code>pure id &lt;*&gt; v = v</code>
</dd>
<dt>Homomorphism</dt>
<dd><code>pure f &lt;*&gt; pure x ≡ pure (f x)</code>
</dd>
<dt>Interchange</dt>
<dd><code>u &lt;*&gt; pure y ≡ pure ($ y) &lt;*&gt; u</code>
</dd>
<dt>Composition</dt>
<dd><code>pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w ≡ u &lt;*&gt; (v &lt;*&gt; w)</code>
</dd>
</dl>
<h3 id="examples-1">Examples</h3>
<ol>
<li><p>Maybe</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true"></a>  <span class="fu">pure</span> <span class="ot">=</span> <span class="dt">Just</span>    <span class="co">-- same as: pure x = Just x</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="op">&lt;*&gt;</span> _ <span class="ot">=</span> <span class="dt">Nothing</span>  <span class="co">-- cannot extract a function out of &#39;Nothing&#39;</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true"></a>  (<span class="dt">Just</span> f) <span class="op">&lt;*&gt;</span> something <span class="ot">=</span> <span class="fu">fmap</span> f something</span></code></pre></div></li>
<li><p>Lists</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Applicative</span> [] <span class="kw">where</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true"></a>  <span class="fu">pure</span> x <span class="ot">=</span> [x]</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true"></a>  f <span class="op">&lt;*&gt;</span> x <span class="ot">=</span> <span class="fu">fmap</span> f x<span class="op">?????????????</span></span></code></pre></div></li>
</ol>
<h2 id="monads">Monads</h2>
<p>Monad ⊂ Applicatives ⊂ Functors</p>
<ul>
<li>Applicative functors that allow us to depend on the previous actions (in the case of IO monads).</li>
<li>Allows us to do sequencing (still in the case of IO monads).</li>
<li>Monads ⊆ applicatives ⊆ functors</li>
<li>Applies a function that returns a 'wrapped value'.</li>
</ul>
<p>= <code>Monad</code> is yet another type class (like <code>Functor</code> and <code>Applicative</code>).</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true"></a><span class="ot">  (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span></code></pre></div>
<dl>
<dt>~(&gt;&gt;=)</dt>
<dd>t a -&gt; (a -&gt; t b) -&gt; t b~ : <strong>bind operator</strong>
</dd>
</dl>
<ul>
<li>Allows us to temporarily pull values out from the functor context??</li>
</ul>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true"></a>  (<span class="op">&gt;&gt;=</span>) (<span class="dt">Just</span> x) f <span class="ot">=</span> f x</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true"></a>  (<span class="op">&gt;&gt;=</span>) <span class="dt">Nothing</span> _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>Some samples:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> half x <span class="ot">=</span> <span class="kw">if</span> x <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Just</span> (x <span class="ot">`div`</span> <span class="dv">2</span>)</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true"></a>λ<span class="op">&gt;</span>          <span class="kw">else</span> <span class="dt">Nothing</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="dt">Just</span> <span class="dv">100</span> <span class="op">&gt;&gt;=</span> half</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true"></a><span class="dt">Just</span> <span class="dv">50</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="dt">Just</span> <span class="dv">100</span> <span class="op">&gt;&gt;=</span> half <span class="op">&gt;&gt;=</span> half</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true"></a><span class="dt">Just</span> <span class="dv">25</span></span></code></pre></div>
<p>Haskell doesn't give a way to pull the value out of an IO monad.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true"></a><span class="ot">getInt ::</span> <span class="dt">IO</span> int</span></code></pre></div>
<p>can't get the int part out.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true"></a><span class="ot">getInt ::</span> <span class="dt">IO</span> int</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true"></a><span class="fu">print</span><span class="ot"> ::</span> int <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true"></a>getInt <span class="op">&gt;&gt;=</span> <span class="fu">print</span></span></code></pre></div>
<h3 id="do-notation">do notation</h3>
<ul>
<li>Essentially just syntactic sugar.</li>
<li>We could think of the <code>&lt;-</code> as something like an assignment.</li>
</ul>
<p><a href="https://en.wikibooks.org/wiki/Haskell/do_notation#Translating_the_bind_operator">https://en.wikibooks.org/wiki/Haskell/do_notation#Translating_the_bind_operator</a></p>
<h3 id="examples-2">Examples</h3>
<ol>
<li><p>Capitalize input</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Char</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true"></a></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true"></a><span class="fu">getContents</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true"></a></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true"></a><span class="fu">toUpper</span><span class="ot"> ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true"></a><span class="ot">capitalize ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true"></a>capitalize <span class="ot">=</span> <span class="fu">map</span> <span class="fu">toUpper</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true"></a></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true"></a>main <span class="ot">=</span> (capitalize <span class="op">&lt;$&gt;</span> <span class="fu">getContents</span>) <span class="op">&gt;&gt;=</span> <span class="fu">putStr</span></span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true"></a></span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true"></a><span class="co">-- Lesson: You don&#39;t take value out of the IO monad. We use bind</span></span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true"></a><span class="co">-- for that.</span></span></code></pre></div></li>
<li><p>Reading 2 ints and finding sum</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true"></a>getInt <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> (getInt <span class="op">&gt;&gt;=</span> \y <span class="ot">-&gt;</span> <span class="fu">print</span> (x <span class="op">+</span> y))</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true"></a></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true"></a></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true"></a><span class="co">-- or use do notation and make it look more readable</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true"></a><span class="co">-- indentation matters here</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true"></a><span class="kw">do</span> x <span class="ot">&lt;-</span> getInt</span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true"></a>   y <span class="ot">&lt;-</span> getInt</span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true"></a>   <span class="fu">print</span> <span class="op">$</span> x<span class="op">+</span>y</span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true"></a></span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true"></a><span class="co">-- or if you don&#39;t like indentation</span></span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true"></a><span class="kw">do</span> { x <span class="ot">&lt;-</span> getInt;</span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true"></a>       y <span class="ot">&lt;-</span> getInt;</span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true"></a>      <span class="fu">print</span> <span class="op">$</span> x<span class="op">+</span>y</span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true"></a> }</span></code></pre></div></li>
<li><p>Read n ints and find sum</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true"></a><span class="kw">do</span> n <span class="ot">&lt;-</span> getInt</span></code></pre></div></li>
<li><p>Expression</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Just</span> a <span class="op">|</span> <span class="dt">Nothing</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true"></a></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Const</span> <span class="dt">Int</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true"></a>          <span class="op">|</span> <span class="dt">Plus</span>  <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true"></a>          <span class="op">|</span> <span class="dt">Mult</span>  <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true"></a>          <span class="op">|</span> <span class="dt">Div</span>   <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true"></a></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true"></a><span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Double</span></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true"></a></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true"></a><span class="co">-- one version (INCOMPLETE)</span></span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true"></a>eval (<span class="dt">Const</span> x) <span class="ot">=</span> <span class="dt">Just</span> x</span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true"></a>eval (<span class="dt">Plus</span> x y) <span class="ot">=</span> <span class="kw">case</span> eval x</span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true"></a>                    <span class="dt">Nothing</span> <span class="ot">=&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true"></a>                    <span class="dt">Just</span> xx <span class="ot">=&gt;</span> <span class="kw">case</span> eval y</span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true"></a>                                 <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true"></a>                                 <span class="dt">Just</span> yy <span class="ot">-&gt;</span> xx <span class="op">+</span> yy</span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true"></a></span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true"></a><span class="co">-- another version (INCOMPLETE)</span></span>
<span id="cb80-19"><a href="#cb80-19" aria-hidden="true"></a>eval (<span class="dt">Const</span> x) <span class="ot">=</span> <span class="dt">Just</span> x</span>
<span id="cb80-20"><a href="#cb80-20" aria-hidden="true"></a>eval (<span class="dt">Plus</span> x y) <span class="ot">=</span> (<span class="op">&gt;&gt;=</span>) eval x <span class="op">&lt;*&gt;</span> \x1</span>
<span id="cb80-21"><a href="#cb80-21" aria-hidden="true"></a></span>
<span id="cb80-22"><a href="#cb80-22" aria-hidden="true"></a><span class="co">-- another version with do notation</span></span>
<span id="cb80-23"><a href="#cb80-23" aria-hidden="true"></a><span class="co">-- No need to explicitly worry about the Nothing case!</span></span>
<span id="cb80-24"><a href="#cb80-24" aria-hidden="true"></a><span class="co">-- Feels natural.</span></span>
<span id="cb80-25"><a href="#cb80-25" aria-hidden="true"></a>eval (<span class="dt">Const</span> x) <span class="ot">=</span> <span class="dt">Just</span> x</span>
<span id="cb80-26"><a href="#cb80-26" aria-hidden="true"></a>eval (<span class="dt">Plus</span> x y) <span class="ot">=</span> <span class="kw">do</span> xx <span class="ot">&lt;-</span> eval x</span>
<span id="cb80-27"><a href="#cb80-27" aria-hidden="true"></a>                     yy <span class="ot">&lt;-</span> eval y</span>
<span id="cb80-28"><a href="#cb80-28" aria-hidden="true"></a>                     <span class="fu">pure</span> (xx <span class="op">+</span> yy)</span>
<span id="cb80-29"><a href="#cb80-29" aria-hidden="true"></a></span>
<span id="cb80-30"><a href="#cb80-30" aria-hidden="true"></a><span class="co">-- yet another way (INCOMPLETE)</span></span>
<span id="cb80-31"><a href="#cb80-31" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb80-32"><a href="#cb80-32" aria-hidden="true"></a>  (<span class="op">&gt;&gt;=</span>) (<span class="dt">Just</span> x) fmaybe <span class="ot">=</span> fmaybe x</span>
<span id="cb80-33"><a href="#cb80-33" aria-hidden="true"></a>  (<span class="op">&gt;&gt;=</span>) <span class="dt">Nothing</span>  fmaybe <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div></li>
<li><p>IO monad</p>
<p><code>(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b</code></p>
<p>Can't give definition for this as <code>IO</code> is effectively a blackbox.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true"></a><span class="co">-- a standalone haskell program</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true"></a></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true"></a><span class="co">-- getContents :: IO string</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true"></a></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true"></a>main <span class="ot">=</span> <span class="kw">do</span> inp <span class="ot">&lt;-</span> <span class="fu">getContents</span></span></code></pre></div></li>
<li><p>Parser combinator??</p>
<pre><code>data Result a = OK a String
              | Error String

newtype Parser a = Parser {runParser :: String -&gt; Result a}

instance Functor Result where
  fmap f (OK a s) = OK (f a) s
  fmap _ (Error s)    = Error s

instance Applicative Parser where
-- INCOMPLETE

instance Monad Parser where
-- INCOMPLETE
</code></pre>
<p>TODO: Look at parsec (<a href="https://en.wikipedia.org/wiki/Parsec_(parser)">Wikipedia</a>), megaparsec, attoparsec (parser combinator libraries? for haskell)</p></li>
</ol>
<h3 id="io-monad-1"><code>IO</code> monad</h3>
<p>Three functions:</p>
<dl>
<dt>~getLine</dt>
<dd>IO String~ :: Read a line from stdin. Accepts no parameters.
</dd>
<dt>~readFile</dt>
<dd>FilePath -&gt; IO String~ :: Accepts the path to a file and returns its contents.
</dd>
<dt>~putStrLn</dt>
<dd>String -&gt; IO ()~ :: Accepts a string and prints it to stdout.
</dd>
</dl>
<p>So,</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true"></a><span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> <span class="fu">readFile</span> <span class="op">&gt;&gt;=</span> <span class="fu">putStrLn</span></span></code></pre></div>
<p>can be used to accept a file name, read that file and print its contents.</p>
<h3 id="then"><code>(&gt;&gt;)</code> (then)</h3>
<div class="sourceCode" id="cb84"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true"></a><span class="ot">(&gt;&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b</span></code></pre></div>
<ul>
<li>Like <code>(&gt;&gt;=)</code> except that state is not carried over</li>
<li>Kind of a sequencing operation</li>
</ul>
<p>A do notation that doesn't use <code>&lt;-</code> is desugared using <code>&gt;&gt;</code> instead of <code>&gt;&gt;=</code>.</p>
<pre><code>do
  action1
  action2
  action3
</code></pre>
<p>is same as:</p>
<pre><code>action1 &gt;&gt; action2 &gt;&gt; action3
</code></pre>
<p><a href="https://en.wikibooks.org/wiki/Haskell/do_notation#Translating_the_then_operator">https://en.wikibooks.org/wiki/Haskell/do_notation#Translating_the_then_operator</a></p>
<p>—</p>
<pre><code>Prelude&gt; [1,2] &gt;&gt; [3,4]
[3,4,3,4]
</code></pre>
<p>Looks like for each element in <code>[1,2]</code>, the <code>[3,4]</code> is done.</p>
<ul>
<li>Modeling of non-determinism at play.</li>
</ul>
<h2 id="state-monad">State monad</h2>
<ul>
<li>'wraps computations in the context of reading and modifying a global state object.' <a href="https://mmhaskell.com/monads/state">¹⁷</a></li>
<li>State is sort of made part of type.</li>
</ul>
<div class="sourceCode" id="cb88"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true"></a><span class="co">-- State is a predefined type</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true"></a><span class="co">-- https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-State-Lazy.html#t:State</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true"></a></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true"></a><span class="co">--          state</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true"></a><span class="co">--           | </span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true"></a><span class="ot">get ::</span> <span class="dt">State</span> s s</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true"></a><span class="co">--             |</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true"></a><span class="co">--             rv</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true"></a></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true"></a><span class="ot">put ::</span> <span class="dt">State</span> s ()</span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true"></a></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true"></a><span class="co">-- Get both final state and final result</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true"></a><span class="ot">runState ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> (a, s)</span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true"></a></span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true"></a><span class="co">-- Get just final result</span></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true"></a><span class="ot">evalState ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> a</span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true"></a></span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true"></a><span class="co">-- Get just final state</span></span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true"></a><span class="ot">execState ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s</span></code></pre></div>
<p>Refs:</p>
<ul>
<li><a href="https://mmhaskell.com/monads/state">https://mmhaskell.com/monads/state</a></li>
<li><a href="https://wiki.haskell.org/State_Monad">https://wiki.haskell.org/State_Monad</a></li>
<li><a href="https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-State-Lazy.html">https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-State-Lazy.html</a></li>
</ul>
<h2 id="fun-facts">Fun facts</h2>
<h3 id="kinds">Kinds</h3>
<p>A kind is type of a type.</p>
<p>Can be seen in ghci with <code>:k</code>.</p>
<h3 id="concrete-type">Concrete type</h3>
<ul>
<li>A type that isn't parametrized.</li>
<li>Values of this type can only have types that are concrete.</li>
</ul>
<h3 id="position-of-argument-to-partially-applied-functions-matters">Position of argument to partially applied functions matters</h3>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> (<span class="st">&quot;hi&quot;</span><span class="op">++</span>) <span class="st">&quot;hello&quot;</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true"></a><span class="st">&quot;hihello&quot;</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true"></a>λ<span class="op">&gt;</span> (<span class="op">++</span><span class="st">&quot;hi&quot;</span>) <span class="st">&quot;hello&quot;</span></span></code></pre></div>
<h2 id="more-built-in-functions">More built-in functions</h2>
<h3 id="flip"><code>flip</code></h3>
<p>Takes a function taking two arguments along with those two arguments and reverses the order of arguments before passing them to the function.</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true"></a><span class="co">-- flip :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">flip</span> (<span class="op">-</span>) <span class="dv">3</span> <span class="dv">2</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true"></a><span class="op">-</span><span class="dv">1</span></span></code></pre></div>
<h2 id="newtype-vs-data"><code>newtype</code> vs <code>data</code></h2>
<p>Difference is that types defined with <code>newtype</code> would be 'erased' at compile time.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">IntPair</span> <span class="ot">=</span> <span class="dt">IPair</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true"></a><span class="dt">IPair</span> <span class="dv">3</span> <span class="dv">2</span></span></code></pre></div>
<p>would be like <a href="https://stackoverflow.com/questions/5889696/difference-between-data-and-newtype-in-haskell">⁶</a></p>
<div class="sourceCode" id="cb92"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true"></a> <span class="dt">IPair</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true"></a>  <span class="op">/</span>\</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true"></a> <span class="op">/</span>  \</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true"></a><span class="dv">3</span>    <span class="dv">2</span></span></code></pre></div>
<p>whereas</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true"></a><span class="co">-- Constructor for a &#39;newtype&#39; can have only one field.</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true"></a><span class="co">-- So a tuple is used instead.</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">IntPair</span> <span class="ot">=</span> <span class="dt">IPair</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span></code></pre></div>
<p>would be something like</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true"></a> ( , )  </span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true"></a>  <span class="op">/</span>\</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true"></a> <span class="op">/</span>  \</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true"></a><span class="dv">3</span>    <span class="dv">2</span></span></code></pre></div>
<p>as if the <code>IPair</code> part never existed.</p>
<table>
<thead>
<tr class="header">
<th><code>newtype</code></th>
<th><code>data</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Erased at compile-time</td>
<td>Remains after compilation</td>
</tr>
<tr class="even">
<td>Faster. Less overhead</td>
<td>Slower. More overhead</td>
</tr>
<tr class="odd">
<td>Only single constructor</td>
<td>No limit on constructor count</td>
</tr>
<tr class="even">
<td>Strict / eager evaluation</td>
<td>Lazy evaluation</td>
</tr>
</tbody>
</table>
<p>An example of the eager evaluation of <code>newtype</code> 'constructors' and lazy evaluation of <code>data</code> constructors <a href="https://stackoverflow.com/questions/2649305/why-is-there-data-and-newtype-in-haskell/">⁷</a>:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">DUndef</span> <span class="ot">=</span> <span class="dt">Dundef</span> <span class="dt">Int</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true"></a>              <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">NUndef</span> <span class="ot">=</span> <span class="dt">Nundef</span> <span class="dt">Int</span></span></code></pre></div>
<p>and doing <code>Dundef undefined</code> will cause exception. But doing <code>Nundef undefined</code> won't. Because the evaluation is done eagerly in the case of <code>DUndef</code> values but lazily on <code>NUndef</code> values.</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="dt">Dundef</span> <span class="fu">undefined</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true"></a><span class="dt">Dundef</span> <span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> Prelude.undefined</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true"></a><span class="dt">CallStack</span> (from <span class="dt">HasCallStack</span>)<span class="op">:</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true"></a>  <span class="fu">error</span>, called at libraries<span class="op">/</span>base<span class="op">/</span><span class="dt">GHC</span><span class="op">/</span>Err.hs<span class="op">:</span><span class="dv">79</span><span class="op">:</span><span class="dv">14</span> <span class="kw">in</span> base<span class="op">:</span><span class="dt">GHC.Err</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true"></a>  <span class="fu">undefined</span>, called at <span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">5</span><span class="op">:</span><span class="dv">8</span> <span class="kw">in</span> interactive<span class="op">:</span><span class="dt">Ghci2</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true"></a></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true"></a>λ<span class="op">&gt;</span> a<span class="ot">=</span><span class="dt">Nundef</span> <span class="fu">undefined</span></span></code></pre></div>
<h2 id="type-constructors">Type constructors</h2>
<p>For example, <code>Maybe</code> is not a proper type of its own, but is rather a type constructor.</p>
<p>We got to apply <code>Maybe</code> to a proper type to get another proper type out of it. Like <code>Maybe Bool</code>.</p>
<h2 id="data-constructors">Data constructors</h2>
<p>These seem to be the kind of constructors that we commonly refer to when we just say 'constructors'.</p>
<p>For example, <code>Nothing</code> and <code>Just</code> are data constructors of <code>Maybe</code>.</p>
<p>Reference: <a href="https://www.seas.upenn.edu/~cis194/fall16/lectures/08-functor-applicative.html">CIS194</a></p>
<h2 id="type-class-reference">Type class reference</h2>
<h2 id="gadt-extension">GADT (extension)</h2>
<p><a href="https://wiki.haskell.org/GADTs_for_dummies">https://wiki.haskell.org/GADTs_for_dummies</a></p>
<div class="sourceCode" id="cb97"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">T</span> a <span class="kw">where</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true"></a>    <span class="dt">D1</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">T</span> <span class="dt">String</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true"></a>    <span class="dt">D2</span><span class="ot"> ::</span> <span class="dt">T</span> <span class="dt">Bool</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true"></a>    <span class="dt">D3</span><span class="ot"> ::</span> (a,a) <span class="ot">-&gt;</span> <span class="dt">T</span> [a]</span></code></pre></div>
<p>ie, you can sort of specify the type family to which individual constructors belong. Kinda like in Coq.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids">http://learnyouahaskell.com/functors-applicative-functors-and-monoids</a></li>
</ul>
<h2 id="unsorted-examples">Unsorted examples</h2>
<div class="sourceCode" id="cb98"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t <span class="fu">max</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true"></a><span class="fu">max</span><span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true"></a></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">max</span> <span class="dv">3</span> <span class="dv">4</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true"></a><span class="dv">4</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true"></a></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">max</span> <span class="op">&lt;$&gt;</span> <span class="dt">Just</span> <span class="dv">3</span></span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="co">-- Just (max 3)</span></span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="co">-- of type Maybe (Int -&gt; Int)</span></span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true"></a></span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">max</span> <span class="op">&lt;$&gt;</span> <span class="dt">Just</span> <span class="dv">3</span> <span class="op">&lt;*&gt;</span> <span class="dt">Just</span> <span class="dv">4</span></span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="co">-- ie, (max &lt;$&gt; Just 3) &lt;*&gt; Just 4</span></span>
<span id="cb98-13"><a href="#cb98-13" aria-hidden="true"></a><span class="dt">Just</span> <span class="dv">4</span></span></code></pre></div>
<h3 id="custom-maybe">Custom Maybe</h3>
<div class="sourceCode" id="cb99"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">CMaybe</span> a <span class="ot">=</span> <span class="dt">CJust</span> a</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true"></a>              <span class="op">|</span> <span class="dt">CNothing</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true"></a>              <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true"></a></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">CMaybe</span> <span class="kw">where</span></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true"></a>  <span class="co">-- fmap :: (a -&gt; b) -&gt; CMaybe a -&gt; CMaybe b</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true"></a>  <span class="fu">fmap</span> f (<span class="dt">CJust</span> x) <span class="ot">=</span> <span class="dt">CJust</span> (f x)</span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true"></a>  <span class="fu">fmap</span> _ <span class="dt">CNothing</span>  <span class="ot">=</span> <span class="dt">CNothing</span></span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true"></a></span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true"></a><span class="co">-- λ&gt; (+5) &lt;$&gt; CJust 3</span></span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true"></a><span class="co">-- CJust 8</span></span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true"></a></span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">CMaybe</span> <span class="kw">where</span></span>
<span id="cb99-14"><a href="#cb99-14" aria-hidden="true"></a>  <span class="co">-- pure :: a -&gt; CMaybe a</span></span>
<span id="cb99-15"><a href="#cb99-15" aria-hidden="true"></a>  <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">CJust</span> x</span>
<span id="cb99-16"><a href="#cb99-16" aria-hidden="true"></a></span>
<span id="cb99-17"><a href="#cb99-17" aria-hidden="true"></a>  <span class="co">-- (&lt;*&gt;) :: CMaybe (a -&gt; b) -&gt; CMaybe a -&gt; CMaybe b</span></span>
<span id="cb99-18"><a href="#cb99-18" aria-hidden="true"></a>  (<span class="op">&lt;*&gt;</span>) (<span class="dt">CJust</span> f) (<span class="dt">CJust</span> x) <span class="ot">=</span> <span class="dt">CJust</span> (f x)</span>
<span id="cb99-19"><a href="#cb99-19" aria-hidden="true"></a>  (<span class="op">&lt;*&gt;</span>) (<span class="dt">CJust</span> f) <span class="dt">CNothing</span>  <span class="ot">=</span> <span class="dt">CNothing</span></span>
<span id="cb99-20"><a href="#cb99-20" aria-hidden="true"></a>  (<span class="op">&lt;*&gt;</span>) <span class="dt">CNothing</span>  _ <span class="ot">=</span> <span class="dt">CNothing</span></span>
<span id="cb99-21"><a href="#cb99-21" aria-hidden="true"></a></span>
<span id="cb99-22"><a href="#cb99-22" aria-hidden="true"></a><span class="co">-- λ&gt; max &lt;$&gt; CJust 3 &lt;*&gt; CJust 4</span></span>
<span id="cb99-23"><a href="#cb99-23" aria-hidden="true"></a><span class="co">-- CJust 4</span></span>
<span id="cb99-24"><a href="#cb99-24" aria-hidden="true"></a></span>
<span id="cb99-25"><a href="#cb99-25" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">CMaybe</span> <span class="kw">where</span></span>
<span id="cb99-26"><a href="#cb99-26" aria-hidden="true"></a>  <span class="co">-- (&gt;&gt;=) :: CMaybe a -&gt; (a -&gt; CMaybe b) -&gt; CMaybe b</span></span>
<span id="cb99-27"><a href="#cb99-27" aria-hidden="true"></a>  (<span class="op">&gt;&gt;=</span>) (<span class="dt">CJust</span> x) f <span class="ot">=</span> f x</span>
<span id="cb99-28"><a href="#cb99-28" aria-hidden="true"></a>  (<span class="op">&gt;&gt;=</span>) <span class="dt">CNothing</span> _  <span class="ot">=</span> <span class="dt">CNothing</span></span>
<span id="cb99-29"><a href="#cb99-29" aria-hidden="true"></a></span>
<span id="cb99-30"><a href="#cb99-30" aria-hidden="true"></a><span class="co">-- Correct type: testfn :: (Show a) =&gt; a -&gt; CMaybe a -- ✓ </span></span>
<span id="cb99-31"><a href="#cb99-31" aria-hidden="true"></a><span class="co">-- Wrong type: testfn :: Int -&gt; CMaybe String        -- ✗</span></span>
<span id="cb99-32"><a href="#cb99-32" aria-hidden="true"></a>testfn x <span class="ot">=</span> <span class="dt">CJust</span> (<span class="fu">show</span> x)</span>
<span id="cb99-33"><a href="#cb99-33" aria-hidden="true"></a></span>
<span id="cb99-34"><a href="#cb99-34" aria-hidden="true"></a><span class="co">{-</span></span>
<span id="cb99-35"><a href="#cb99-35" aria-hidden="true"></a><span class="co">λ&gt; tesfn 3</span></span>
<span id="cb99-36"><a href="#cb99-36" aria-hidden="true"></a><span class="co">CJust &quot;3&quot;</span></span>
<span id="cb99-37"><a href="#cb99-37" aria-hidden="true"></a></span>
<span id="cb99-38"><a href="#cb99-38" aria-hidden="true"></a><span class="co">λ&gt; tesfn 3.14</span></span>
<span id="cb99-39"><a href="#cb99-39" aria-hidden="true"></a><span class="co">CJust &quot;3.14&quot;</span></span>
<span id="cb99-40"><a href="#cb99-40" aria-hidden="true"></a></span>
<span id="cb99-41"><a href="#cb99-41" aria-hidden="true"></a><span class="co">λ&gt; tesfn &quot;pi&quot;</span></span>
<span id="cb99-42"><a href="#cb99-42" aria-hidden="true"></a><span class="co">CJust &quot;\&quot;pi\&quot;&quot;</span></span>
<span id="cb99-43"><a href="#cb99-43" aria-hidden="true"></a></span>
<span id="cb99-44"><a href="#cb99-44" aria-hidden="true"></a><span class="co">λ&gt; CJust 3 &gt;&gt;= testfn</span></span>
<span id="cb99-45"><a href="#cb99-45" aria-hidden="true"></a><span class="co">CJust &quot;3&quot;</span></span>
<span id="cb99-46"><a href="#cb99-46" aria-hidden="true"></a></span>
<span id="cb99-47"><a href="#cb99-47" aria-hidden="true"></a><span class="co">λ&gt; CNothing &gt;&gt;= testfn</span></span>
<span id="cb99-48"><a href="#cb99-48" aria-hidden="true"></a><span class="co">CNothing</span></span>
<span id="cb99-49"><a href="#cb99-49" aria-hidden="true"></a><span class="co">-}</span></span></code></pre></div>
<h3 id="quiz-4-questions">Quiz 4 questions</h3>
<ol>
<li><p>1</p>
<p>Consider the binary tree data type given by</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true"></a>            <span class="op">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> a) a (<span class="dt">Tree</span> a)</span></code></pre></div>
<p>Similar to the <code>ZipList</code> instance give an <code>Applicative</code> instance for binary trees where the <code>tf (&lt;*&gt;) tx</code> applies the functions at each node in the tree <code>tf : Tree (a -&gt; b)</code> to the corresponding node in the tree <code>tx : Tree a</code> (shown pictorially below).</p>
<pre><code>  f₁           x₁           f₁x₁
 / \    &lt;*&gt;   / \     =     /  \
f₂  f₃       x₂  x₃       f₂x₂  f₃x₃
</code></pre>
<hr />
<div class="sourceCode" id="cb102"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true"></a>            <span class="op">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> a) a (<span class="dt">Tree</span> a)</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true"></a>            <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true"></a></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Tree</span> <span class="kw">where</span></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true"></a>  <span class="co">-- fmap :: (a -&gt; b) -&gt; Tree a -&gt; Tree b</span></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true"></a>  <span class="fu">fmap</span> f (<span class="dt">Node</span> left val right) <span class="ot">=</span> <span class="dt">Node</span> (<span class="fu">fmap</span> f left) (f val) (<span class="fu">fmap</span> f right)</span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true"></a>  <span class="fu">fmap</span> _ <span class="dt">Empty</span>                 <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true"></a></span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Tree</span> <span class="kw">where</span></span>
<span id="cb102-11"><a href="#cb102-11" aria-hidden="true"></a>  <span class="co">-- pure :: a -&gt; Tree a</span></span>
<span id="cb102-12"><a href="#cb102-12" aria-hidden="true"></a>  <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">Node</span> <span class="dt">Empty</span> x <span class="dt">Empty</span></span>
<span id="cb102-13"><a href="#cb102-13" aria-hidden="true"></a></span>
<span id="cb102-14"><a href="#cb102-14" aria-hidden="true"></a>  <span class="co">-- &lt;*&gt; :: Tree (a -&gt; b) -&gt; Tree a -&gt; Tree b</span></span>
<span id="cb102-15"><a href="#cb102-15" aria-hidden="true"></a>  <span class="co">-- ie, a tree where each leaf node is a function from a to b</span></span>
<span id="cb102-16"><a href="#cb102-16" aria-hidden="true"></a>  (<span class="op">&lt;*&gt;</span>) (<span class="dt">Node</span> fleft f fright) (<span class="dt">Node</span> left val right) <span class="ot">=</span> <span class="dt">Node</span> (fleft <span class="op">&lt;*&gt;</span> left) (f val) (fright <span class="op">&lt;*&gt;</span> right)</span>
<span id="cb102-17"><a href="#cb102-17" aria-hidden="true"></a>  (<span class="op">&lt;*&gt;</span>) <span class="dt">Empty</span> _ <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb102-18"><a href="#cb102-18" aria-hidden="true"></a>  (<span class="op">&lt;*&gt;</span>) _ <span class="dt">Empty</span> <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb102-19"><a href="#cb102-19" aria-hidden="true"></a></span>
<span id="cb102-20"><a href="#cb102-20" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Tree</span> <span class="kw">where</span></span>
<span id="cb102-21"><a href="#cb102-21" aria-hidden="true"></a>  <span class="co">-- (&gt;&gt;=) :: Tree a -&gt; (a -&gt; Tree b) -&gt; Tree b</span></span>
<span id="cb102-22"><a href="#cb102-22" aria-hidden="true"></a>  (<span class="op">&gt;&gt;=</span>) (<span class="dt">Node</span> left val right) f <span class="ot">=</span> <span class="dt">Node</span> (left <span class="op">&gt;&gt;=</span> f) (f val) (right <span class="op">&gt;&gt;=</span> f)</span>
<span id="cb102-23"><a href="#cb102-23" aria-hidden="true"></a>  (<span class="op">&gt;&gt;=</span>) <span class="dt">Empty</span> _ <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb102-24"><a href="#cb102-24" aria-hidden="true"></a></span>
<span id="cb102-25"><a href="#cb102-25" aria-hidden="true"></a>ftree <span class="ot">=</span> <span class="dt">Node</span> <span class="dt">Empty</span> (<span class="op">+</span>) <span class="dt">Empty</span></span>
<span id="cb102-26"><a href="#cb102-26" aria-hidden="true"></a>tree1 <span class="ot">=</span> <span class="dt">Node</span> <span class="dt">Empty</span> <span class="dv">3</span> <span class="dt">Empty</span></span>
<span id="cb102-27"><a href="#cb102-27" aria-hidden="true"></a>tree2 <span class="ot">=</span> <span class="dt">Node</span> <span class="dt">Empty</span> <span class="dv">5</span> <span class="dt">Empty</span></span>
<span id="cb102-28"><a href="#cb102-28" aria-hidden="true"></a>tree3 <span class="ot">=</span> <span class="dt">Node</span> (<span class="dt">Node</span> <span class="dt">Empty</span> <span class="dv">5</span> <span class="dt">Empty</span>) <span class="dv">6</span> <span class="dt">Empty</span></span>
<span id="cb102-29"><a href="#cb102-29" aria-hidden="true"></a></span>
<span id="cb102-30"><a href="#cb102-30" aria-hidden="true"></a><span class="co">{-</span></span>
<span id="cb102-31"><a href="#cb102-31" aria-hidden="true"></a><span class="co">λ&gt; (+3) &lt;$&gt; tree1</span></span>
<span id="cb102-32"><a href="#cb102-32" aria-hidden="true"></a><span class="co">Node Empty 6 Empty</span></span>
<span id="cb102-33"><a href="#cb102-33" aria-hidden="true"></a></span>
<span id="cb102-34"><a href="#cb102-34" aria-hidden="true"></a><span class="co">λ&gt; (+) &lt;$&gt; tree1 &lt;*&gt; tree2</span></span>
<span id="cb102-35"><a href="#cb102-35" aria-hidden="true"></a><span class="co">Node Empty 8 Empty</span></span>
<span id="cb102-36"><a href="#cb102-36" aria-hidden="true"></a></span>
<span id="cb102-37"><a href="#cb102-37" aria-hidden="true"></a><span class="co">λ&gt; ftree &lt;*&gt; tree1 &lt;*&gt; tree2</span></span>
<span id="cb102-38"><a href="#cb102-38" aria-hidden="true"></a><span class="co">Node Empty 8 Empty</span></span>
<span id="cb102-39"><a href="#cb102-39" aria-hidden="true"></a></span>
<span id="cb102-40"><a href="#cb102-40" aria-hidden="true"></a><span class="co">λ&gt; ftree &lt;*&gt; tree1 &lt;*&gt; tree3</span></span>
<span id="cb102-41"><a href="#cb102-41" aria-hidden="true"></a><span class="co">Node Empty 9 Empty</span></span>
<span id="cb102-42"><a href="#cb102-42" aria-hidden="true"></a><span class="co">-}</span></span></code></pre></div></li>
</ol>
<h3 id="leafy-binary-tree">Leafy binary tree</h3>
<div class="sourceCode" id="cb103"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">LTree</span> a <span class="ot">=</span> <span class="dt">Leaf</span> a</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true"></a>             <span class="op">|</span> <span class="dt">Node</span> (<span class="dt">LTree</span> a) (<span class="dt">Ltree</span> a)</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true"></a>             <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true"></a></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">LTree</span> <span class="kw">where</span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true"></a>  <span class="co">-- fmap :: (a -&gt; b) -&gt; a -&gt; b</span></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true"></a>  <span class="fu">fmap</span> f (<span class="dt">Node</span> left right) <span class="ot">=</span> <span class="dt">Node</span> (f <span class="op">&lt;$&gt;</span> left) (f <span class="op">&lt;$&gt;</span> right)</span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true"></a>  <span class="fu">fmap</span> f (<span class="dt">Leaf</span> x) <span class="ot">=</span> f x</span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true"></a></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">LTree</span> <span class="kw">where</span></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true"></a>  <span class="co">-- pure :: a -&gt; LTree a</span></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true"></a>  <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">Leaf</span> x</span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true"></a></span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true"></a>  <span class="co">-- &lt;*&gt; :: LTree (a -&gt; b) -&gt; LTree a -&gt; LTree b</span></span>
<span id="cb103-15"><a href="#cb103-15" aria-hidden="true"></a>  (<span class="op">&lt;*&gt;</span>) (<span class="dt">Node</span> fleft fright) (<span class="dt">Node</span> left right) <span class="ot">=</span> <span class="dt">Node</span> (fleft <span class="op">&lt;*&gt;</span> left) (fright <span class="op">&lt;*&gt;</span> right)</span>
<span id="cb103-16"><a href="#cb103-16" aria-hidden="true"></a>  (<span class="op">&lt;*&gt;</span>) (<span class="dt">Leaf</span> fx) (<span class="dt">Leaf</span> x) <span class="ot">=</span> fx x</span>
<span id="cb103-17"><a href="#cb103-17" aria-hidden="true"></a>  (<span class="op">&lt;*&gt;</span>) _ <span class="dt">Empty</span> <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb103-18"><a href="#cb103-18" aria-hidden="true"></a>  (<span class="op">&lt;*&gt;</span>) <span class="dt">Empty</span> _ <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb103-19"><a href="#cb103-19" aria-hidden="true"></a></span>
<span id="cb103-20"><a href="#cb103-20" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">LTree</span> <span class="kw">where</span></span>
<span id="cb103-21"><a href="#cb103-21" aria-hidden="true"></a>  <span class="co">-- (&gt;&gt;=) :: LTree a -&gt; (a -&gt; LTree b) -&gt; LTree b</span></span>
<span id="cb103-22"><a href="#cb103-22" aria-hidden="true"></a>  (<span class="op">&gt;&gt;=</span>) (<span class="dt">Node</span> left right) f <span class="ot">=</span> <span class="dt">Node</span> (left <span class="op">&gt;&gt;=</span> f) (right <span class="op">&gt;&gt;=</span> f)</span>
<span id="cb103-23"><a href="#cb103-23" aria-hidden="true"></a>  (<span class="op">&gt;&gt;=</span>) (<span class="dt">Leaf</span> x) f          <span class="ot">=</span> <span class="dt">Leaf</span> (f x)</span>
<span id="cb103-24"><a href="#cb103-24" aria-hidden="true"></a></span>
<span id="cb103-25"><a href="#cb103-25" aria-hidden="true"></a><span class="co">-- tree1 = Node (Node Empty 3 Empty) 4 (Node Empty 5 Empty)</span></span></code></pre></div>
<h3 id="a-result-type">A Result type</h3>
<div class="sourceCode" id="cb104"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Result</span> err ok <span class="ot">=</span> <span class="dt">Error</span> err</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true"></a>                   <span class="op">|</span> <span class="dt">Okay</span> ok</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true"></a></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Result</span> err) <span class="kw">where</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true"></a>  <span class="co">-- fmap :: (a -&gt; b) -&gt; Result err a -&gt; Result err b</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true"></a>  <span class="fu">fmap</span> f (<span class="dt">Error</span> e) <span class="ot">=</span> <span class="dt">Error</span> e</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true"></a>  <span class="fu">fmap</span> f (<span class="dt">Okay</span> x)  <span class="ot">=</span> <span class="dt">Okay</span> (f x)</span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true"></a></span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Result</span> err) <span class="kw">where</span></span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true"></a>  <span class="co">-- pure :: a -&gt; Result err a</span></span>
<span id="cb104-11"><a href="#cb104-11" aria-hidden="true"></a>  <span class="fu">pure</span> (<span class="dt">Error</span> e) <span class="ot">=</span> <span class="dt">Error</span> e</span>
<span id="cb104-12"><a href="#cb104-12" aria-hidden="true"></a>  <span class="fu">pure</span> (<span class="dt">Okay</span> e) <span class="ot">=</span> <span class="dt">Error</span> e</span></code></pre></div>
<h2 id="prime-number-generation">Prime number generation</h2>
<div class="sourceCode" id="cb105"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true"></a><span class="co">-- Magic of laziness! :)</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true"></a></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true"></a><span class="co">-- | Not! Eratosthenes sieve.</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true"></a><span class="co">-- http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true"></a><span class="ot">sieve ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true"></a>sieve [] <span class="ot">=</span> []</span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true"></a>sieve (n<span class="op">:</span>ns) <span class="ot">=</span> n <span class="op">:</span> (sieve <span class="op">$</span> <span class="fu">filter</span> (\x <span class="ot">-&gt;</span> <span class="fu">mod</span> x n <span class="op">/=</span> <span class="dv">0</span>) ns)</span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true"></a><span class="co">-- λ&gt; sieve [2,3..50]</span></span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true"></a><span class="co">-- [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47</span></span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true"></a></span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true"></a><span class="co">-- | Find nth prime number</span></span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true"></a>primes</span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true"></a><span class="ot">  ::</span> <span class="dt">Int</span>  <span class="co">-- ^ n</span></span>
<span id="cb105-14"><a href="#cb105-14" aria-hidden="true"></a>  <span class="ot">-&gt;</span> <span class="dt">Int</span>  <span class="co">-- ^ nth prime number</span></span>
<span id="cb105-15"><a href="#cb105-15" aria-hidden="true"></a>primes n <span class="ot">=</span> (sieve [<span class="dv">2</span><span class="op">..</span>]) <span class="op">!!</span> n</span>
<span id="cb105-16"><a href="#cb105-16" aria-hidden="true"></a><span class="co">-- λ&gt; primes 8</span></span>
<span id="cb105-17"><a href="#cb105-17" aria-hidden="true"></a><span class="co">-- 23</span></span>
<span id="cb105-18"><a href="#cb105-18" aria-hidden="true"></a></span>
<span id="cb105-19"><a href="#cb105-19" aria-hidden="true"></a><span class="co">-- | Find first n prime numbers</span></span>
<span id="cb105-20"><a href="#cb105-20" aria-hidden="true"></a>firstnprimes</span>
<span id="cb105-21"><a href="#cb105-21" aria-hidden="true"></a><span class="ot">  ::</span> <span class="dt">Int</span>    <span class="co">-- ^ n</span></span>
<span id="cb105-22"><a href="#cb105-22" aria-hidden="true"></a>  <span class="ot">-&gt;</span> [<span class="dt">Int</span>]  <span class="co">-- ^ list of first n prime numbers</span></span>
<span id="cb105-23"><a href="#cb105-23" aria-hidden="true"></a>firstnprimes n <span class="ot">=</span> <span class="fu">take</span> n <span class="op">$</span> sieve [<span class="dv">2</span><span class="op">..</span>]</span>
<span id="cb105-24"><a href="#cb105-24" aria-hidden="true"></a><span class="co">-- λ&gt; firstnprimes 10</span></span>
<span id="cb105-25"><a href="#cb105-25" aria-hidden="true"></a><span class="co">-- [2,3,5,7,11,13,17,19,23,29]</span></span></code></pre></div>
<h2 id="some-builtin-type-classes">Some builtin type classes</h2>
<ul>
<li><a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/GHC-Enum.html">Enum</a>: enumerate all values from the (finite) typ</li>
<li>Ord: total ordering?</li>
</ul>
<h2 id="some-functions">Some functions</h2>
<p><code>unwords</code>: Take a list of strings and make a single space separated string.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">unwords</span> [<span class="st">&quot;hello&quot;</span>, <span class="st">&quot;world&quot;</span>]</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true"></a><span class="st">&quot;hello world&quot;</span></span></code></pre></div>
<h2 id="haddock">Haddock</h2>
<p><a href="https://haskell-haddock.readthedocs.io/en/latest/markup.html">https://haskell-haddock.readthedocs.io/en/latest/markup.html</a></p>
<ul>
<li><p><code>|</code></p></li>
<li><p><code>^</code></p></li>
<li><p><code>{-# .... #-}</code>: Module attributes</p></li>
<li><p>Verbatim: <code>@&lt;text&gt;@</code></p></li>
<li><p>Linkable code reference: <code>'var_name'</code></p></li>
</ul>
<h2 id="doubt">Doubt</h2>
<ul>
<li><code>Monad</code> has kind <code>(* -&gt; *) -&gt; Constraint</code>. What is <code>Constraint</code>?</li>
</ul>
</div>
</body>
</html>
