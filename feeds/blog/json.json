{"version": "https://www.jsonfeed.org/version/1.1/", "title": "famubu's blog", "home_page_url": "{root}/blog/index.html", "feed_url": "https://rawtext.club/~famubu/feeds/blog/json.json", "description": "Software stuff, random musings...", "authors": [{"name": "famubu", "url": "https://rawtext.club/~famubu/index.html", "language": "en"}], "items": [{"id": "https://rawtext.club/~famubu/blog/hello-pvs.html", "url": "https://rawtext.club/~famubu/blog/hello-pvs.html", "title": "A taste of the PVS theorem prover", "content_html": "<div id=\"content-container\">\n<p>I had attended the <a href=\"https://fm.csl.sri.com/SSFT22/\">Eleventh\nSummer School on Formal Techniques</a> (SSFT 2022) online.</p>\n<p>During this event, I first got to use the PVS theorem prover. Had\nheard a lot about it before the SSFT, but had never used it. Have come\nacross a mention of the <code>grind</code> proof strategy of PVS more\nthan a couple of times.</p>\n<p>This blog post is a description of the first proof that I did with\nPVS, along with some stuff that I found out while doing it.</p>\n<p>Mistakes, if any, are my own and corrections are welcome.</p>\n<p>(I originally wrote this blog post right after the SSFT back in 2022,\nbut didn't finish writing all I wished to. Was worried of errors in what\nI had written, so refrained from putting it up online.</p>\n<p>But hey, better to make it public and let others correct me than to\nkeep this to myself, right? \ud83d\ude42)</p>\n<p>By the way, registration for this year's SSFT is open at the moment.\nIt was a great experience for me even though I joined online. If\npossible, do join physically!</p>\n<hr/>\n<p>PVS, which stands for Prototype Verification System, is an\ninteractive theorem prover.</p>\n<p>Proofs are constructed with guidance from the user. A batch mode is\navailable to re-run pre-existing proofs, though.</p>\n<p>The logic used by PVS is based on <a href=\"https://en.wikipedia.org/wiki/Sequent_calculus\">sequent\ncalculus</a>.</p>\n<p>Proofs in PVS seem to be in the 'backward-reasoning' style. We go\nfrom the goal to the assumptions. A top-down approach.</p>\n<p>Users can define custom procedures, known as <em>strategies</em>\n(analogous to tactics in coq), to construct proofs for automating the\ntheorem proving process.</p>\n<p>PVS is implemented mainly in common lisp and requires a common-lisp\nruntime to work.</p>\n<p>Emacs or vscode can be used as front-ends to interact with the pvs\nsystem. I used emacs.</p>\n<p>Let me show one of the first proofs that we did in PVS. Quite an\namusing one too.</p>\n<h2 id=\"a-simple-proof-in-pvs\">A simple proof in PVS</h2>\n<p>One of the proofs that we did during the summer school was inspired\nby the lyrics of the song <a href=\"https://en.wikipedia.org/wiki/Everybody_Loves_My_Baby\">'Everybody\nloves my baby'</a> which went like:</p>\n<blockquote>\n<p>Everybody loves my baby<br/>\nBut my baby don't love nobody but me.</p>\n</blockquote>\n<p>There are two conditions:</p>\n<ul>\n<li>Everyone loves my baby.</li>\n<li>My baby loves only me.</li>\n</ul>\n<p>So we could formulate them as:</p>\n<ul>\n<li><code>\u2200p, loves(p, baby)</code></li>\n<li><code>\u2200p, loves(baby, p) \u2192 (p = me)</code></li>\n</ul>\n<p>where <code>loves(a, b)</code> means <code>a</code> loves\n<code>b</code>, but not necessarily <code>b</code> loves\n<code>a</code>.</p>\n<p>With these assumptions, it is possible to prove that 'me' and 'my\nbaby' are the same person!</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>No</th>\n<th>Statement</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>1</td>\n<td><code>\u2200p, loves(p, baby)</code></td>\n<td>Assumption</td>\n</tr>\n<tr class=\"even\">\n<td>2</td>\n<td><code>\u2200p, loves(baby, p) \u2192 (p = me)</code></td>\n<td>Assumption</td>\n</tr>\n<tr class=\"odd\">\n<td>3</td>\n<td><code>loves(baby, baby)</code></td>\n<td>1 with <code>p=baby</code></td>\n</tr>\n<tr class=\"even\">\n<td>4</td>\n<td><code>loves(baby, baby) \u2192 (baby = me)</code></td>\n<td>2 with <code>p=baby</code></td>\n</tr>\n<tr class=\"odd\">\n<td>5</td>\n<td><code>baby = me</code></td>\n<td>Modus ponens with 4 and 3</td>\n</tr>\n</tbody>\n</table>\n<p>But of course, 'me' and 'my baby' can't have been same person. We\nwere able to derive this due to an incomplete way of framing the\nassumptions.</p>\n<p>Look at <code>\u2200p, loves(baby, p) \u2192 (p = me)</code>. The baby may love\nthemselves, which gives <code>loves(baby, baby)</code>, but that doesn't\nmean <code>baby = me</code>.</p>\n<p>This is an example of an attempt to prove a theorem exposing a bug in\nthe specification.</p>\n<p>Anway, let's try doing the proof with these assumptions itself.\nWriting this down as a PVS specification file (a file with\n<code>.pvs</code> extension),</p>\n<pre class=\"pvs\"><code>mybaby: THEORY\nBEGIN\n  % 'person' is an inhabited Type\n  % The '+' means that there is at least one term of the type 'person'\n  person: TYPE+\n\n  % 'me' and 'mybaby' are people\n  % ie, they are values of the type 'person'\n  me, mybaby: person\n\n  % A few variables of type 'person'\n  x, y, z: VAR person\n\n  % A predicate accepting two values of type 'person'\n  loves(x, y): boolean\n\n  % Everyone loves my baby\n  everybodyLovesMyBaby: AXIOM\n    forall x: loves(x, mybaby)\n\n  % If my baby loves somebody, that is me\n  mybabyLovesOnlyMe: AXIOM\n    loves(mybaby, x) IMPLIES x = me\n\n  % We this, we can prove that mybaby and me are same!\n  mybabyIsMe: LEMMA\n    mybaby = me\nEND mybaby\n</code></pre>\n<p>(Anything that follows a <code>%</code> in a line is a comment till\nthe end of that line.)</p>\n<p>First, we got to type check this file.</p>\n<p>In the emacs interface, we can do <code>C-c C-t</code> for that\n(<code>C</code> is Ctrl key).</p>\n<p>If the file type checked successfully, we would get a message\nlike</p>\n<pre><code>mybaby typechecked in 0.01s: No TCCs generated; 1 msg\n</code></pre>\n<p>TCC means Type-Correctness Conditions. They are obligations generated\nby the type checker 'which must be discharged before the corresponding\ntheory is considered type correct'<a href=\"https://pvs.csl.sri.com/doc/pvs-system-guide.pdf\">\u00b9\u2070</a>. The\nexample that we considering is quite simple and doesn't have any\nTCCs.</p>\n<p>Now position the cursor over a part of the theorem to be proven,\nwhich in our case is <code>mybabyIsMe</code> and do\n<code>C-c p</code>.</p>\n<p><code>mybabyIsMe</code> spans two lines in our source file, placing\nthe cursor at any point in those two lines seems to be okay, even on\nwhite space as long as it is on one of those two lines.</p>\n<p>On starting the proof, we would get</p>\n<pre><code>mybabyIsMe :\n\n  |-------\n{1}   mybaby = me\n\nRule?\n</code></pre>\n<p>This is a sequent (have mentioned a little about sequents in PVS as\npart of the addendum of this blog post).</p>\n<p>The <code>Rule?</code> is the prompt asking for our next input to\nguide the proof.</p>\n<p>Here are some handy keyboard shortcuts that can be used to retrive\ncommands from usage history:</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Shortcut</th>\n<th>Use</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>M-p</code></td>\n<td>Last command</td>\n</tr>\n<tr class=\"even\">\n<td><code>M-n</code></td>\n<td>Next command</td>\n</tr>\n<tr class=\"odd\">\n<td><code>M-s</code></td>\n<td>Auto-complete from history</td>\n</tr>\n</tbody>\n</table>\n<p>Back to our proof, in</p>\n<pre><code>  |-------\n{1}   mybaby = me\n</code></pre>\n<p>the part above the line are the assumptions (which at this point is\nnothing) and that below the line is the current goal that needs to be\nproved.</p>\n<p>Time to bring in our <code>everybodyLovesMyBaby</code> axiom. Type\nthe following into the prompt:</p>\n<pre><code>(lemma \"everybodyLovesMyBaby\")\n</code></pre>\n<p>and the sequent becomes:</p>\n<pre><code>{-1}  FORALL (x): loves(x, mybaby)\n  |-------\n[1]   mybaby = me\n</code></pre>\n<p>Let's instantiate this using <code>mybaby</code></p>\n<pre><code>(inst - \"mybaby\")\n</code></pre>\n<p>and we infer that the baby loves himself.</p>\n<pre><code>{-1}  loves(mybaby, mybaby)\n  |-------\n[1]   mybaby = me\n</code></pre>\n<p>Bringing <code>mybabyLovesOnlyMe</code> as well into the picture,</p>\n<pre><code>(lemma \"mybabyLovesOnlyMe\")\n</code></pre>\n<p>and the sequent changes to</p>\n<pre><code>{-1}  FORALL (x: person): loves(mybaby, x) IMPLIES x = me\n[-2]  loves(mybaby, mybaby)\n  |-------\n[1]   mybaby = me\n</code></pre>\n<p>Now we got <code>loves(mybaby, mybaby)</code> and\n<code>FORALL (x: person):\nloves(mybaby, x) IMPLIES x = me</code>. So we can sort of follow the\nimplication</p>\n<pre><code>(forward-chain -)\n</code></pre>\n<p>and the proof is done.</p>\n<pre><code>Forward chaining on -,\nQ.E.D.\n</code></pre>\n<p>A transcript of the last proven proof can be shown with <code>M-x\nshow-last-proof</code>.</p>\n<p>For the proof that we just did, it shows as:</p>\n<pre><code>mybabyIsMe :\n\n  |-------\n{1}   mybaby = me\n\nApplying everybodyLovesMyBaby  then\nInstantiating the top quantifier in - with the terms:\n mybaby, and then\nApplying mybabyLovesOnlyMe\n this simplifies to:\nmybabyIsMe :\n\n{-1}  FORALL (x: person): loves(mybaby, x) IMPLIES x = me\n{-2}  loves(mybaby, mybaby)\n  |-------\n[1]   mybaby = me\n\nForward chaining on -,\n This completes the proof of mybabyIsMe.\n\nQ.E.D.\n</code></pre>\n<p>Once a proof is complete, it would be saved in a <code>.prf</code>\nfile. This is the proof script that records the steps that we took in\nthe course of proving the theorem. The proof can be rerun and verified\nif needed using this.<a href=\"https://hal.inria.fr/hal-01673517/document\">\u00b9\u2078</a> This file is\nnot meant to be edited by users and is best left alone so that only PVS\nitself handles it.</p>\n<p><code>.prf</code> file associated with the proof that we just did\nlooks something like this:</p>\n<pre><code>(mybaby\n (mybabyIsMe 0\n  (mybabyIsMe-1 nil 1823146151\n   (\"\" (lemma \"everybodyLovesMyBaby\")\n    ((\"\" (inst - \"mybaby\")\n      ((\"\" (lemma \"mybabyLovesOnlyMe\") ((\"\" (forward-chain -) nil nil))\n        nil))\n      nil))\n    nil)\n   ((person nonempty-type-decl nil mybaby nil)\n    (mybaby const-decl \"person\" mybaby nil)\n    (mybabyLovesOnlyMe formula-decl nil mybaby nil)\n    (everybodyLovesMyBaby formula-decl nil mybaby nil))\n   shostak)))\n</code></pre>\n<p>I think <code>shostak</code> here refers to the name of a decision\nprocedure brought about by the work of R. E. Shostak.</p>\n<p>Tried to find the file format of the <code>.prf</code> files, but\ncouldn't find it. It being a internal format and thereby being\nsusceptible to frequent changes may be a reason. Found a <a href=\"https://pvs.csl.sri.com/doc/ProofLite-4.2.pdf\">2007 document</a>\nthat mentions it though.</p>\n<h2 id=\"proof-tree\">Proof tree</h2>\n<p>The goal of a PVS proof is to construct a tree where the leaf nodes\nare trivially true (ie, <code>TRUE</code>).</p>\n<p>In the case of the 'my baby loves only me' example, the tree looks\nlike</p>\n<pre><code>   \u2200p, loves(p, baby)       \u2200p, loves(baby, p) \u2192 (p = me)\n  -------------------     ---------------------------------\n   loves(baby, baby)       loves(baby, baby) \u2192 (baby = me)\n-------------------------------------------------------------\n                      baby = me\n</code></pre>\n<p>We can think of the proof tree growing from the root\n(<code>baby = me</code>) to the leaves.</p>\n<pre><code>\u22a2 \u2200p: loves(p, baby)           \u22a2 \u2200p: loves(baby, p) \u2192 (p = me)         \n  |                              |                                            \n  |                              |                                            \n  +-- \u22a2 loves(baby, baby)        +-- \u22a2 loves(baby, baby) \u2192 (baby = me)      \n        |                              |\n        |                              |\n        +------------------------------+\n                      |\n                      |\n                      +-- \u22a2 baby = me\n</code></pre>\n<p>The proof starts off as a sequent without antecedents with just the\ntheorem to be proved as consequent.</p>\n<p>From the <a href=\"https://pvs.csl.sri.com/doc/pvs-prover-guide.pdf\">PVS prover\nguide</a>:</p>\n<blockquote>\n<p>'At any time in a PVS proof, attention is focused on some sequent\nthat is a leaf node in the current proof tree'.</p>\n</blockquote>\n<h2 id=\"editing-proof\">Editing proof</h2>\n<p>A proof which has already been completed can be edited in a 'proof\nbuffer'.</p>\n<p>Position cursor on the theorem whose proof needs to be edited and do\n<code>M-x edit-proof</code>.</p>\n<p>For our 'my baby loves only me' proof, the (unedited) proof is:</p>\n<pre><code>;;; Proof mybabyIsMe-1 for formula mybaby.mybabyIsMe\n(\"\"\n (lemma \"everybodyLovesMyBaby\")\n (inst - \"mybaby\")\n (lemma \"mybabyLovesOnlyMe\")\n (forward-chain -))\n</code></pre>\n<p>Looks pretty much like lisp, doesn't it? Probably because it\n<em>is</em> lisp.</p>\n<p>After editing, the new proof can be attached to the same or different\nformula with <code>M-x install-proof</code>.</p>\n<p>(Haven't properly figured this one yet, really. But this is roughly\nhow it is.)</p>\n<h2 id=\"pvs-interface\">PVS interface</h2>\n<p>The default PVS interface is just emacs with some customizations.\nThere are commands and key-bindings for some PVS-specific things, but\nother than that it's just emacs.</p>\n<p>This also means that if you already have emacs set up, that\nconfiguration would also be loaded (provided there are no conflicts with\nthose of pvs, I guess). For instance, I had evil-mode set up and could\nuse it in the emacs launched by pvs as well.</p>\n<p>Here are a few default key-bindings/commands:</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Description</th>\n<th>Command</th>\n<th>Key binding</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>Start proof</td>\n<td><code>M-x pr</code></td>\n<td><code>C-c p</code></td>\n</tr>\n<tr class=\"even\">\n<td>Type check</td>\n<td><code>M-x typecheck</code></td>\n<td><code>C-c C-t</code></td>\n</tr>\n<tr class=\"odd\">\n<td>Show TCCs</td>\n<td><code>M-x show-tccs</code></td>\n<td><code>C-c C-q s</code></td>\n</tr>\n<tr class=\"even\">\n<td>Quit</td>\n<td><code>M-x exit-pvs</code></td>\n<td><code>C-x C-c</code></td>\n</tr>\n<tr class=\"odd\">\n<td>Suspend PVS</td>\n<td><code>M-x suspend-pvs</code></td>\n<td><code>C-x C-z</code></td>\n</tr>\n</tbody>\n</table>\n<p>We can change these key-bindings if we needed as it's just emacs,\nwhich is well known for its customizability.</p>\n<p>Still, emacs can take time to get used to (although it is very well\nworth the time), and a <a href=\"https://github.com/nasa/vscode-pvs\">plugin</a> (made by some folks\nat NASA) to use VSCode editor as the interface to PVS is also\navailable.</p>\n<p>Lot of people at NASA seem to use PVS. They have published a large\nPVS library named the <a href=\"https://shemesh.larc.nasa.gov/fm/pvs/PVS-library/\">NASA PVS\nlibrary</a>.</p>\n<h2 id=\"pvs-back-end\">PVS 'back-end'</h2>\n<p>In the PVS website, two 'flavours' of PVS can be seen. One with <a href=\"http://www.sbcl.org/\">SBCL</a> and the other with Allegro.</p>\n<p>PVS needs an implementation of common lisp to work and SBCL and\nAllegro are two such implementations.</p>\n<p>(SBCL stands for Steel Bank Common Lisp. A reference to\nCarnegie-Mellon University, the place from where SBCL originated. Andrew\nCarnegie was involved in the steel industry and Andrew Mellon was a\nbanker.<a href=\"https://en.wikipedia.org/wiki/Steel_Bank_Common_Lisp\">\u00b3</a>)</p>\n<p>One of the differences between SBCL and Allegro is that SBCL is free\nsoftware whereas Allegro is a commercial implementation and comes with\nsome restrictions although non-commerical use seems okay.</p>\n<p>Another difference is that PVS operates faster when used with Allegro\nwhen compared to SBCL. Probably a reason why the <a href=\"https://pvs.csl.sri.com/downloads.html\">PVS website</a> recommends\nAllegro.</p>\n<p>I first tried to run the example mentioned in this blog post using\nPVS-SBCL, but it had some bug that prevented the proof from getting\ncompleted (the '<code>(forward-chain -)</code>' wouldn't go through).\nBut PVS-Allegro had no problem with it.</p>\n<p>Maybe the Allegro version gets more priority in the PVS development\nprocess.</p>\n<p>Anyway, now I use the Allegro version. Still would've liked to try\nSBCL version when it gets fixed though.</p>\n<h2 id=\"fun-fact\">Fun fact</h2>\n<p>The 2015 Hollywood film Martian shows PVS running on a computer on\nmultiple occasions. Shankar had mentioned this during his session and I\nlater found out <a href=\"https://shemesh.larc.nasa.gov/fm/pvs/TheMartian/\">a web-page</a>\nthat talks about it:</p>\n<p>As evinced by the NASA PVS library, PVS enjoys some popularity at\nNASA. Yet PVS is not a tool meant to be used in space. But it can help\nin making sure that the stuff being sent to space would work as it is\nmeant to be by verifying their designs.</p>\n<h2 id=\"references\">References</h2>\n<ul>\n<li><a href=\"https://pvs.csl.sri.com/doc/pvs-system-guide.pdf\">PVS\nSystem Guide (v7.1)</a></li>\n<li><a href=\"https://pvs.csl.sri.com/doc/pvs-prover-guide.pdf\">PVS\nProver Guide (v7.1)</a></li>\n<li><a href=\"https://www.cs.umd.edu/~mvz/handouts/wift-tutorial.pdf\">A\nTutorial Introduction to PVS</a></li>\n<li><em>PVS: A Prototype Verification System</em> (1992) - S. Owre, J.\nM. Rushby, N. Shankar</li>\n</ul>\n<ul>\n<li><a href=\"https://hal.inria.fr/hal-01673517/document\"><em>Proof\ncertificates in PVS</em></a> - Gilbert, Fr\u00e9d\u00e9ric (International\nConference on Interactive Theorem Proving. Springer, Cham, 2017)</li>\n<li><a href=\"https://shemesh.larc.nasa.gov/fm/pvs/LASER2011/Strategies/Lecture-a4.pdf\">Slides\ndiscussing PVS rules and strategies</a></li>\n<li>Cyrluk, D., Rajan, S., Shankar, N. and Srivas, M.K.,\n<strong>1994</strong>, September. <em>Effective theorem proving for\nhardware verification</em>. In International Conference on Theorem\nProvers in Circuit Design (pp. 203-222). Springer, Berlin,\nHeidelberg.</li>\n</ul>\n<h2 id=\"addendum-sequents\">Addendum: Sequents</h2>\n<p>Proof goals are <a href=\"https://en.wikipedia.org/wiki/Sequent\">sequents</a> (a la\nGentzen's <a href=\"https://en.wikipedia.org/wiki/Sequent_calculus\">sequent\ncalculus</a>).</p>\n<p>Sequents are 'conditional tautologies'. Could think of them as\nformulas which are true only if some conditions are satisfied.</p>\n<p>Sequents are usually represented like</p>\n<pre><code> A\u2081, A\u2082, ..., A\u2099\n-----------------\n B\u2081, B\u2082, ..., B\u2098\n</code></pre>\n<p>or equivalently, like</p>\n<pre><code>A\u2081, A\u2082, ..., A\u2099 \u22a2 B\u2081, B\u2082, ..., B\u2098\n</code></pre>\n<p>This means that if all the A\u1d62-s are true, then at least one of the\nB\u1d62-s must be true.</p>\n<pre><code>A\u2081 \u2227 A\u2082 \u2227 ... \u2227 A\u2099 \u22a2 B\u2081 \u2228 B\u2082 \u2228 ... \u2228 B\u2098\n</code></pre>\n<p>The A\u1d62-s are the antecedents and the B\u1d62-s are the consequents.</p>\n<p>Both groups may simply be thought as formulas.</p>\n<pre><code>                                    \u23ab\n                    \u23ab               \u23ae\n A\u2081, A\u2082, ..., A\u2099    \u23ac antecedents   \u23ae\n                    \u23ad               \u23ae\n-----------------                   \u23ac sequent\n                    \u23ab               \u23ae\n B\u2081, B\u2082, ..., B\u2098    \u23ac consequents   \u23ae\n                    \u23ad               \u23ae\n                                    \u23ad\n</code></pre>\n<p>A sequent without antecedents is always true. For example,\n<code>\u22a2 M</code> is always true (sort of an unconditional\ntautology).</p>\n<p>In PVS, a sequent looks like <a href=\"https://pvs.csl.sri.com/doc/pvs-prover-guide.pdf\">\u00b9\u00b9</a></p>\n<pre><code>{-1}  A1  \n{-2}  A2  \n      .   \n      .   \n[-n]  An  \n  |-------\n{1}   B1  \n[2]   B2  \n      .   \n      .   \n{-m}  Bm  \n</code></pre>\n<p>The antecedents (with negative numbering) appear above the line\nwhereas the consequents (with positive numbers) show up under the\nline.</p>\n<p>The numbers are used to name the forumlas.</p>\n<p>Newly introduced formulas have their number enclosed within curly\nbraces. And those formulas which were there in a parent goal itself have\ntheir number surrounded by square brackets.</p>\n</div>", "summary": "First encounter with PVS theorem prover", "date_published": "2024-03-06T00:00:00+00:00", "tags": ["logic", "proof", "types"]}]}