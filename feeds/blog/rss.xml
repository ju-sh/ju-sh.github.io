<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>
      famubu: Home
    </title>
    <link>
      https://rawtext.club/~famubu
    </link>
    <description>
      Updates from famubu's site
    </description>
    <generator>
      Script using https://codeberg.org/ju-sh/mrkup
    </generator>
    <language>
      en-us
    </language>
    <atom:link href="https://rawtext.club/~famubu/blog/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>
        A taste of the PVS theorem prover
      </title>
      <link>
        https://rawtext.club/~famubu/blog/hello-pvs.html
      </link>
      <description>
        
&lt;div&gt;
  &lt;div&gt;
    First encounter with PVS theorem prover
  &lt;/div&gt;
  &lt;div&gt;
    &lt;div id=&quot;content-container&quot;&gt;
&lt;p&gt;I had attended the &lt;a href=&quot;https://fm.csl.sri.com/SSFT22/&quot;&gt;Eleventh
Summer School on Formal Techniques&lt;/a&gt; (SSFT 2022) online.&lt;/p&gt;
&lt;p&gt;During this event, I first got to use the PVS theorem prover. Had
heard a lot about it before the SSFT, but had never used it. Have come
across a mention of the &lt;code&gt;grind&lt;/code&gt; proof strategy of PVS more
than a couple of times.&lt;/p&gt;
&lt;p&gt;This blog post is a description of the first proof that I did with
PVS, along with some stuff that I found out while doing it.&lt;/p&gt;
&lt;p&gt;Mistakes, if any, are my own and corrections are welcome.&lt;/p&gt;
&lt;p&gt;(I originally wrote this blog post right after the SSFT back in 2022,
but didn&#x27;t finish writing all I wished to. Was worried of errors in what
I had written, so refrained from putting it up online.&lt;/p&gt;
&lt;p&gt;But hey, better to make it public and let others correct me than to
keep this to myself, right? üôÇ)&lt;/p&gt;
&lt;p&gt;By the way, registration for this year&#x27;s SSFT is open at the moment.
It was a great experience for me even though I joined online. If
possible, do join physically!&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;PVS, which stands for Prototype Verification System, is an
interactive theorem prover.&lt;/p&gt;
&lt;p&gt;Proofs are constructed with guidance from the user. A batch mode is
available to re-run pre-existing proofs, though.&lt;/p&gt;
&lt;p&gt;The logic used by PVS is based on &lt;a href=&quot;https://en.wikipedia.org/wiki/Sequent_calculus&quot;&gt;sequent
calculus&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Proofs in PVS seem to be in the &#x27;backward-reasoning&#x27; style. We go
from the goal to the assumptions. A top-down approach.&lt;/p&gt;
&lt;p&gt;Users can define custom procedures, known as &lt;em&gt;strategies&lt;/em&gt;
(analogous to tactics in coq), to construct proofs for automating the
theorem proving process.&lt;/p&gt;
&lt;p&gt;PVS is implemented mainly in common lisp and requires a common-lisp
runtime to work.&lt;/p&gt;
&lt;p&gt;Emacs or vscode can be used as front-ends to interact with the pvs
system. I used emacs.&lt;/p&gt;
&lt;p&gt;Let me show one of the first proofs that we did in PVS. Quite an
amusing one too.&lt;/p&gt;
&lt;h2 id=&quot;a-simple-proof-in-pvs&quot;&gt;A simple proof in PVS&lt;/h2&gt;
&lt;p&gt;One of the proofs that we did during the summer school was inspired
by the lyrics of the song &lt;a href=&quot;https://en.wikipedia.org/wiki/Everybody_Loves_My_Baby&quot;&gt;&#x27;Everybody
loves my baby&#x27;&lt;/a&gt; which went like:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Everybody loves my baby&lt;br/&gt;
But my baby don&#x27;t love nobody but me.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There are two conditions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Everyone loves my baby.&lt;/li&gt;
&lt;li&gt;My baby loves only me.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So we could formulate them as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;‚àÄp, loves(p, baby)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;‚àÄp, loves(baby, p) ‚Üí (p = me)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;where &lt;code&gt;loves(a, b)&lt;/code&gt; means &lt;code&gt;a&lt;/code&gt; loves
&lt;code&gt;b&lt;/code&gt;, but not necessarily &lt;code&gt;b&lt;/code&gt; loves
&lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With these assumptions, it is possible to prove that &#x27;me&#x27; and &#x27;my
baby&#x27; are the same person!&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;No&lt;/th&gt;
&lt;th&gt;Statement&lt;/th&gt;
&lt;th&gt;Reason&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;code&gt;‚àÄp, loves(p, baby)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Assumption&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;code&gt;‚àÄp, loves(baby, p) ‚Üí (p = me)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Assumption&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;code&gt;loves(baby, baby)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1 with &lt;code&gt;p=baby&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;code&gt;loves(baby, baby) ‚Üí (baby = me)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2 with &lt;code&gt;p=baby&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;code&gt;baby = me&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Modus ponens with 4 and 3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;But of course, &#x27;me&#x27; and &#x27;my baby&#x27; can&#x27;t have been same person. We
were able to derive this due to an incomplete way of framing the
assumptions.&lt;/p&gt;
&lt;p&gt;Look at &lt;code&gt;‚àÄp, loves(baby, p) ‚Üí (p = me)&lt;/code&gt;. The baby may love
themselves, which gives &lt;code&gt;loves(baby, baby)&lt;/code&gt;, but that doesn&#x27;t
mean &lt;code&gt;baby = me&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is an example of an attempt to prove a theorem exposing a bug in
the specification.&lt;/p&gt;
&lt;p&gt;Anway, let&#x27;s try doing the proof with these assumptions itself.
Writing this down as a PVS specification file (a file with
&lt;code&gt;.pvs&lt;/code&gt; extension),&lt;/p&gt;
&lt;pre class=&quot;pvs&quot;&gt;&lt;code&gt;mybaby: THEORY
BEGIN
  % &#x27;person&#x27; is an inhabited Type
  % The &#x27;+&#x27; means that there is at least one term of the type &#x27;person&#x27;
  person: TYPE+

  % &#x27;me&#x27; and &#x27;mybaby&#x27; are people
  % ie, they are values of the type &#x27;person&#x27;
  me, mybaby: person

  % A few variables of type &#x27;person&#x27;
  x, y, z: VAR person

  % A predicate accepting two values of type &#x27;person&#x27;
  loves(x, y): boolean

  % Everyone loves my baby
  everybodyLovesMyBaby: AXIOM
    forall x: loves(x, mybaby)

  % If my baby loves somebody, that is me
  mybabyLovesOnlyMe: AXIOM
    loves(mybaby, x) IMPLIES x = me

  % We this, we can prove that mybaby and me are same!
  mybabyIsMe: LEMMA
    mybaby = me
END mybaby
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Anything that follows a &lt;code&gt;%&lt;/code&gt; in a line is a comment till
the end of that line.)&lt;/p&gt;
&lt;p&gt;First, we got to type check this file.&lt;/p&gt;
&lt;p&gt;In the emacs interface, we can do &lt;code&gt;C-c C-t&lt;/code&gt; for that
(&lt;code&gt;C&lt;/code&gt; is Ctrl key).&lt;/p&gt;
&lt;p&gt;If the file type checked successfully, we would get a message
like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mybaby typechecked in 0.01s: No TCCs generated; 1 msg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TCC means Type-Correctness Conditions. They are obligations generated
by the type checker &#x27;which must be discharged before the corresponding
theory is considered type correct&#x27;&lt;a href=&quot;https://pvs.csl.sri.com/doc/pvs-system-guide.pdf&quot;&gt;¬π‚Å∞&lt;/a&gt;. The
example that we considering is quite simple and doesn&#x27;t have any
TCCs.&lt;/p&gt;
&lt;p&gt;Now position the cursor over a part of the theorem to be proven,
which in our case is &lt;code&gt;mybabyIsMe&lt;/code&gt; and do
&lt;code&gt;C-c p&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mybabyIsMe&lt;/code&gt; spans two lines in our source file, placing
the cursor at any point in those two lines seems to be okay, even on
white space as long as it is on one of those two lines.&lt;/p&gt;
&lt;p&gt;On starting the proof, we would get&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mybabyIsMe :

  |-------
{1}   mybaby = me

Rule?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a sequent (have mentioned a little about sequents in PVS as
part of the addendum of this blog post).&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Rule?&lt;/code&gt; is the prompt asking for our next input to
guide the proof.&lt;/p&gt;
&lt;p&gt;Here are some handy keyboard shortcuts that can be used to retrive
commands from usage history:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;Shortcut&lt;/th&gt;
&lt;th&gt;Use&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;&lt;code&gt;M-p&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Last command&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;&lt;code&gt;M-n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Next command&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;&lt;code&gt;M-s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Auto-complete from history&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Back to our proof, in&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  |-------
{1}   mybaby = me
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the part above the line are the assumptions (which at this point is
nothing) and that below the line is the current goal that needs to be
proved.&lt;/p&gt;
&lt;p&gt;Time to bring in our &lt;code&gt;everybodyLovesMyBaby&lt;/code&gt; axiom. Type
the following into the prompt:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(lemma &quot;everybodyLovesMyBaby&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and the sequent becomes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{-1}  FORALL (x): loves(x, mybaby)
  |-------
[1]   mybaby = me
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&#x27;s instantiate this using &lt;code&gt;mybaby&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(inst - &quot;mybaby&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and we infer that the baby loves himself.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{-1}  loves(mybaby, mybaby)
  |-------
[1]   mybaby = me
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bringing &lt;code&gt;mybabyLovesOnlyMe&lt;/code&gt; as well into the picture,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(lemma &quot;mybabyLovesOnlyMe&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and the sequent changes to&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{-1}  FORALL (x: person): loves(mybaby, x) IMPLIES x = me
[-2]  loves(mybaby, mybaby)
  |-------
[1]   mybaby = me
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we got &lt;code&gt;loves(mybaby, mybaby)&lt;/code&gt; and
&lt;code&gt;FORALL (x: person):
loves(mybaby, x) IMPLIES x = me&lt;/code&gt;. So we can sort of follow the
implication&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(forward-chain -)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and the proof is done.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Forward chaining on -,
Q.E.D.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A transcript of the last proven proof can be shown with &lt;code&gt;M-x
show-last-proof&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For the proof that we just did, it shows as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mybabyIsMe :

  |-------
{1}   mybaby = me

Applying everybodyLovesMyBaby  then
Instantiating the top quantifier in - with the terms:
 mybaby, and then
Applying mybabyLovesOnlyMe
 this simplifies to:
mybabyIsMe :

{-1}  FORALL (x: person): loves(mybaby, x) IMPLIES x = me
{-2}  loves(mybaby, mybaby)
  |-------
[1]   mybaby = me

Forward chaining on -,
 This completes the proof of mybabyIsMe.

Q.E.D.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once a proof is complete, it would be saved in a &lt;code&gt;.prf&lt;/code&gt;
file. This is the proof script that records the steps that we took in
the course of proving the theorem. The proof can be rerun and verified
if needed using this.&lt;a href=&quot;https://hal.inria.fr/hal-01673517/document&quot;&gt;¬π‚Å∏&lt;/a&gt; This file is
not meant to be edited by users and is best left alone so that only PVS
itself handles it.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.prf&lt;/code&gt; file associated with the proof that we just did
looks something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(mybaby
 (mybabyIsMe 0
  (mybabyIsMe-1 nil 1823146151
   (&quot;&quot; (lemma &quot;everybodyLovesMyBaby&quot;)
    ((&quot;&quot; (inst - &quot;mybaby&quot;)
      ((&quot;&quot; (lemma &quot;mybabyLovesOnlyMe&quot;) ((&quot;&quot; (forward-chain -) nil nil))
        nil))
      nil))
    nil)
   ((person nonempty-type-decl nil mybaby nil)
    (mybaby const-decl &quot;person&quot; mybaby nil)
    (mybabyLovesOnlyMe formula-decl nil mybaby nil)
    (everybodyLovesMyBaby formula-decl nil mybaby nil))
   shostak)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I think &lt;code&gt;shostak&lt;/code&gt; here refers to the name of a decision
procedure brought about by the work of R. E. Shostak.&lt;/p&gt;
&lt;p&gt;Tried to find the file format of the &lt;code&gt;.prf&lt;/code&gt; files, but
couldn&#x27;t find it. It being a internal format and thereby being
susceptible to frequent changes may be a reason. Found a &lt;a href=&quot;https://pvs.csl.sri.com/doc/ProofLite-4.2.pdf&quot;&gt;2007 document&lt;/a&gt;
that mentions it though.&lt;/p&gt;
&lt;h2 id=&quot;proof-tree&quot;&gt;Proof tree&lt;/h2&gt;
&lt;p&gt;The goal of a PVS proof is to construct a tree where the leaf nodes
are trivially true (ie, &lt;code&gt;TRUE&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;In the case of the &#x27;my baby loves only me&#x27; example, the tree looks
like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   ‚àÄp, loves(p, baby)       ‚àÄp, loves(baby, p) ‚Üí (p = me)
  -------------------     ---------------------------------
   loves(baby, baby)       loves(baby, baby) ‚Üí (baby = me)
-------------------------------------------------------------
                      baby = me
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can think of the proof tree growing from the root
(&lt;code&gt;baby = me&lt;/code&gt;) to the leaves.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;‚ä¢ ‚àÄp: loves(p, baby)           ‚ä¢ ‚àÄp: loves(baby, p) ‚Üí (p = me)         
  |                              |                                            
  |                              |                                            
  +-- ‚ä¢ loves(baby, baby)        +-- ‚ä¢ loves(baby, baby) ‚Üí (baby = me)      
        |                              |
        |                              |
        +------------------------------+
                      |
                      |
                      +-- ‚ä¢ baby = me
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The proof starts off as a sequent without antecedents with just the
theorem to be proved as consequent.&lt;/p&gt;
&lt;p&gt;From the &lt;a href=&quot;https://pvs.csl.sri.com/doc/pvs-prover-guide.pdf&quot;&gt;PVS prover
guide&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&#x27;At any time in a PVS proof, attention is focused on some sequent
that is a leaf node in the current proof tree&#x27;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;editing-proof&quot;&gt;Editing proof&lt;/h2&gt;
&lt;p&gt;A proof which has already been completed can be edited in a &#x27;proof
buffer&#x27;.&lt;/p&gt;
&lt;p&gt;Position cursor on the theorem whose proof needs to be edited and do
&lt;code&gt;M-x edit-proof&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For our &#x27;my baby loves only me&#x27; proof, the (unedited) proof is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;;;; Proof mybabyIsMe-1 for formula mybaby.mybabyIsMe
(&quot;&quot;
 (lemma &quot;everybodyLovesMyBaby&quot;)
 (inst - &quot;mybaby&quot;)
 (lemma &quot;mybabyLovesOnlyMe&quot;)
 (forward-chain -))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looks pretty much like lisp, doesn&#x27;t it? Probably because it
&lt;em&gt;is&lt;/em&gt; lisp.&lt;/p&gt;
&lt;p&gt;After editing, the new proof can be attached to the same or different
formula with &lt;code&gt;M-x install-proof&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;(Haven&#x27;t properly figured this one yet, really. But this is roughly
how it is.)&lt;/p&gt;
&lt;h2 id=&quot;pvs-interface&quot;&gt;PVS interface&lt;/h2&gt;
&lt;p&gt;The default PVS interface is just emacs with some customizations.
There are commands and key-bindings for some PVS-specific things, but
other than that it&#x27;s just emacs.&lt;/p&gt;
&lt;p&gt;This also means that if you already have emacs set up, that
configuration would also be loaded (provided there are no conflicts with
those of pvs, I guess). For instance, I had evil-mode set up and could
use it in the emacs launched by pvs as well.&lt;/p&gt;
&lt;p&gt;Here are a few default key-bindings/commands:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Key binding&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;Start proof&lt;/td&gt;
&lt;td&gt;&lt;code&gt;M-x pr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;C-c p&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;Type check&lt;/td&gt;
&lt;td&gt;&lt;code&gt;M-x typecheck&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;C-c C-t&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;Show TCCs&lt;/td&gt;
&lt;td&gt;&lt;code&gt;M-x show-tccs&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;C-c C-q s&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;Quit&lt;/td&gt;
&lt;td&gt;&lt;code&gt;M-x exit-pvs&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;C-x C-c&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;Suspend PVS&lt;/td&gt;
&lt;td&gt;&lt;code&gt;M-x suspend-pvs&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;C-x C-z&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;We can change these key-bindings if we needed as it&#x27;s just emacs,
which is well known for its customizability.&lt;/p&gt;
&lt;p&gt;Still, emacs can take time to get used to (although it is very well
worth the time), and a &lt;a href=&quot;https://github.com/nasa/vscode-pvs&quot;&gt;plugin&lt;/a&gt; (made by some folks
at NASA) to use VSCode editor as the interface to PVS is also
available.&lt;/p&gt;
&lt;p&gt;Lot of people at NASA seem to use PVS. They have published a large
PVS library named the &lt;a href=&quot;https://shemesh.larc.nasa.gov/fm/pvs/PVS-library/&quot;&gt;NASA PVS
library&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;pvs-back-end&quot;&gt;PVS &#x27;back-end&#x27;&lt;/h2&gt;
&lt;p&gt;In the PVS website, two &#x27;flavours&#x27; of PVS can be seen. One with &lt;a href=&quot;http://www.sbcl.org/&quot;&gt;SBCL&lt;/a&gt; and the other with Allegro.&lt;/p&gt;
&lt;p&gt;PVS needs an implementation of common lisp to work and SBCL and
Allegro are two such implementations.&lt;/p&gt;
&lt;p&gt;(SBCL stands for Steel Bank Common Lisp. A reference to
Carnegie-Mellon University, the place from where SBCL originated. Andrew
Carnegie was involved in the steel industry and Andrew Mellon was a
banker.&lt;a href=&quot;https://en.wikipedia.org/wiki/Steel_Bank_Common_Lisp&quot;&gt;¬≥&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;One of the differences between SBCL and Allegro is that SBCL is free
software whereas Allegro is a commercial implementation and comes with
some restrictions although non-commerical use seems okay.&lt;/p&gt;
&lt;p&gt;Another difference is that PVS operates faster when used with Allegro
when compared to SBCL. Probably a reason why the &lt;a href=&quot;https://pvs.csl.sri.com/downloads.html&quot;&gt;PVS website&lt;/a&gt; recommends
Allegro.&lt;/p&gt;
&lt;p&gt;I first tried to run the example mentioned in this blog post using
PVS-SBCL, but it had some bug that prevented the proof from getting
completed (the &#x27;&lt;code&gt;(forward-chain -)&lt;/code&gt;&#x27; wouldn&#x27;t go through).
But PVS-Allegro had no problem with it.&lt;/p&gt;
&lt;p&gt;Maybe the Allegro version gets more priority in the PVS development
process.&lt;/p&gt;
&lt;p&gt;Anyway, now I use the Allegro version. Still would&#x27;ve liked to try
SBCL version when it gets fixed though.&lt;/p&gt;
&lt;h2 id=&quot;fun-fact&quot;&gt;Fun fact&lt;/h2&gt;
&lt;p&gt;The 2015 Hollywood film Martian shows PVS running on a computer on
multiple occasions. Shankar had mentioned this during his session and I
later found out &lt;a href=&quot;https://shemesh.larc.nasa.gov/fm/pvs/TheMartian/&quot;&gt;a web-page&lt;/a&gt;
that talks about it:&lt;/p&gt;
&lt;p&gt;As evinced by the NASA PVS library, PVS enjoys some popularity at
NASA. Yet PVS is not a tool meant to be used in space. But it can help
in making sure that the stuff being sent to space would work as it is
meant to be by verifying their designs.&lt;/p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pvs.csl.sri.com/doc/pvs-system-guide.pdf&quot;&gt;PVS
System Guide (v7.1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pvs.csl.sri.com/doc/pvs-prover-guide.pdf&quot;&gt;PVS
Prover Guide (v7.1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cs.umd.edu/~mvz/handouts/wift-tutorial.pdf&quot;&gt;A
Tutorial Introduction to PVS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;PVS: A Prototype Verification System&lt;/em&gt; (1992) - S. Owre, J.
M. Rushby, N. Shankar&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://hal.inria.fr/hal-01673517/document&quot;&gt;&lt;em&gt;Proof
certificates in PVS&lt;/em&gt;&lt;/a&gt; - Gilbert, Fr√©d√©ric (International
Conference on Interactive Theorem Proving. Springer, Cham, 2017)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://shemesh.larc.nasa.gov/fm/pvs/LASER2011/Strategies/Lecture-a4.pdf&quot;&gt;Slides
discussing PVS rules and strategies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Cyrluk, D., Rajan, S., Shankar, N. and Srivas, M.K.,
&lt;strong&gt;1994&lt;/strong&gt;, September. &lt;em&gt;Effective theorem proving for
hardware verification&lt;/em&gt;. In International Conference on Theorem
Provers in Circuit Design (pp. 203-222). Springer, Berlin,
Heidelberg.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;addendum-sequents&quot;&gt;Addendum: Sequents&lt;/h2&gt;
&lt;p&gt;Proof goals are &lt;a href=&quot;https://en.wikipedia.org/wiki/Sequent&quot;&gt;sequents&lt;/a&gt; (a la
Gentzen&#x27;s &lt;a href=&quot;https://en.wikipedia.org/wiki/Sequent_calculus&quot;&gt;sequent
calculus&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Sequents are &#x27;conditional tautologies&#x27;. Could think of them as
formulas which are true only if some conditions are satisfied.&lt;/p&gt;
&lt;p&gt;Sequents are usually represented like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; A‚ÇÅ, A‚ÇÇ, ..., A‚Çô
-----------------
 B‚ÇÅ, B‚ÇÇ, ..., B‚Çò
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or equivalently, like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A‚ÇÅ, A‚ÇÇ, ..., A‚Çô ‚ä¢ B‚ÇÅ, B‚ÇÇ, ..., B‚Çò
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that if all the A·µ¢-s are true, then at least one of the
B·µ¢-s must be true.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A‚ÇÅ ‚àß A‚ÇÇ ‚àß ... ‚àß A‚Çô ‚ä¢ B‚ÇÅ ‚à® B‚ÇÇ ‚à® ... ‚à® B‚Çò
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The A·µ¢-s are the antecedents and the B·µ¢-s are the consequents.&lt;/p&gt;
&lt;p&gt;Both groups may simply be thought as formulas.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                                    ‚é´
                    ‚é´               ‚éÆ
 A‚ÇÅ, A‚ÇÇ, ..., A‚Çô    ‚é¨ antecedents   ‚éÆ
                    ‚é≠               ‚éÆ
-----------------                   ‚é¨ sequent
                    ‚é´               ‚éÆ
 B‚ÇÅ, B‚ÇÇ, ..., B‚Çò    ‚é¨ consequents   ‚éÆ
                    ‚é≠               ‚éÆ
                                    ‚é≠
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A sequent without antecedents is always true. For example,
&lt;code&gt;‚ä¢ M&lt;/code&gt; is always true (sort of an unconditional
tautology).&lt;/p&gt;
&lt;p&gt;In PVS, a sequent looks like &lt;a href=&quot;https://pvs.csl.sri.com/doc/pvs-prover-guide.pdf&quot;&gt;¬π¬π&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{-1}  A1  
{-2}  A2  
      .   
      .   
[-n]  An  
  |-------
{1}   B1  
[2]   B2  
      .   
      .   
{-m}  Bm  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The antecedents (with negative numbering) appear above the line
whereas the consequents (with positive numbers) show up under the
line.&lt;/p&gt;
&lt;p&gt;The numbers are used to name the forumlas.&lt;/p&gt;
&lt;p&gt;Newly introduced formulas have their number enclosed within curly
braces. And those formulas which were there in a parent goal itself have
their number surrounded by square brackets.&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
      </description>
      <pubDate>
        Wed, 06 Mar 2024 00:00:00 GMT
      </pubDate>
      <guid>
        https://rawtext.club/~famubu/blog/hello-pvs.html
      </guid>
      <category>
        logic
      </category>
      <category>
        proof
      </category>
      <category>
        types
      </category>
    </item>
  </channel>
</rss>